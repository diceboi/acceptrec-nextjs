"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/html-to-text";
exports.ids = ["vendor-chunks/html-to-text"];
exports.modules = {

/***/ "(rsc)/./node_modules/html-to-text/lib/html-to-text.cjs":
/*!********************************************************!*\
  !*** ./node_modules/html-to-text/lib/html-to-text.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar pluginHtmlparser2 = __webpack_require__(/*! @selderee/plugin-htmlparser2 */ \"(rsc)/./node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.cjs\");\nvar htmlparser2 = __webpack_require__(/*! htmlparser2 */ \"(rsc)/./node_modules/htmlparser2/lib/index.js\");\nvar selderee = __webpack_require__(/*! selderee */ \"(rsc)/./node_modules/selderee/lib/selderee.cjs\");\nvar merge = __webpack_require__(/*! deepmerge */ \"(rsc)/./node_modules/deepmerge/dist/cjs.js\");\nvar domSerializer = __webpack_require__(/*! dom-serializer */ \"(rsc)/./node_modules/dom-serializer/lib/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar merge__default = /*#__PURE__*/ _interopDefaultLegacy(merge);\n/**\n * Make a recursive function that will only run to a given depth\n * and switches to an alternative function at that depth. \\\n * No limitation if `n` is `undefined` (Just wraps `f` in that case).\n *\n * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.\n * @param   { Function }           f   Function that accepts recursive callback as the first argument.\n * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.\n * @returns { Function }\n */ function limitedDepthRecursive(n, f, g = ()=>undefined) {\n    if (n === undefined) {\n        const f1 = function(...args) {\n            return f(f1, ...args);\n        };\n        return f1;\n    }\n    if (n >= 0) {\n        return function(...args) {\n            return f(limitedDepthRecursive(n - 1, f, g), ...args);\n        };\n    }\n    return g;\n}\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from each side.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */ function trimCharacter(str, char) {\n    let start = 0;\n    let end = str.length;\n    while(start < end && str[start] === char){\n        ++start;\n    }\n    while(end > start && str[end - 1] === char){\n        --end;\n    }\n    return start > 0 || end < str.length ? str.substring(start, end) : str;\n}\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from the end only.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */ function trimCharacterEnd(str, char) {\n    let end = str.length;\n    while(end > 0 && str[end - 1] === char){\n        --end;\n    }\n    return end < str.length ? str.substring(0, end) : str;\n}\n/**\n * Return a new string will all characters replaced with unicode escape sequences.\n * This extreme kind of escaping can used to be safely compose regular expressions.\n *\n * @param { string } str A string to escape.\n * @returns { string } A string of unicode escape sequences.\n */ function unicodeEscape(str) {\n    return str.replace(/[\\s\\S]/g, (c)=>\"\\\\u\" + c.charCodeAt().toString(16).padStart(4, \"0\"));\n}\n/**\n * Deduplicate an array by a given key callback.\n * Item properties are merged recursively and with the preference for last defined values.\n * Of items with the same key, merged item takes the place of the last item,\n * others are omitted.\n *\n * @param { any[] } items An array to deduplicate.\n * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.\n * @returns { any[] }\n */ function mergeDuplicatesPreferLast(items, getKey) {\n    const map = new Map();\n    for(let i = items.length; i-- > 0;){\n        const item = items[i];\n        const key = getKey(item);\n        map.set(key, map.has(key) ? merge__default[\"default\"](item, map.get(key), {\n            arrayMerge: overwriteMerge$1\n        }) : item);\n    }\n    return [\n        ...map.values()\n    ].reverse();\n}\nconst overwriteMerge$1 = (acc, src, options)=>[\n        ...src\n    ];\n/**\n * Get a nested property from an object.\n *\n * @param   { object }   obj  The object to query for the value.\n * @param   { string[] } path The path to the property.\n * @returns { any }\n */ function get(obj, path) {\n    for (const key of path){\n        if (!obj) {\n            return undefined;\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n/**\n * Convert a number into alphabetic sequence representation (Sequence without zeroes).\n *\n * For example: `a, ..., z, aa, ..., zz, aaa, ...`.\n *\n * @param   { number } num              Number to convert. Must be >= 1.\n * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.\n * @param   { number } [base = 26]      Number of characters in the sequence.\n * @returns { string }\n */ function numberToLetterSequence(num, baseChar = \"a\", base = 26) {\n    const digits = [];\n    do {\n        num -= 1;\n        digits.push(num % base);\n        num = num / base >> 0; // quick `floor`\n    }while (num > 0);\n    const baseCode = baseChar.charCodeAt(0);\n    return digits.reverse().map((n)=>String.fromCharCode(baseCode + n)).join(\"\");\n}\nconst I = [\n    \"I\",\n    \"X\",\n    \"C\",\n    \"M\"\n];\nconst V = [\n    \"V\",\n    \"L\",\n    \"D\"\n];\n/**\n * Convert a number to it's Roman representation. No large numbers extension.\n *\n * @param   { number } num Number to convert. `0 < num <= 3999`.\n * @returns { string }\n */ function numberToRoman(num) {\n    return [\n        ...num + \"\"\n    ].map((n)=>+n).reverse().map((v, i)=>v % 5 < 4 ? (v < 5 ? \"\" : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join(\"\");\n}\n/**\n * Helps to build text from words.\n */ class InlineTextBuilder {\n    /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */ constructor(options, maxLineLength = undefined){\n        /** @type { string[][] } */ this.lines = [];\n        /** @type { string[] }   */ this.nextLineWords = [];\n        this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n        this.nextLineAvailableChars = this.maxLineLength;\n        this.wrapCharacters = get(options, [\n            \"longWordSplit\",\n            \"wrapCharacters\"\n        ]) || [];\n        this.forceWrapOnLimit = get(options, [\n            \"longWordSplit\",\n            \"forceWrapOnLimit\"\n        ]) || false;\n        this.stashedSpace = false;\n        this.wordBreakOpportunity = false;\n    }\n    /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */ pushWord(word, noWrap = false) {\n        if (this.nextLineAvailableChars <= 0 && !noWrap) {\n            this.startNewLine();\n        }\n        const isLineStart = this.nextLineWords.length === 0;\n        const cost = word.length + (isLineStart ? 0 : 1);\n        if (cost <= this.nextLineAvailableChars || noWrap) {\n            this.nextLineWords.push(word);\n            this.nextLineAvailableChars -= cost;\n        } else {\n            // The word is moved to a new line - prefer to wrap between words.\n            const [first, ...rest] = this.splitLongWord(word);\n            if (!isLineStart) {\n                this.startNewLine();\n            }\n            this.nextLineWords.push(first);\n            this.nextLineAvailableChars -= first.length;\n            for (const part of rest){\n                this.startNewLine();\n                this.nextLineWords.push(part);\n                this.nextLineAvailableChars -= part.length;\n            }\n        }\n    }\n    /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */ popWord() {\n        const lastWord = this.nextLineWords.pop();\n        if (lastWord !== undefined) {\n            const isLineStart = this.nextLineWords.length === 0;\n            const cost = lastWord.length + (isLineStart ? 0 : 1);\n            this.nextLineAvailableChars += cost;\n        }\n        return lastWord;\n    }\n    /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */ concatWord(word, noWrap = false) {\n        if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n            this.pushWord(word, noWrap);\n            this.wordBreakOpportunity = false;\n        } else {\n            const lastWord = this.popWord();\n            this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);\n        }\n    }\n    /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */ startNewLine(n = 1) {\n        this.lines.push(this.nextLineWords);\n        if (n > 1) {\n            this.lines.push(...Array.from({\n                length: n - 1\n            }, ()=>[]));\n        }\n        this.nextLineWords = [];\n        this.nextLineAvailableChars = this.maxLineLength;\n    }\n    /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */ isEmpty() {\n        return this.lines.length === 0 && this.nextLineWords.length === 0;\n    }\n    clear() {\n        this.lines.length = 0;\n        this.nextLineWords.length = 0;\n        this.nextLineAvailableChars = this.maxLineLength;\n    }\n    /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */ toString() {\n        return [\n            ...this.lines,\n            this.nextLineWords\n        ].map((words)=>words.join(\" \")).join(\"\\n\");\n    }\n    /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */ splitLongWord(word) {\n        const parts = [];\n        let idx = 0;\n        while(word.length > this.maxLineLength){\n            const firstLine = word.substring(0, this.maxLineLength);\n            const remainingChars = word.substring(this.maxLineLength);\n            const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n            if (splitIndex > -1) {\n                word = firstLine.substring(splitIndex + 1) + remainingChars;\n                parts.push(firstLine.substring(0, splitIndex + 1));\n            } else {\n                idx++;\n                if (idx < this.wrapCharacters.length) {\n                    word = firstLine + remainingChars;\n                } else {\n                    if (this.forceWrapOnLimit) {\n                        parts.push(firstLine);\n                        word = remainingChars;\n                        if (word.length > this.maxLineLength) {\n                            continue;\n                        }\n                    } else {\n                        word = firstLine + remainingChars;\n                    }\n                    break;\n                }\n            }\n        }\n        parts.push(word); // Add remaining part to array\n        return parts;\n    }\n}\n/* eslint-disable max-classes-per-file */ class StackItem {\n    constructor(next = null){\n        this.next = next;\n    }\n    getRoot() {\n        return this.next ? this.next : this;\n    }\n}\nclass BlockStackItem extends StackItem {\n    constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined){\n        super(next);\n        this.leadingLineBreaks = leadingLineBreaks;\n        this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);\n        this.rawText = \"\";\n        this.stashedLineBreaks = 0;\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass ListStackItem extends BlockStackItem {\n    constructor(options, next = null, { interRowLineBreaks = 1, leadingLineBreaks = 2, maxLineLength = undefined, maxPrefixLength = 0, prefixAlign = \"left\" } = {}){\n        super(options, next, leadingLineBreaks, maxLineLength);\n        this.maxPrefixLength = maxPrefixLength;\n        this.prefixAlign = prefixAlign;\n        this.interRowLineBreaks = interRowLineBreaks;\n    }\n}\nclass ListItemStackItem extends BlockStackItem {\n    constructor(options, next = null, { leadingLineBreaks = 1, maxLineLength = undefined, prefix = \"\" } = {}){\n        super(options, next, leadingLineBreaks, maxLineLength);\n        this.prefix = prefix;\n    }\n}\nclass TableStackItem extends StackItem {\n    constructor(next = null){\n        super(next);\n        this.rows = [];\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass TableRowStackItem extends StackItem {\n    constructor(next = null){\n        super(next);\n        this.cells = [];\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass TableCellStackItem extends StackItem {\n    constructor(options, next = null, maxColumnWidth = undefined){\n        super(next);\n        this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);\n        this.rawText = \"\";\n        this.stashedLineBreaks = 0;\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass TransformerStackItem extends StackItem {\n    constructor(next = null, transform){\n        super(next);\n        this.transform = transform;\n    }\n}\nfunction charactersToCodes(str) {\n    return [\n        ...str\n    ].map((c)=>\"\\\\u\" + c.charCodeAt(0).toString(16).padStart(4, \"0\")).join(\"\");\n}\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */ class WhitespaceProcessor {\n    /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */ constructor(options){\n        this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\\n/g, \"\") : options.whitespaceCharacters;\n        const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n        this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n        this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n        this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n        this.newlineOrNonWhitespaceRe = new RegExp(`(\\\\n|[^\\\\n${whitespaceCodes}])`, \"g\");\n        this.newlineOrNonNewlineStringRe = new RegExp(`(\\\\n|[^\\\\n]+)`, \"g\");\n        if (options.preserveNewlines) {\n            const wordOrNewlineRe = new RegExp(`\\\\n|[^\\\\n${whitespaceCodes}]+`, \"gm\");\n            /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.\n       */ this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str)=>str, noWrap = false) {\n                if (!text) {\n                    return;\n                }\n                const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n                let anyMatch = false;\n                let m = wordOrNewlineRe.exec(text);\n                if (m) {\n                    anyMatch = true;\n                    if (m[0] === \"\\n\") {\n                        inlineTextBuilder.startNewLine();\n                    } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                    } else {\n                        inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n                    }\n                    while((m = wordOrNewlineRe.exec(text)) !== null){\n                        if (m[0] === \"\\n\") {\n                            inlineTextBuilder.startNewLine();\n                        } else {\n                            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                        }\n                    }\n                }\n                inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n            // No need to stash a space in case last added item was a new line,\n            // but that won't affect anything later anyway.\n            };\n        } else {\n            const wordRe = new RegExp(`[^${whitespaceCodes}]+`, \"g\");\n            this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str)=>str, noWrap = false) {\n                if (!text) {\n                    return;\n                }\n                const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n                let anyMatch = false;\n                let m = wordRe.exec(text);\n                if (m) {\n                    anyMatch = true;\n                    if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                    } else {\n                        inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n                    }\n                    while((m = wordRe.exec(text)) !== null){\n                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                    }\n                }\n                inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n            };\n        }\n    }\n    /**\n   * Add text with only minimal processing.\n   * Everything between newlines considered a single word.\n   * No whitespace is trimmed.\n   * Not affected by preserveNewlines option - `\\n` always starts a new line.\n   *\n   * `noWrap` argument is `true` by default - this won't start a new line\n   * even if there is not enough space left in the current line.\n   *\n   * @param { string }            text              Input text.\n   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.\n   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.\n   */ addLiteral(text, inlineTextBuilder, noWrap = true) {\n        if (!text) {\n            return;\n        }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = this.newlineOrNonNewlineStringRe.exec(text);\n        if (m) {\n            anyMatch = true;\n            if (m[0] === \"\\n\") {\n                inlineTextBuilder.startNewLine();\n            } else if (previouslyStashedSpace) {\n                inlineTextBuilder.pushWord(m[0], noWrap);\n            } else {\n                inlineTextBuilder.concatWord(m[0], noWrap);\n            }\n            while((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null){\n                if (m[0] === \"\\n\") {\n                    inlineTextBuilder.startNewLine();\n                } else {\n                    inlineTextBuilder.pushWord(m[0], noWrap);\n                }\n            }\n        }\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;\n    }\n    /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */ testLeadingWhitespace(text) {\n        return this.leadingWhitespaceRe.test(text);\n    }\n    /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */ testTrailingWhitespace(text) {\n        return this.trailingWhitespaceRe.test(text);\n    }\n    /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */ testContainsWords(text) {\n        return !this.allWhitespaceOrEmptyRe.test(text);\n    }\n    /**\n   * Return the number of newlines if there are no words.\n   *\n   * If any word is found then return zero regardless of the actual number of newlines.\n   *\n   * @param   { string }  text  Input string.\n   * @returns { number }\n   */ countNewlinesNoWords(text) {\n        this.newlineOrNonWhitespaceRe.lastIndex = 0;\n        let counter = 0;\n        let match;\n        while((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null){\n            if (match[0] === \"\\n\") {\n                counter++;\n            } else {\n                return 0;\n            }\n        }\n        return counter;\n    }\n}\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */ class BlockTextBuilder {\n    /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.\n   */ constructor(options, picker, metadata = undefined){\n        this.options = options;\n        this.picker = picker;\n        this.metadata = metadata;\n        this.whitespaceProcessor = new WhitespaceProcessor(options);\n        /** @type { StackItem } */ this._stackItem = new BlockStackItem(options);\n        /** @type { TransformerStackItem } */ this._wordTransformer = undefined;\n    }\n    /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */ pushWordTransform(wordTransform) {\n        this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n    }\n    /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */ popWordTransform() {\n        if (!this._wordTransformer) {\n            return undefined;\n        }\n        const transform = this._wordTransformer.transform;\n        this._wordTransformer = this._wordTransformer.next;\n        return transform;\n    }\n    /**\n   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.\n   */ startNoWrap() {\n        this._stackItem.isNoWrap = true;\n    }\n    /**\n   * Return automatic wrapping to behavior defined by options.\n   */ stopNoWrap() {\n        this._stackItem.isNoWrap = false;\n    }\n    /** @returns { (str: string) => string } */ _getCombinedWordTransformer() {\n        const wt = this._wordTransformer ? (str)=>applyTransformer(str, this._wordTransformer) : undefined;\n        const ce = this.options.encodeCharacters;\n        return wt ? ce ? (str)=>ce(wt(str)) : wt : ce;\n    }\n    _popStackItem() {\n        const item = this._stackItem;\n        this._stackItem = item.next;\n        return item;\n    }\n    /**\n   * Add a line break into currently built block.\n   */ addLineBreak() {\n        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n            return;\n        }\n        if (this._stackItem.isPre) {\n            this._stackItem.rawText += \"\\n\";\n        } else {\n            this._stackItem.inlineTextBuilder.startNewLine();\n        }\n    }\n    /**\n   * Allow to break line in case directly following text will not fit.\n   */ addWordBreakOpportunity() {\n        if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {\n            this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n        }\n    }\n    /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object } [param1]\n   * Object holding the parameters of the operation.\n   *\n   * @param { boolean } [param1.noWordTransform]\n   * Ignore word transformers if there are any.\n   * Don't encode characters as well.\n   * (Use this for things like URL addresses).\n   */ addInline(str, { noWordTransform = false } = {}) {\n        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n            return;\n        }\n        if (this._stackItem.isPre) {\n            this._stackItem.rawText += str;\n            return;\n        }\n        if (str.length === 0 || // empty string\n        this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant\n        !this.whitespaceProcessor.testContainsWords(str) // no words to add\n        ) {\n            return;\n        }\n        if (this.options.preserveNewlines) {\n            const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n            if (newlinesNumber > 0) {\n                this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);\n                // keep stashedLineBreaks unchanged\n                return;\n            }\n        }\n        if (this._stackItem.stashedLineBreaks) {\n            this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n        }\n        this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);\n        this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n    }\n    /**\n   * Add a string inline into the currently built block.\n   *\n   * Use this for markup elements that don't have to adhere\n   * to text layout rules.\n   *\n   * @param { string } str Text to add.\n   */ addLiteral(str) {\n        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n            return;\n        }\n        if (str.length === 0) {\n            return;\n        }\n        if (this._stackItem.isPre) {\n            this._stackItem.rawText += str;\n            return;\n        }\n        if (this._stackItem.stashedLineBreaks) {\n            this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n        }\n        this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);\n        this._stackItem.stashedLineBreaks = 0;\n    }\n    /**\n   * Start building a new block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any preceding block.\n   *\n   * @param { number }  [param0.reservedLineLength]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [param0.isPre]\n   * Should HTML whitespace be preserved inside this block.\n   */ openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {\n        const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n        this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n        if (isPre) {\n            this._stackItem.isPre = true;\n        }\n    }\n    /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [param0.blockTransform]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   */ closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {\n        const block = this._popStackItem();\n        const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n        addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n    }\n    /**\n   * Start building a new list.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.maxPrefixLength]\n   * Length of the longest list item prefix.\n   * If not supplied or too small then list items won't be aligned properly.\n   *\n   * @param { 'left' | 'right' } [param0.prefixAlign]\n   * Specify how prefixes of different lengths have to be aligned\n   * within a column.\n   *\n   * @param { number } [param0.interRowLineBreaks]\n   * Minimum number of line breaks between list items.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any preceding block.\n   */ openList({ maxPrefixLength = 0, prefixAlign = \"left\", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {\n        this._stackItem = new ListStackItem(this.options, this._stackItem, {\n            interRowLineBreaks: interRowLineBreaks,\n            leadingLineBreaks: leadingLineBreaks,\n            maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,\n            maxPrefixLength: maxPrefixLength,\n            prefixAlign: prefixAlign\n        });\n    }\n    /**\n   * Start building a new list item.\n   *\n   * @param {object} param0\n   * Object holding the parameters of the list item.\n   *\n   * @param { string } [param0.prefix]\n   * Prefix for this list item (item number, bullet point, etc).\n   */ openListItem({ prefix = \"\" } = {}) {\n        if (!(this._stackItem instanceof ListStackItem)) {\n            throw new Error(\"Can't add a list item to something that is not a list! Check the formatter.\");\n        }\n        const list = this._stackItem;\n        const prefixLength = Math.max(prefix.length, list.maxPrefixLength);\n        const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);\n        this._stackItem = new ListItemStackItem(this.options, list, {\n            prefix: prefix,\n            maxLineLength: maxLineLength,\n            leadingLineBreaks: list.interRowLineBreaks\n        });\n    }\n    /**\n   * Finalize currently built list item, add it's content to the parent list.\n   */ closeListItem() {\n        const listItem = this._popStackItem();\n        const list = listItem.next;\n        const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);\n        const spacing = \"\\n\" + \" \".repeat(prefixLength);\n        const prefix = list.prefixAlign === \"right\" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);\n        const text = prefix + getText(listItem).replace(/\\n/g, spacing);\n        addText(list, text, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));\n    }\n    /**\n   * Finalize currently built list, add it's content to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any following block.\n   */ closeList({ trailingLineBreaks = 2 } = {}) {\n        const list = this._popStackItem();\n        const text = getText(list);\n        if (text) {\n            addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);\n        }\n    }\n    /**\n   * Start building a table.\n   */ openTable() {\n        this._stackItem = new TableStackItem(this._stackItem);\n    }\n    /**\n   * Start building a table row.\n   */ openTableRow() {\n        if (!(this._stackItem instanceof TableStackItem)) {\n            throw new Error(\"Can't add a table row to something that is not a table! Check the formatter.\");\n        }\n        this._stackItem = new TableRowStackItem(this._stackItem);\n    }\n    /**\n   * Start building a table cell.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.maxColumnWidth]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */ openTableCell({ maxColumnWidth = undefined } = {}) {\n        if (!(this._stackItem instanceof TableRowStackItem)) {\n            throw new Error(\"Can't add a table cell to something that is not a table row! Check the formatter.\");\n        }\n        this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n    }\n    /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.colspan] How many columns this cell should occupy.\n   * @param { number } [param0.rowspan] How many rows this cell should occupy.\n   */ closeTableCell({ colspan = 1, rowspan = 1 } = {}) {\n        const cell = this._popStackItem();\n        const text = trimCharacter(getText(cell), \"\\n\");\n        cell.next.cells.push({\n            colspan: colspan,\n            rowspan: rowspan,\n            text: text\n        });\n    }\n    /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */ closeTableRow() {\n        const row = this._popStackItem();\n        row.next.rows.push(row.cells);\n    }\n    /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the table.\n   *\n   * @param { TablePrinter } param0.tableToString\n   * A function to convert a table of stringified cells into a complete table.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   */ closeTable({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {\n        const table = this._popStackItem();\n        const output = tableToString(table.rows);\n        if (output) {\n            addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n        }\n    }\n    /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */ toString() {\n        return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n    }\n}\nfunction getText(stackItem) {\n    if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n        throw new Error(\"Only blocks, list items and table cells can be requested for text contents.\");\n    }\n    return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n    if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n        throw new Error(\"Only blocks, list items and table cells can contain text.\");\n    }\n    const parentText = getText(stackItem);\n    const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n    stackItem.inlineTextBuilder.clear();\n    if (parentText) {\n        stackItem.rawText = parentText + \"\\n\".repeat(lineBreaks) + text;\n    } else {\n        stackItem.rawText = text;\n        stackItem.leadingLineBreaks = lineBreaks;\n    }\n    stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n/**\n * @param { string } str A string to transform.\n * @param { TransformerStackItem } transformer A transformer item (with possible continuation).\n * @returns { string }\n */ function applyTransformer(str, transformer) {\n    return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n}\n/**\n * Compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */ function compile$1(options = {}) {\n    const selectorsWithoutFormat = options.selectors.filter((s)=>!s.format);\n    if (selectorsWithoutFormat.length) {\n        throw new Error(\"Following selectors have no specified format: \" + selectorsWithoutFormat.map((s)=>`\\`${s.selector}\\``).join(\", \"));\n    }\n    const picker = new selderee.DecisionTree(options.selectors.map((s)=>[\n            s.selector,\n            s\n        ])).build(pluginHtmlparser2.hp2Builder);\n    if (typeof options.encodeCharacters !== \"function\") {\n        options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);\n    }\n    const baseSelectorsPicker = new selderee.DecisionTree(options.baseElements.selectors.map((s, i)=>[\n            s,\n            i + 1\n        ])).build(pluginHtmlparser2.hp2Builder);\n    function findBaseElements(dom) {\n        return findBases(dom, options, baseSelectorsPicker);\n    }\n    const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {\n        builder.addInline(options.limits.ellipsis || \"\");\n    });\n    return function(html, metadata = undefined) {\n        return process(html, metadata, options, picker, findBaseElements, limitedWalk);\n    };\n}\n/**\n * Convert given HTML according to preprocessed options.\n *\n * @param { string } html HTML content to convert.\n * @param { any } metadata Optional metadata for HTML document, for use in formatters.\n * @param { Options } options HtmlToText options (preprocessed).\n * @param { import('selderee').Picker<DomNode, TagDefinition> } picker\n * Tag definition picker for DOM nodes processing.\n * @param { (dom: DomNode[]) => DomNode[] } findBaseElements\n * Function to extract elements from HTML DOM\n * that will only be present in the output text.\n * @param { RecursiveCallback } walk Recursive callback.\n * @returns { string }\n */ function process(html, metadata, options, picker, findBaseElements, walk) {\n    const maxInputLength = options.limits.maxInputLength;\n    if (maxInputLength && html && html.length > maxInputLength) {\n        console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);\n        html = html.substring(0, maxInputLength);\n    }\n    const document = htmlparser2.parseDocument(html, {\n        decodeEntities: options.decodeEntities\n    });\n    const bases = findBaseElements(document.children);\n    const builder = new BlockTextBuilder(options, picker, metadata);\n    walk(bases, builder);\n    return builder.toString();\n}\nfunction findBases(dom, options, baseSelectorsPicker) {\n    const results = [];\n    function recursiveWalk(walk, /** @type { DomNode[] } */ dom) {\n        dom = dom.slice(0, options.limits.maxChildNodes);\n        for (const elem of dom){\n            if (elem.type !== \"tag\") {\n                continue;\n            }\n            const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);\n            if (pickedSelectorIndex > 0) {\n                results.push({\n                    selectorIndex: pickedSelectorIndex,\n                    element: elem\n                });\n            } else if (elem.children) {\n                walk(elem.children);\n            }\n            if (results.length >= options.limits.maxBaseElements) {\n                return;\n            }\n        }\n    }\n    const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);\n    limitedWalk(dom);\n    if (options.baseElements.orderBy !== \"occurrence\") {\n        results.sort((a, b)=>a.selectorIndex - b.selectorIndex);\n    }\n    return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x)=>x.element);\n}\n/**\n * Function to walk through DOM nodes and accumulate their string representations.\n *\n * @param   { RecursiveCallback } walk    Recursive callback.\n * @param   { DomNode[] }         [dom]   Nodes array to process.\n * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.\n * @private\n */ function recursiveWalk(walk, dom, builder) {\n    if (!dom) {\n        return;\n    }\n    const options = builder.options;\n    const tooManyChildNodes = dom.length > options.limits.maxChildNodes;\n    if (tooManyChildNodes) {\n        dom = dom.slice(0, options.limits.maxChildNodes);\n        dom.push({\n            data: options.limits.ellipsis,\n            type: \"text\"\n        });\n    }\n    for (const elem of dom){\n        switch(elem.type){\n            case \"text\":\n                {\n                    builder.addInline(elem.data);\n                    break;\n                }\n            case \"tag\":\n                {\n                    const tagDefinition = builder.picker.pick1(elem);\n                    const format = options.formatters[tagDefinition.format];\n                    format(elem, walk, builder, tagDefinition.options || {});\n                    break;\n                }\n        }\n    }\n    return;\n}\n/**\n * @param { Object<string,string | false> } dict\n * A dictionary where keys are characters to replace\n * and values are replacement strings.\n *\n * First code point from dict keys is used.\n * Compound emojis with ZWJ are not supported (not until Node 16).\n *\n * @returns { ((str: string) => string) | undefined }\n */ function makeReplacerFromDict(dict) {\n    if (!dict || Object.keys(dict).length === 0) {\n        return undefined;\n    }\n    /** @type { [string, string][] } */ const entries = Object.entries(dict).filter(([, v])=>v !== false);\n    const regex = new RegExp(entries.map(([c])=>`(${unicodeEscape([\n            ...c\n        ][0])})`).join(\"|\"), \"g\");\n    const values = entries.map(([, v])=>v);\n    const replacer = (m, ...cgs)=>values[cgs.findIndex((cg)=>cg)];\n    return (str)=>str.replace(regex, replacer);\n}\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */ function formatSkip(elem, walk, builder, formatOptions) {\n/* do nothing */ }\n/**\n * Insert the given string literal inline instead of a tag.\n *\n * @type { FormatCallback }\n */ function formatInlineString(elem, walk, builder, formatOptions) {\n    builder.addLiteral(formatOptions.string || \"\");\n}\n/**\n * Insert a block with the given string literal instead of a tag.\n *\n * @type { FormatCallback }\n */ function formatBlockString(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.addLiteral(formatOptions.string || \"\");\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */ function formatInline(elem, walk, builder, formatOptions) {\n    walk(elem.children, builder);\n}\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */ function formatBlock$1(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\nfunction renderOpenTag(elem) {\n    const attrs = elem.attribs && elem.attribs.length ? \" \" + Object.entries(elem.attribs).map(([k, v])=>v === \"\" ? k : `${k}=${v.replace(/\"/g, \"&quot;\")}`).join(\" \") : \"\";\n    return `<${elem.name}${attrs}>`;\n}\nfunction renderCloseTag(elem) {\n    return `</${elem.name}>`;\n}\n/**\n * Render an element as inline HTML tag, walk through it's children.\n *\n * @type { FormatCallback }\n */ function formatInlineTag(elem, walk, builder, formatOptions) {\n    builder.startNoWrap();\n    builder.addLiteral(renderOpenTag(elem));\n    builder.stopNoWrap();\n    walk(elem.children, builder);\n    builder.startNoWrap();\n    builder.addLiteral(renderCloseTag(elem));\n    builder.stopNoWrap();\n}\n/**\n * Render an element as HTML block bag, walk through it's children.\n *\n * @type { FormatCallback }\n */ function formatBlockTag(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.startNoWrap();\n    builder.addLiteral(renderOpenTag(elem));\n    builder.stopNoWrap();\n    walk(elem.children, builder);\n    builder.startNoWrap();\n    builder.addLiteral(renderCloseTag(elem));\n    builder.stopNoWrap();\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Render an element with all it's children as inline HTML.\n *\n * @type { FormatCallback }\n */ function formatInlineHtml(elem, walk, builder, formatOptions) {\n    builder.startNoWrap();\n    builder.addLiteral(domSerializer.render(elem, {\n        decodeEntities: builder.options.decodeEntities\n    }));\n    builder.stopNoWrap();\n}\n/**\n * Render an element with all it's children as HTML block.\n *\n * @type { FormatCallback }\n */ function formatBlockHtml(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.startNoWrap();\n    builder.addLiteral(domSerializer.render(elem, {\n        decodeEntities: builder.options.decodeEntities\n    }));\n    builder.stopNoWrap();\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Render inline element wrapped with given strings.\n *\n * @type { FormatCallback }\n */ function formatInlineSurround(elem, walk, builder, formatOptions) {\n    builder.addLiteral(formatOptions.prefix || \"\");\n    walk(elem.children, builder);\n    builder.addLiteral(formatOptions.suffix || \"\");\n}\nvar genericFormatters = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    block: formatBlock$1,\n    blockHtml: formatBlockHtml,\n    blockString: formatBlockString,\n    blockTag: formatBlockTag,\n    inline: formatInline,\n    inlineHtml: formatInlineHtml,\n    inlineString: formatInlineString,\n    inlineSurround: formatInlineSurround,\n    inlineTag: formatInlineTag,\n    skip: formatSkip\n});\nfunction getRow(matrix, j) {\n    if (!matrix[j]) {\n        matrix[j] = [];\n    }\n    return matrix[j];\n}\nfunction findFirstVacantIndex(row, x = 0) {\n    while(row[x]){\n        x++;\n    }\n    return x;\n}\nfunction transposeInPlace(matrix, maxSize) {\n    for(let i = 0; i < maxSize; i++){\n        const rowI = getRow(matrix, i);\n        for(let j = 0; j < i; j++){\n            const rowJ = getRow(matrix, j);\n            const temp = rowI[j];\n            rowI[j] = rowJ[i];\n            rowJ[i] = temp;\n        }\n    }\n}\nfunction putCellIntoLayout(cell, layout, baseRow, baseCol) {\n    for(let r = 0; r < cell.rowspan; r++){\n        const layoutRow = getRow(layout, baseRow + r);\n        for(let c = 0; c < cell.colspan; c++){\n            layoutRow[baseCol + c] = cell;\n        }\n    }\n}\nfunction updateOffset(offsets, base, span, value) {\n    offsets[base + span] = Math.max(offsets[base + span] || 0, offsets[base] + value);\n}\n/**\n * Render a table into a string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */ function tableToString(tableRows, rowSpacing, colSpacing) {\n    const layout = [];\n    let colNumber = 0;\n    const rowNumber = tableRows.length;\n    const rowOffsets = [\n        0\n    ];\n    // Fill the layout table and row offsets row-by-row.\n    for(let j = 0; j < rowNumber; j++){\n        const layoutRow = getRow(layout, j);\n        const cells = tableRows[j];\n        let x = 0;\n        for(let i = 0; i < cells.length; i++){\n            const cell = cells[i];\n            x = findFirstVacantIndex(layoutRow, x);\n            putCellIntoLayout(cell, layout, j, x);\n            x += cell.colspan;\n            cell.lines = cell.text.split(\"\\n\");\n            const cellHeight = cell.lines.length;\n            updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n        }\n        colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;\n    }\n    transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);\n    const outputLines = [];\n    const colOffsets = [\n        0\n    ];\n    // Fill column offsets and output lines column-by-column.\n    for(let x = 0; x < colNumber; x++){\n        let y = 0;\n        let cell;\n        while(y < rowNumber && (cell = layout[x][y])){\n            if (!cell.rendered) {\n                let cellWidth = 0;\n                for(let j = 0; j < cell.lines.length; j++){\n                    const line = cell.lines[j];\n                    const lineOffset = rowOffsets[y] + j;\n                    outputLines[lineOffset] = (outputLines[lineOffset] || \"\").padEnd(colOffsets[x]) + line;\n                    cellWidth = line.length > cellWidth ? line.length : cellWidth;\n                }\n                updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n                cell.rendered = true;\n            }\n            y += cell.rowspan;\n        }\n    }\n    return outputLines.join(\"\\n\");\n}\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */ function formatLineBreak(elem, walk, builder, formatOptions) {\n    builder.addLineBreak();\n}\n/**\n * Process a `wbr` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */ function formatWbr(elem, walk, builder, formatOptions) {\n    builder.addWordBreakOpportunity();\n}\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */ function formatHorizontalLine(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.addInline(\"-\".repeat(formatOptions.length || builder.options.wordwrap || 40));\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */ function formatParagraph(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */ function formatPre(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        isPre: true,\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */ function formatHeading(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    if (formatOptions.uppercase !== false) {\n        builder.pushWordTransform((str)=>str.toUpperCase());\n        walk(elem.children, builder);\n        builder.popWordTransform();\n    } else {\n        walk(elem.children, builder);\n    }\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */ function formatBlockquote(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n        reservedLineLength: 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n        blockTransform: (str)=>(formatOptions.trimEmptyLines !== false ? trimCharacter(str, \"\\n\") : str).split(\"\\n\").map((line)=>\"> \" + line).join(\"\\n\")\n    });\n}\nfunction withBrackets(str, brackets) {\n    if (!brackets) {\n        return str;\n    }\n    const lbr = typeof brackets[0] === \"string\" ? brackets[0] : \"[\";\n    const rbr = typeof brackets[1] === \"string\" ? brackets[1] : \"]\";\n    return lbr + str + rbr;\n}\nfunction pathRewrite(path, rewriter, baseUrl, metadata, elem) {\n    const modifiedPath = typeof rewriter === \"function\" ? rewriter(path, metadata, elem) : path;\n    return modifiedPath[0] === \"/\" && baseUrl ? trimCharacterEnd(baseUrl, \"/\") + modifiedPath : modifiedPath;\n}\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */ function formatImage(elem, walk, builder, formatOptions) {\n    const attribs = elem.attribs || {};\n    const alt = attribs.alt ? attribs.alt : \"\";\n    const src = !attribs.src ? \"\" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n    const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + \" \" + withBrackets(src, formatOptions.linkBrackets);\n    builder.addInline(text, {\n        noWordTransform: true\n    });\n}\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */ function formatAnchor(elem, walk, builder, formatOptions) {\n    function getHref() {\n        if (formatOptions.ignoreHref) {\n            return \"\";\n        }\n        if (!elem.attribs || !elem.attribs.href) {\n            return \"\";\n        }\n        let href = elem.attribs.href.replace(/^mailto:/, \"\");\n        if (formatOptions.noAnchorUrl && href[0] === \"#\") {\n            return \"\";\n        }\n        href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n        return href;\n    }\n    const href = getHref();\n    if (!href) {\n        walk(elem.children, builder);\n    } else {\n        let text = \"\";\n        builder.pushWordTransform((str)=>{\n            if (str) {\n                text += str;\n            }\n            return str;\n        });\n        walk(elem.children, builder);\n        builder.popWordTransform();\n        const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n        if (!hideSameLink) {\n            builder.addInline(!text ? href : \" \" + withBrackets(href, formatOptions.linkBrackets), {\n                noWordTransform: true\n            });\n        }\n    }\n}\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.\n */ function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {\n    const isNestedList = get(elem, [\n        \"parent\",\n        \"name\"\n    ]) === \"li\";\n    // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n    // so the dumb length comparison is the most robust way to get the correct value.\n    let maxPrefixLength = 0;\n    const listItems = (elem.children || [])// it might be more accurate to check only for html spaces here, but no significant benefit\n    .filter((child)=>child.type !== \"text\" || !/^\\s*$/.test(child.data)).map(function(child) {\n        if (child.name !== \"li\") {\n            return {\n                node: child,\n                prefix: \"\"\n            };\n        }\n        const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();\n        if (prefix.length > maxPrefixLength) {\n            maxPrefixLength = prefix.length;\n        }\n        return {\n            node: child,\n            prefix: prefix\n        };\n    });\n    if (!listItems.length) {\n        return;\n    }\n    builder.openList({\n        interRowLineBreaks: 1,\n        leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,\n        maxPrefixLength: maxPrefixLength,\n        prefixAlign: \"left\"\n    });\n    for (const { node, prefix } of listItems){\n        builder.openListItem({\n            prefix: prefix\n        });\n        walk([\n            node\n        ], builder);\n        builder.closeListItem();\n    }\n    builder.closeList({\n        trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */ function formatUnorderedList(elem, walk, builder, formatOptions) {\n    const prefix = formatOptions.itemPrefix || \" * \";\n    return formatList(elem, walk, builder, formatOptions, ()=>prefix);\n}\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */ function formatOrderedList(elem, walk, builder, formatOptions) {\n    let nextIndex = Number(elem.attribs.start || \"1\");\n    const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n    const nextPrefixCallback = ()=>\" \" + indexFunction(nextIndex++) + \". \";\n    return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */ function getOrderedListIndexFunction(olType = \"1\") {\n    switch(olType){\n        case \"a\":\n            return (i)=>numberToLetterSequence(i, \"a\");\n        case \"A\":\n            return (i)=>numberToLetterSequence(i, \"A\");\n        case \"i\":\n            return (i)=>numberToRoman(i).toLowerCase();\n        case \"I\":\n            return (i)=>numberToRoman(i);\n        case \"1\":\n        default:\n            return (i)=>i.toString();\n    }\n}\n/**\n * Given a list of class and ID selectors (prefixed with '.' and '#'),\n * return them as separate lists of names without prefixes.\n *\n * @param { string[] } selectors Class and ID selectors (`[\".class\", \"#id\"]` etc).\n * @returns { { classes: string[], ids: string[] } }\n */ function splitClassesAndIds(selectors) {\n    const classes = [];\n    const ids = [];\n    for (const selector of selectors){\n        if (selector.startsWith(\".\")) {\n            classes.push(selector.substring(1));\n        } else if (selector.startsWith(\"#\")) {\n            ids.push(selector.substring(1));\n        }\n    }\n    return {\n        classes: classes,\n        ids: ids\n    };\n}\nfunction isDataTable(attr, tables) {\n    if (tables === true) {\n        return true;\n    }\n    if (!attr) {\n        return false;\n    }\n    const { classes, ids } = splitClassesAndIds(tables);\n    const attrClasses = (attr[\"class\"] || \"\").split(\" \");\n    const attrIds = (attr[\"id\"] || \"\").split(\" \");\n    return attrClasses.some((x)=>classes.includes(x)) || attrIds.some((x)=>ids.includes(x));\n}\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */ function formatTable(elem, walk, builder, formatOptions) {\n    return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);\n}\nfunction formatBlock(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks\n    });\n}\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */ function formatDataTable(elem, walk, builder, formatOptions) {\n    builder.openTable();\n    elem.children.forEach(walkTable);\n    builder.closeTable({\n        tableToString: (rows)=>tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),\n        leadingLineBreaks: formatOptions.leadingLineBreaks,\n        trailingLineBreaks: formatOptions.trailingLineBreaks\n    });\n    function formatCell(cellNode) {\n        const colspan = +get(cellNode, [\n            \"attribs\",\n            \"colspan\"\n        ]) || 1;\n        const rowspan = +get(cellNode, [\n            \"attribs\",\n            \"rowspan\"\n        ]) || 1;\n        builder.openTableCell({\n            maxColumnWidth: formatOptions.maxColumnWidth\n        });\n        walk(cellNode.children, builder);\n        builder.closeTableCell({\n            colspan: colspan,\n            rowspan: rowspan\n        });\n    }\n    function walkTable(elem) {\n        if (elem.type !== \"tag\") {\n            return;\n        }\n        const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode)=>{\n            builder.pushWordTransform((str)=>str.toUpperCase());\n            formatCell(cellNode);\n            builder.popWordTransform();\n        } : formatCell;\n        switch(elem.name){\n            case \"thead\":\n            case \"tbody\":\n            case \"tfoot\":\n            case \"center\":\n                elem.children.forEach(walkTable);\n                return;\n            case \"tr\":\n                {\n                    builder.openTableRow();\n                    for (const childOfTr of elem.children){\n                        if (childOfTr.type !== \"tag\") {\n                            continue;\n                        }\n                        switch(childOfTr.name){\n                            case \"th\":\n                                {\n                                    formatHeaderCell(childOfTr);\n                                    break;\n                                }\n                            case \"td\":\n                                {\n                                    formatCell(childOfTr);\n                                    break;\n                                }\n                        }\n                    }\n                    builder.closeTableRow();\n                    break;\n                }\n        }\n    }\n}\nvar textFormatters = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    anchor: formatAnchor,\n    blockquote: formatBlockquote,\n    dataTable: formatDataTable,\n    heading: formatHeading,\n    horizontalLine: formatHorizontalLine,\n    image: formatImage,\n    lineBreak: formatLineBreak,\n    orderedList: formatOrderedList,\n    paragraph: formatParagraph,\n    pre: formatPre,\n    table: formatTable,\n    unorderedList: formatUnorderedList,\n    wbr: formatWbr\n});\n/**\n * Default options.\n *\n * @constant\n * @type { Options }\n * @default\n * @private\n */ const DEFAULT_OPTIONS = {\n    baseElements: {\n        selectors: [\n            \"body\"\n        ],\n        orderBy: \"selectors\",\n        returnDomByDefault: true\n    },\n    decodeEntities: true,\n    encodeCharacters: {},\n    formatters: {},\n    limits: {\n        ellipsis: \"...\",\n        maxBaseElements: undefined,\n        maxChildNodes: undefined,\n        maxDepth: undefined,\n        maxInputLength: 1 << 24 // 16_777_216\n    },\n    longWordSplit: {\n        forceWrapOnLimit: false,\n        wrapCharacters: []\n    },\n    preserveNewlines: false,\n    selectors: [\n        {\n            selector: \"*\",\n            format: \"inline\"\n        },\n        {\n            selector: \"a\",\n            format: \"anchor\",\n            options: {\n                baseUrl: null,\n                hideLinkHrefIfSameAsText: false,\n                ignoreHref: false,\n                linkBrackets: [\n                    \"[\",\n                    \"]\"\n                ],\n                noAnchorUrl: true\n            }\n        },\n        {\n            selector: \"article\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"aside\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"blockquote\",\n            format: \"blockquote\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                trimEmptyLines: true\n            }\n        },\n        {\n            selector: \"br\",\n            format: \"lineBreak\"\n        },\n        {\n            selector: \"div\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"footer\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"form\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"h1\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 3,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h2\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 3,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h3\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 3,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h4\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h5\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h6\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"header\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"hr\",\n            format: \"horizontalLine\",\n            options: {\n                leadingLineBreaks: 2,\n                length: undefined,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"img\",\n            format: \"image\",\n            options: {\n                baseUrl: null,\n                linkBrackets: [\n                    \"[\",\n                    \"]\"\n                ]\n            }\n        },\n        {\n            selector: \"main\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"nav\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"ol\",\n            format: \"orderedList\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"p\",\n            format: \"paragraph\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"pre\",\n            format: \"pre\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"section\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"table\",\n            format: \"table\",\n            options: {\n                colSpacing: 3,\n                leadingLineBreaks: 2,\n                maxColumnWidth: 60,\n                rowSpacing: 0,\n                trailingLineBreaks: 2,\n                uppercaseHeaderCells: true\n            }\n        },\n        {\n            selector: \"ul\",\n            format: \"unorderedList\",\n            options: {\n                itemPrefix: \" * \",\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"wbr\",\n            format: \"wbr\"\n        }\n    ],\n    tables: [],\n    whitespaceCharacters: \" \t\\r\\n\\f\",\n    wordwrap: 80\n};\nconst concatMerge = (acc, src, options)=>[\n        ...acc,\n        ...src\n    ];\nconst overwriteMerge = (acc, src, options)=>[\n        ...src\n    ];\nconst selectorsMerge = (acc, src, options)=>acc.some((s)=>typeof s === \"object\") ? concatMerge(acc, src) // selectors\n     : overwriteMerge(acc, src) // baseElements.selectors\n;\n/**\n * Preprocess options, compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options.\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */ function compile(options = {}) {\n    options = merge__default[\"default\"](DEFAULT_OPTIONS, options, {\n        arrayMerge: overwriteMerge,\n        customMerge: (key)=>key === \"selectors\" ? selectorsMerge : undefined\n    });\n    options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);\n    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s)=>s.selector);\n    handleDeprecatedOptions(options);\n    return compile$1(options);\n}\n/**\n * Convert given HTML content to plain text string.\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.\n * @returns { string }                 Plain text string.\n * @static\n *\n * @example\n * const { convert } = require('html-to-text');\n * const text = convert('<h1>Hello World</h1>', {\n *   wordwrap: 130\n * });\n * console.log(text); // HELLO WORLD\n */ function convert(html, options = {}, metadata = undefined) {\n    return compile(options)(html, metadata);\n}\n/**\n * Map previously existing and now deprecated options to the new options layout.\n * This is a subject for cleanup in major releases.\n *\n * @param { Options } options HtmlToText options.\n */ function handleDeprecatedOptions(options) {\n    if (options.tags) {\n        const tagDefinitions = Object.entries(options.tags).map(([selector, definition])=>({\n                ...definition,\n                selector: selector || \"*\"\n            }));\n        options.selectors.push(...tagDefinitions);\n        options.selectors = mergeDuplicatesPreferLast(options.selectors, (s)=>s.selector);\n    }\n    function set(obj, path, value) {\n        const valueKey = path.pop();\n        for (const key of path){\n            let nested = obj[key];\n            if (!nested) {\n                nested = {};\n                obj[key] = nested;\n            }\n            obj = nested;\n        }\n        obj[valueKey] = value;\n    }\n    if (options[\"baseElement\"]) {\n        const baseElement = options[\"baseElement\"];\n        set(options, [\n            \"baseElements\",\n            \"selectors\"\n        ], Array.isArray(baseElement) ? baseElement : [\n            baseElement\n        ]);\n    }\n    if (options[\"returnDomByDefault\"] !== undefined) {\n        set(options, [\n            \"baseElements\",\n            \"returnDomByDefault\"\n        ], options[\"returnDomByDefault\"]);\n    }\n    for (const definition of options.selectors){\n        if (definition.format === \"anchor\" && get(definition, [\n            \"options\",\n            \"noLinkBrackets\"\n        ])) {\n            set(definition, [\n                \"options\",\n                \"linkBrackets\"\n            ], false);\n        }\n    }\n}\nexports.compile = compile;\nexports.convert = convert;\nexports.htmlToText = convert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHRtbC10by10ZXh0L2xpYi9odG1sLXRvLXRleHQuY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLG9CQUFvQkMsbUJBQU9BLENBQUM7QUFDaEMsSUFBSUMsY0FBY0QsbUJBQU9BLENBQUM7QUFDMUIsSUFBSUUsV0FBV0YsbUJBQU9BLENBQUM7QUFDdkIsSUFBSUcsUUFBUUgsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUksZ0JBQWdCSixtQkFBT0EsQ0FBQztBQUU1QixTQUFTSyxzQkFBdUJDLENBQUM7SUFBSSxPQUFPQSxLQUFLLE9BQU9BLE1BQU0sWUFBWSxhQUFhQSxJQUFJQSxJQUFJO1FBQUUsV0FBV0E7SUFBRTtBQUFHO0FBRWpILElBQUlDLGlCQUFpQixXQUFXLEdBQUVGLHNCQUFzQkY7QUFFeEQ7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0ssc0JBQXVCQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsSUFBSSxJQUFNQyxTQUFTO0lBQ3ZELElBQUlILE1BQU1HLFdBQVc7UUFDbkIsTUFBTUMsS0FBSyxTQUFVLEdBQUdDLElBQUk7WUFBSSxPQUFPSixFQUFFRyxPQUFPQztRQUFPO1FBQ3ZELE9BQU9EO0lBQ1Q7SUFDQSxJQUFJSixLQUFLLEdBQUc7UUFDVixPQUFPLFNBQVUsR0FBR0ssSUFBSTtZQUFJLE9BQU9KLEVBQUVGLHNCQUFzQkMsSUFBSSxHQUFHQyxHQUFHQyxPQUFPRztRQUFPO0lBQ3JGO0lBQ0EsT0FBT0g7QUFDVDtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTSSxjQUFlQyxHQUFHLEVBQUVDLElBQUk7SUFDL0IsSUFBSUMsUUFBUTtJQUNaLElBQUlDLE1BQU1ILElBQUlJLE1BQU07SUFDcEIsTUFBT0YsUUFBUUMsT0FBT0gsR0FBRyxDQUFDRSxNQUFNLEtBQUtELEtBQU07UUFBRSxFQUFFQztJQUFPO0lBQ3RELE1BQU9DLE1BQU1ELFNB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Z0JBQVc7YUFBZSxFQUFFO1FBQy9DO0lBQ0Y7QUFDRjtBQUVBbGIsZUFBZSxHQUFHMmE7QUFDbEIzYSxlQUFlLEdBQUcrYTtBQUNsQi9hLGtCQUFrQixHQUFHK2EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC1jbGllbnQvLi9ub2RlX21vZHVsZXMvaHRtbC10by10ZXh0L2xpYi9odG1sLXRvLXRleHQuY2pzP2ZlODEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgcGx1Z2luSHRtbHBhcnNlcjIgPSByZXF1aXJlKCdAc2VsZGVyZWUvcGx1Z2luLWh0bWxwYXJzZXIyJyk7XG52YXIgaHRtbHBhcnNlcjIgPSByZXF1aXJlKCdodG1scGFyc2VyMicpO1xudmFyIHNlbGRlcmVlID0gcmVxdWlyZSgnc2VsZGVyZWUnKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoJ2RlZXBtZXJnZScpO1xudmFyIGRvbVNlcmlhbGl6ZXIgPSByZXF1aXJlKCdkb20tc2VyaWFsaXplcicpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIG1lcmdlX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShtZXJnZSk7XG5cbi8qKlxuICogTWFrZSBhIHJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBydW4gdG8gYSBnaXZlbiBkZXB0aFxuICogYW5kIHN3aXRjaGVzIHRvIGFuIGFsdGVybmF0aXZlIGZ1bmN0aW9uIGF0IHRoYXQgZGVwdGguIFxcXG4gKiBObyBsaW1pdGF0aW9uIGlmIGBuYCBpcyBgdW5kZWZpbmVkYCAoSnVzdCB3cmFwcyBgZmAgaW4gdGhhdCBjYXNlKS5cbiAqXG4gKiBAcGFyYW0gICB7IG51bWJlciB8IHVuZGVmaW5lZCB9IG4gICBBbGxvd2VkIGRlcHRoIG9mIHJlY3Vyc2lvbi4gYHVuZGVmaW5lZGAgZm9yIG5vIGxpbWl0YXRpb24uXG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gICAgICAgICAgIGYgICBGdW5jdGlvbiB0aGF0IGFjY2VwdHMgcmVjdXJzaXZlIGNhbGxiYWNrIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSAgICAgICAgICAgW2ddIEZ1bmN0aW9uIHRvIHJ1biBpbnN0ZWFkLCB3aGVuIG1heGltdW0gZGVwdGggd2FzIHJlYWNoZWQuIERvIG5vdGhpbmcgYnkgZGVmYXVsdC5cbiAqIEByZXR1cm5zIHsgRnVuY3Rpb24gfVxuICovXG5mdW5jdGlvbiBsaW1pdGVkRGVwdGhSZWN1cnNpdmUgKG4sIGYsIGcgPSAoKSA9PiB1bmRlZmluZWQpIHtcbiAgaWYgKG4gPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGYxID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHsgcmV0dXJuIGYoZjEsIC4uLmFyZ3MpOyB9O1xuICAgIHJldHVybiBmMTtcbiAgfVxuICBpZiAobiA+PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7IHJldHVybiBmKGxpbWl0ZWREZXB0aFJlY3Vyc2l2ZShuIC0gMSwgZiwgZyksIC4uLmFyZ3MpOyB9O1xuICB9XG4gIHJldHVybiBnO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSBzdHJpbmcgb3IgYSBzdWJzdHJpbmcgd2l0aFxuICogdGhlIGdpdmVuIGNoYXJhY3RlciBvY2N1cnJlbmNlcyByZW1vdmVkIGZyb20gZWFjaCBzaWRlLlxuICpcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gc3RyICBBIHN0cmluZyB0byB0cmltLlxuICogQHBhcmFtICAgeyBzdHJpbmcgfSBjaGFyIEEgY2hhcmFjdGVyIHRvIGJlIHRyaW1tZWQuXG4gKiBAcmV0dXJucyB7IHN0cmluZyB9XG4gKi9cbmZ1bmN0aW9uIHRyaW1DaGFyYWN0ZXIgKHN0ciwgY2hhcikge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gc3RyLmxlbmd0aDtcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kICYmIHN0cltzdGFydF0gPT09IGNoYXIpIHsgKytzdGFydDsgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgc3RyW2VuZCAtIDFdID09PSBjaGFyKSB7IC0tZW5kOyB9XG4gIHJldHVybiAoc3RhcnQgPiAwIHx8IGVuZCA8IHN0ci5sZW5ndGgpXG4gICAgPyBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpXG4gICAgOiBzdHI7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHN0cmluZyBvciBhIHN1YnN0cmluZyB3aXRoXG4gKiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIG9jY3VycmVuY2VzIHJlbW92ZWQgZnJvbSB0aGUgZW5kIG9ubHkuXG4gKlxuICogQHBhcmFtICAgeyBzdHJpbmcgfSBzdHIgIEEgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9IGNoYXIgQSBjaGFyYWN0ZXIgdG8gYmUgdHJpbW1lZC5cbiAqIEByZXR1cm5zIHsgc3RyaW5nIH1cbiAqL1xuZnVuY3Rpb24gdHJpbUNoYXJhY3RlckVuZCAoc3RyLCBjaGFyKSB7XG4gIGxldCBlbmQgPSBzdHIubGVuZ3RoO1xuICB3aGlsZSAoZW5kID4gMCAmJiBzdHJbZW5kIC0gMV0gPT09IGNoYXIpIHsgLS1lbmQ7IH1cbiAgcmV0dXJuIChlbmQgPCBzdHIubGVuZ3RoKVxuICAgID8gc3RyLnN1YnN0cmluZygwLCBlbmQpXG4gICAgOiBzdHI7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IHN0cmluZyB3aWxsIGFsbCBjaGFyYWN0ZXJzIHJlcGxhY2VkIHdpdGggdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzLlxuICogVGhpcyBleHRyZW1lIGtpbmQgb2YgZXNjYXBpbmcgY2FuIHVzZWQgdG8gYmUgc2FmZWx5IGNvbXBvc2UgcmVndWxhciBleHByZXNzaW9ucy5cbiAqXG4gKiBAcGFyYW0geyBzdHJpbmcgfSBzdHIgQSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMgeyBzdHJpbmcgfSBBIHN0cmluZyBvZiB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZXMuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVFc2NhcGUgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHNcXFNdL2csIGMgPT4gJ1xcXFx1JyArIGMuY2hhckNvZGVBdCgpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg0LCAnMCcpKTtcbn1cblxuLyoqXG4gKiBEZWR1cGxpY2F0ZSBhbiBhcnJheSBieSBhIGdpdmVuIGtleSBjYWxsYmFjay5cbiAqIEl0ZW0gcHJvcGVydGllcyBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5IGFuZCB3aXRoIHRoZSBwcmVmZXJlbmNlIGZvciBsYXN0IGRlZmluZWQgdmFsdWVzLlxuICogT2YgaXRlbXMgd2l0aCB0aGUgc2FtZSBrZXksIG1lcmdlZCBpdGVtIHRha2VzIHRoZSBwbGFjZSBvZiB0aGUgbGFzdCBpdGVtLFxuICogb3RoZXJzIGFyZSBvbWl0dGVkLlxuICpcbiAqIEBwYXJhbSB7IGFueVtdIH0gaXRlbXMgQW4gYXJyYXkgdG8gZGVkdXBsaWNhdGUuXG4gKiBAcGFyYW0geyAoeDogYW55KSA9PiBzdHJpbmcgfSBnZXRLZXkgQ2FsbGJhY2sgdG8gZ2V0IGEgdmFsdWUgdGhhdCBkaXN0aW5ndWlzaGVzIHVuaXF1ZSBpdGVtcy5cbiAqIEByZXR1cm5zIHsgYW55W10gfVxuICovXG5mdW5jdGlvbiBtZXJnZUR1cGxpY2F0ZXNQcmVmZXJMYXN0IChpdGVtcywgZ2V0S2V5KSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgZm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGl0ZW0pO1xuICAgIG1hcC5zZXQoXG4gICAgICBrZXksXG4gICAgICAobWFwLmhhcyhrZXkpKVxuICAgICAgICA/IG1lcmdlX19kZWZhdWx0W1wiZGVmYXVsdFwiXShpdGVtLCBtYXAuZ2V0KGtleSksIHsgYXJyYXlNZXJnZTogb3ZlcndyaXRlTWVyZ2UkMSB9KVxuICAgICAgICA6IGl0ZW1cbiAgICApO1xuICB9XG4gIHJldHVybiBbLi4ubWFwLnZhbHVlcygpXS5yZXZlcnNlKCk7XG59XG5cbmNvbnN0IG92ZXJ3cml0ZU1lcmdlJDEgPSAoYWNjLCBzcmMsIG9wdGlvbnMpID0+IFsuLi5zcmNdO1xuXG4vKipcbiAqIEdldCBhIG5lc3RlZCBwcm9wZXJ0eSBmcm9tIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gICB7IG9iamVjdCB9ICAgb2JqICBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGZvciB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gICB7IHN0cmluZ1tdIH0gcGF0aCBUaGUgcGF0aCB0byB0aGUgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7IGFueSB9XG4gKi9cbmZ1bmN0aW9uIGdldCAob2JqLCBwYXRoKSB7XG4gIGZvciAoY29uc3Qga2V5IG9mIHBhdGgpIHtcbiAgICBpZiAoIW9iaikgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgb2JqID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIGludG8gYWxwaGFiZXRpYyBzZXF1ZW5jZSByZXByZXNlbnRhdGlvbiAoU2VxdWVuY2Ugd2l0aG91dCB6ZXJvZXMpLlxuICpcbiAqIEZvciBleGFtcGxlOiBgYSwgLi4uLCB6LCBhYSwgLi4uLCB6eiwgYWFhLCAuLi5gLlxuICpcbiAqIEBwYXJhbSAgIHsgbnVtYmVyIH0gbnVtICAgICAgICAgICAgICBOdW1iZXIgdG8gY29udmVydC4gTXVzdCBiZSA+PSAxLlxuICogQHBhcmFtICAgeyBzdHJpbmcgfSBbYmFzZUNoYXIgPSAnYSddIENoYXJhY3RlciBmb3IgMSBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gICB7IG51bWJlciB9IFtiYXNlID0gMjZdICAgICAgTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gdGhlIHNlcXVlbmNlLlxuICogQHJldHVybnMgeyBzdHJpbmcgfVxuICovXG5mdW5jdGlvbiBudW1iZXJUb0xldHRlclNlcXVlbmNlIChudW0sIGJhc2VDaGFyID0gJ2EnLCBiYXNlID0gMjYpIHtcbiAgY29uc3QgZGlnaXRzID0gW107XG4gIGRvIHtcbiAgICBudW0gLT0gMTtcbiAgICBkaWdpdHMucHVzaChudW0gJSBiYXNlKTtcbiAgICBudW0gPSAobnVtIC8gYmFzZSkgPj4gMDsgLy8gcXVpY2sgYGZsb29yYFxuICB9IHdoaWxlIChudW0gPiAwKTtcbiAgY29uc3QgYmFzZUNvZGUgPSBiYXNlQ2hhci5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gZGlnaXRzXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAobiA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhc2VDb2RlICsgbikpXG4gICAgLmpvaW4oJycpO1xufVxuXG5jb25zdCBJID0gWydJJywgJ1gnLCAnQycsICdNJ107XG5jb25zdCBWID0gWydWJywgJ0wnLCAnRCddO1xuXG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgdG8gaXQncyBSb21hbiByZXByZXNlbnRhdGlvbi4gTm8gbGFyZ2UgbnVtYmVycyBleHRlbnNpb24uXG4gKlxuICogQHBhcmFtICAgeyBudW1iZXIgfSBudW0gTnVtYmVyIHRvIGNvbnZlcnQuIGAwIDwgbnVtIDw9IDM5OTlgLlxuICogQHJldHVybnMgeyBzdHJpbmcgfVxuICovXG5mdW5jdGlvbiBudW1iZXJUb1JvbWFuIChudW0pIHtcbiAgcmV0dXJuIFsuLi4obnVtKSArICcnXVxuICAgIC5tYXAobiA9PiArbilcbiAgICAucmV2ZXJzZSgpXG4gICAgLm1hcCgodiwgaSkgPT4gKCh2ICUgNSA8IDQpXG4gICAgICA/ICh2IDwgNSA/ICcnIDogVltpXSkgKyBJW2ldLnJlcGVhdCh2ICUgNSlcbiAgICAgIDogSVtpXSArICh2IDwgNSA/IFZbaV0gOiBJW2kgKyAxXSkpKVxuICAgIC5yZXZlcnNlKClcbiAgICAuam9pbignJyk7XG59XG5cbi8qKlxuICogSGVscHMgdG8gYnVpbGQgdGV4dCBmcm9tIHdvcmRzLlxuICovXG5jbGFzcyBJbmxpbmVUZXh0QnVpbGRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIElubGluZVRleHRCdWlsZGVyLlxuICAgKlxuICAgKiBJZiBgbWF4TGluZUxlbmd0aGAgaXMgbm90IHByb3ZpZGVkIHRoZW4gaXQgaXMgZWl0aGVyIGBvcHRpb25zLndvcmR3cmFwYCBvciB1bmxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IE9wdGlvbnMgfSBvcHRpb25zICAgICAgICAgICBIdG1sVG9UZXh0IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7IG51bWJlciB9ICBbIG1heExpbmVMZW5ndGggXSBUaGlzIGJ1aWxkZXIgd2lsbCB0cnkgdG8gd3JhcCB0ZXh0IHRvIGZpdCB0aGlzIGxpbmUgbGVuZ3RoLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMsIG1heExpbmVMZW5ndGggPSB1bmRlZmluZWQpIHtcbiAgICAvKiogQHR5cGUgeyBzdHJpbmdbXVtdIH0gKi9cbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgLyoqIEB0eXBlIHsgc3RyaW5nW10gfSAgICovXG4gICAgdGhpcy5uZXh0TGluZVdvcmRzID0gW107XG4gICAgdGhpcy5tYXhMaW5lTGVuZ3RoID0gbWF4TGluZUxlbmd0aCB8fCBvcHRpb25zLndvcmR3cmFwIHx8IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdGhpcy5uZXh0TGluZUF2YWlsYWJsZUNoYXJzID0gdGhpcy5tYXhMaW5lTGVuZ3RoO1xuICAgIHRoaXMud3JhcENoYXJhY3RlcnMgPSBnZXQob3B0aW9ucywgWydsb25nV29yZFNwbGl0JywgJ3dyYXBDaGFyYWN0ZXJzJ10pIHx8IFtdO1xuICAgIHRoaXMuZm9yY2VXcmFwT25MaW1pdCA9IGdldChvcHRpb25zLCBbJ2xvbmdXb3JkU3BsaXQnLCAnZm9yY2VXcmFwT25MaW1pdCddKSB8fCBmYWxzZTtcblxuICAgIHRoaXMuc3Rhc2hlZFNwYWNlID0gZmFsc2U7XG4gICAgdGhpcy53b3JkQnJlYWtPcHBvcnR1bml0eSA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyB3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0geyBzdHJpbmcgfSB3b3JkIEEgd29yZCB0byBhZGQuXG4gICAqIEBwYXJhbSB7IGJvb2xlYW4gfSBbbm9XcmFwXSBEb24ndCB3cmFwIHRleHQgZXZlbiBpZiB0aGUgbGluZSBpcyB0b28gbG9uZy5cbiAgICovXG4gIHB1c2hXb3JkICh3b3JkLCBub1dyYXAgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMgPD0gMCAmJiAhbm9XcmFwKSB7XG4gICAgICB0aGlzLnN0YXJ0TmV3TGluZSgpO1xuICAgIH1cbiAgICBjb25zdCBpc0xpbmVTdGFydCA9IHRoaXMubmV4dExpbmVXb3Jkcy5sZW5ndGggPT09IDA7XG4gICAgY29uc3QgY29zdCA9IHdvcmQubGVuZ3RoICsgKGlzTGluZVN0YXJ0ID8gMCA6IDEpO1xuICAgIGlmICgoY29zdCA8PSB0aGlzLm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMpIHx8IG5vV3JhcCkgeyAvLyBGaXRzIGludG8gYXZhaWxhYmxlIGJ1ZGdldFxuXG4gICAgICB0aGlzLm5leHRMaW5lV29yZHMucHVzaCh3b3JkKTtcbiAgICAgIHRoaXMubmV4dExpbmVBdmFpbGFibGVDaGFycyAtPSBjb3N0O1xuXG4gICAgfSBlbHNlIHsgLy8gRG9lcyBub3QgZml0IC0gdHJ5IHRvIHNwbGl0IHRoZSB3b3JkXG5cbiAgICAgIC8vIFRoZSB3b3JkIGlzIG1vdmVkIHRvIGEgbmV3IGxpbmUgLSBwcmVmZXIgdG8gd3JhcCBiZXR3ZWVuIHdvcmRzLlxuICAgICAgY29uc3QgW2ZpcnN0LCAuLi5yZXN0XSA9IHRoaXMuc3BsaXRMb25nV29yZCh3b3JkKTtcbiAgICAgIGlmICghaXNMaW5lU3RhcnQpIHsgdGhpcy5zdGFydE5ld0xpbmUoKTsgfVxuICAgICAgdGhpcy5uZXh0TGluZVdvcmRzLnB1c2goZmlyc3QpO1xuICAgICAgdGhpcy5uZXh0TGluZUF2YWlsYWJsZUNoYXJzIC09IGZpcnN0Lmxlbmd0aDtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiByZXN0KSB7XG4gICAgICAgIHRoaXMuc3RhcnROZXdMaW5lKCk7XG4gICAgICAgIHRoaXMubmV4dExpbmVXb3Jkcy5wdXNoKHBhcnQpO1xuICAgICAgICB0aGlzLm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMgLT0gcGFydC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUG9wIGEgd29yZCBmcm9tIHRoZSBjdXJyZW50bHkgYnVpbHQgbGluZS5cbiAgICogVGhpcyBkb2Vzbid0IGFmZmVjdCBjb21wbGV0ZWQgbGluZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHsgc3RyaW5nIH1cbiAgICovXG4gIHBvcFdvcmQgKCkge1xuICAgIGNvbnN0IGxhc3RXb3JkID0gdGhpcy5uZXh0TGluZVdvcmRzLnBvcCgpO1xuICAgIGlmIChsYXN0V29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBpc0xpbmVTdGFydCA9IHRoaXMubmV4dExpbmVXb3Jkcy5sZW5ndGggPT09IDA7XG4gICAgICBjb25zdCBjb3N0ID0gbGFzdFdvcmQubGVuZ3RoICsgKGlzTGluZVN0YXJ0ID8gMCA6IDEpO1xuICAgICAgdGhpcy5uZXh0TGluZUF2YWlsYWJsZUNoYXJzICs9IGNvc3Q7XG4gICAgfVxuICAgIHJldHVybiBsYXN0V29yZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25jYXQgYSB3b3JkIHRvIHRoZSBsYXN0IHdvcmQgYWxyZWFkeSBpbiB0aGUgYnVpbGRlci5cbiAgICogQWRkcyBhIG5ldyB3b3JkIGluIGNhc2UgdGhlcmUgYXJlIG5vIHdvcmRzIHlldCBpbiB0aGUgbGFzdCBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0geyBzdHJpbmcgfSB3b3JkIEEgd29yZCB0byBiZSBjb25jYXRlbmF0ZWQuXG4gICAqIEBwYXJhbSB7IGJvb2xlYW4gfSBbbm9XcmFwXSBEb24ndCB3cmFwIHRleHQgZXZlbiBpZiB0aGUgbGluZSBpcyB0b28gbG9uZy5cbiAgICovXG4gIGNvbmNhdFdvcmQgKHdvcmQsIG5vV3JhcCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMud29yZEJyZWFrT3Bwb3J0dW5pdHkgJiYgd29yZC5sZW5ndGggPiB0aGlzLm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMpIHtcbiAgICAgIHRoaXMucHVzaFdvcmQod29yZCwgbm9XcmFwKTtcbiAgICAgIHRoaXMud29yZEJyZWFrT3Bwb3J0dW5pdHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdFdvcmQgPSB0aGlzLnBvcFdvcmQoKTtcbiAgICAgIHRoaXMucHVzaFdvcmQoKGxhc3RXb3JkKSA/IGxhc3RXb3JkLmNvbmNhdCh3b3JkKSA6IHdvcmQsIG5vV3JhcCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBjdXJyZW50IGxpbmUgKGFuZCBtb3JlIGVtcHR5IGxpbmVzIGlmIHByb3ZpZGVkIGFyZ3VtZW50ID4gMSkgdG8gdGhlIGxpc3Qgb2YgY29tcGxldGUgbGluZXMgYW5kIHN0YXJ0IGEgbmV3IG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gbiBOdW1iZXIgb2YgbGluZSBicmVha3MgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICAgKi9cbiAgc3RhcnROZXdMaW5lIChuID0gMSkge1xuICAgIHRoaXMubGluZXMucHVzaCh0aGlzLm5leHRMaW5lV29yZHMpO1xuICAgIGlmIChuID4gMSkge1xuICAgICAgdGhpcy5saW5lcy5wdXNoKC4uLkFycmF5LmZyb20oeyBsZW5ndGg6IG4gLSAxIH0sICgpID0+IFtdKSk7XG4gICAgfVxuICAgIHRoaXMubmV4dExpbmVXb3JkcyA9IFtdO1xuICAgIHRoaXMubmV4dExpbmVBdmFpbGFibGVDaGFycyA9IHRoaXMubWF4TGluZUxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBObyB3b3JkcyBpbiB0aGlzIGJ1aWxkZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gICAqL1xuICBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lcy5sZW5ndGggPT09IDBcbiAgICAgICAgJiYgdGhpcy5uZXh0TGluZVdvcmRzLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIGNsZWFyICgpIHtcbiAgICB0aGlzLmxpbmVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5uZXh0TGluZVdvcmRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5uZXh0TGluZUF2YWlsYWJsZUNoYXJzID0gdGhpcy5tYXhMaW5lTGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gYWxsIGxpbmVzIG9mIHdvcmRzIGluc2lkZSB0aGUgSW5saW5lVGV4dEJ1aWxkZXIgaW50byBhIGNvbXBsZXRlIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybnMgeyBzdHJpbmcgfVxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5saW5lcywgdGhpcy5uZXh0TGluZVdvcmRzXVxuICAgICAgLm1hcCh3b3JkcyA9PiB3b3Jkcy5qb2luKCcgJykpXG4gICAgICAuam9pbignXFxuJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgYSBsb25nIHdvcmQgdXAgdG8gZml0IHdpdGhpbiB0aGUgd29yZCB3cmFwIGxpbWl0LlxuICAgKiBVc2UgZWl0aGVyIGEgY2hhcmFjdGVyIHRvIHNwbGl0IGxvb2tpbmcgYmFjayBmcm9tIHRoZSB3b3JkIHdyYXAgbGltaXQsXG4gICAqIG9yIHRydW5jYXRlIHRvIHRoZSB3b3JkIHdyYXAgbGltaXQuXG4gICAqXG4gICAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gICB3b3JkIElucHV0IHdvcmQuXG4gICAqIEByZXR1cm5zIHsgc3RyaW5nW10gfSAgICAgIFBhcnRzIG9mIHRoZSB3b3JkLlxuICAgKi9cbiAgc3BsaXRMb25nV29yZCAod29yZCkge1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgd2hpbGUgKHdvcmQubGVuZ3RoID4gdGhpcy5tYXhMaW5lTGVuZ3RoKSB7XG5cbiAgICAgIGNvbnN0IGZpcnN0TGluZSA9IHdvcmQuc3Vic3RyaW5nKDAsIHRoaXMubWF4TGluZUxlbmd0aCk7XG4gICAgICBjb25zdCByZW1haW5pbmdDaGFycyA9IHdvcmQuc3Vic3RyaW5nKHRoaXMubWF4TGluZUxlbmd0aCk7XG5cbiAgICAgIGNvbnN0IHNwbGl0SW5kZXggPSBmaXJzdExpbmUubGFzdEluZGV4T2YodGhpcy53cmFwQ2hhcmFjdGVyc1tpZHhdKTtcblxuICAgICAgaWYgKHNwbGl0SW5kZXggPiAtMSkgeyAvLyBGb3VuZCBhIGNoYXJhY3RlciB0byBzcGxpdCBvblxuXG4gICAgICAgIHdvcmQgPSBmaXJzdExpbmUuc3Vic3RyaW5nKHNwbGl0SW5kZXggKyAxKSArIHJlbWFpbmluZ0NoYXJzO1xuICAgICAgICBwYXJ0cy5wdXNoKGZpcnN0TGluZS5zdWJzdHJpbmcoMCwgc3BsaXRJbmRleCArIDEpKTtcblxuICAgICAgfSBlbHNlIHsgLy8gTm90IGZvdW5kIGEgY2hhcmFjdGVyIHRvIHNwbGl0IG9uXG5cbiAgICAgICAgaWR4Kys7XG4gICAgICAgIGlmIChpZHggPCB0aGlzLndyYXBDaGFyYWN0ZXJzLmxlbmd0aCkgeyAvLyBUaGVyZSBpcyBuZXh0IGNoYXJhY3RlciB0byB0cnlcblxuICAgICAgICAgIHdvcmQgPSBmaXJzdExpbmUgKyByZW1haW5pbmdDaGFycztcblxuICAgICAgICB9IGVsc2UgeyAvLyBObyBtb3JlIGNoYXJhY3RlcnMgdG8gdHJ5XG5cbiAgICAgICAgICBpZiAodGhpcy5mb3JjZVdyYXBPbkxpbWl0KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGZpcnN0TGluZSk7XG4gICAgICAgICAgICB3b3JkID0gcmVtYWluaW5nQ2hhcnM7XG4gICAgICAgICAgICBpZiAod29yZC5sZW5ndGggPiB0aGlzLm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdvcmQgPSBmaXJzdExpbmUgKyByZW1haW5pbmdDaGFycztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG4gICAgcGFydHMucHVzaCh3b3JkKTsgLy8gQWRkIHJlbWFpbmluZyBwYXJ0IHRvIGFycmF5XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG5cblxuY2xhc3MgU3RhY2tJdGVtIHtcbiAgY29uc3RydWN0b3IgKG5leHQgPSBudWxsKSB7IHRoaXMubmV4dCA9IG5leHQ7IH1cblxuICBnZXRSb290ICgpIHsgcmV0dXJuICh0aGlzLm5leHQpID8gdGhpcy5uZXh0IDogdGhpczsgfVxufVxuXG5jbGFzcyBCbG9ja1N0YWNrSXRlbSBleHRlbmRzIFN0YWNrSXRlbSB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zLCBuZXh0ID0gbnVsbCwgbGVhZGluZ0xpbmVCcmVha3MgPSAxLCBtYXhMaW5lTGVuZ3RoID0gdW5kZWZpbmVkKSB7XG4gICAgc3VwZXIobmV4dCk7XG4gICAgdGhpcy5sZWFkaW5nTGluZUJyZWFrcyA9IGxlYWRpbmdMaW5lQnJlYWtzO1xuICAgIHRoaXMuaW5saW5lVGV4dEJ1aWxkZXIgPSBuZXcgSW5saW5lVGV4dEJ1aWxkZXIob3B0aW9ucywgbWF4TGluZUxlbmd0aCk7XG4gICAgdGhpcy5yYXdUZXh0ID0gJyc7XG4gICAgdGhpcy5zdGFzaGVkTGluZUJyZWFrcyA9IDA7XG4gICAgdGhpcy5pc1ByZSA9IG5leHQgJiYgbmV4dC5pc1ByZTtcbiAgICB0aGlzLmlzTm9XcmFwID0gbmV4dCAmJiBuZXh0LmlzTm9XcmFwO1xuICB9XG59XG5cbmNsYXNzIExpc3RTdGFja0l0ZW0gZXh0ZW5kcyBCbG9ja1N0YWNrSXRlbSB7XG4gIGNvbnN0cnVjdG9yIChcbiAgICBvcHRpb25zLFxuICAgIG5leHQgPSBudWxsLFxuICAgIHtcbiAgICAgIGludGVyUm93TGluZUJyZWFrcyA9IDEsXG4gICAgICBsZWFkaW5nTGluZUJyZWFrcyA9IDIsXG4gICAgICBtYXhMaW5lTGVuZ3RoID0gdW5kZWZpbmVkLFxuICAgICAgbWF4UHJlZml4TGVuZ3RoID0gMCxcbiAgICAgIHByZWZpeEFsaWduID0gJ2xlZnQnLFxuICAgIH0gPSB7fVxuICApIHtcbiAgICBzdXBlcihvcHRpb25zLCBuZXh0LCBsZWFkaW5nTGluZUJyZWFrcywgbWF4TGluZUxlbmd0aCk7XG4gICAgdGhpcy5tYXhQcmVmaXhMZW5ndGggPSBtYXhQcmVmaXhMZW5ndGg7XG4gICAgdGhpcy5wcmVmaXhBbGlnbiA9IHByZWZpeEFsaWduO1xuICAgIHRoaXMuaW50ZXJSb3dMaW5lQnJlYWtzID0gaW50ZXJSb3dMaW5lQnJlYWtzO1xuICB9XG59XG5cbmNsYXNzIExpc3RJdGVtU3RhY2tJdGVtIGV4dGVuZHMgQmxvY2tTdGFja0l0ZW0ge1xuICBjb25zdHJ1Y3RvciAoXG4gICAgb3B0aW9ucyxcbiAgICBuZXh0ID0gbnVsbCxcbiAgICB7XG4gICAgICBsZWFkaW5nTGluZUJyZWFrcyA9IDEsXG4gICAgICBtYXhMaW5lTGVuZ3RoID0gdW5kZWZpbmVkLFxuICAgICAgcHJlZml4ID0gJycsXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHN1cGVyKG9wdGlvbnMsIG5leHQsIGxlYWRpbmdMaW5lQnJlYWtzLCBtYXhMaW5lTGVuZ3RoKTtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgfVxufVxuXG5jbGFzcyBUYWJsZVN0YWNrSXRlbSBleHRlbmRzIFN0YWNrSXRlbSB7XG4gIGNvbnN0cnVjdG9yIChuZXh0ID0gbnVsbCkge1xuICAgIHN1cGVyKG5leHQpO1xuICAgIHRoaXMucm93cyA9IFtdO1xuICAgIHRoaXMuaXNQcmUgPSBuZXh0ICYmIG5leHQuaXNQcmU7XG4gICAgdGhpcy5pc05vV3JhcCA9IG5leHQgJiYgbmV4dC5pc05vV3JhcDtcbiAgfVxufVxuXG5jbGFzcyBUYWJsZVJvd1N0YWNrSXRlbSBleHRlbmRzIFN0YWNrSXRlbSB7XG4gIGNvbnN0cnVjdG9yIChuZXh0ID0gbnVsbCkge1xuICAgIHN1cGVyKG5leHQpO1xuICAgIHRoaXMuY2VsbHMgPSBbXTtcbiAgICB0aGlzLmlzUHJlID0gbmV4dCAmJiBuZXh0LmlzUHJlO1xuICAgIHRoaXMuaXNOb1dyYXAgPSBuZXh0ICYmIG5leHQuaXNOb1dyYXA7XG4gIH1cbn1cblxuY2xhc3MgVGFibGVDZWxsU3RhY2tJdGVtIGV4dGVuZHMgU3RhY2tJdGVtIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMsIG5leHQgPSBudWxsLCBtYXhDb2x1bW5XaWR0aCA9IHVuZGVmaW5lZCkge1xuICAgIHN1cGVyKG5leHQpO1xuICAgIHRoaXMuaW5saW5lVGV4dEJ1aWxkZXIgPSBuZXcgSW5saW5lVGV4dEJ1aWxkZXIob3B0aW9ucywgbWF4Q29sdW1uV2lkdGgpO1xuICAgIHRoaXMucmF3VGV4dCA9ICcnO1xuICAgIHRoaXMuc3Rhc2hlZExpbmVCcmVha3MgPSAwO1xuICAgIHRoaXMuaXNQcmUgPSBuZXh0ICYmIG5leHQuaXNQcmU7XG4gICAgdGhpcy5pc05vV3JhcCA9IG5leHQgJiYgbmV4dC5pc05vV3JhcDtcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2Zvcm1lclN0YWNrSXRlbSBleHRlbmRzIFN0YWNrSXRlbSB7XG4gIGNvbnN0cnVjdG9yIChuZXh0ID0gbnVsbCwgdHJhbnNmb3JtKSB7XG4gICAgc3VwZXIobmV4dCk7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hhcmFjdGVyc1RvQ29kZXMgKHN0cikge1xuICByZXR1cm4gWy4uLnN0cl1cbiAgICAubWFwKGMgPT4gJ1xcXFx1JyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikucGFkU3RhcnQoNCwgJzAnKSlcbiAgICAuam9pbignJyk7XG59XG5cbi8qKlxuICogSGVscHMgdG8gaGFuZGxlIEhUTUwgd2hpdGVzcGFjZXMuXG4gKlxuICogQGNsYXNzIFdoaXRlc3BhY2VQcm9jZXNzb3JcbiAqL1xuY2xhc3MgV2hpdGVzcGFjZVByb2Nlc3NvciB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgV2hpdGVzcGFjZVByb2Nlc3Nvci5cbiAgICpcbiAgICogQHBhcmFtIHsgT3B0aW9ucyB9IG9wdGlvbnMgICAgSHRtbFRvVGV4dCBvcHRpb25zLlxuICAgKiBAbWVtYmVyb2YgV2hpdGVzcGFjZVByb2Nlc3NvclxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICB0aGlzLndoaXRlc3BhY2VDaGFycyA9IChvcHRpb25zLnByZXNlcnZlTmV3bGluZXMpXG4gICAgICA/IG9wdGlvbnMud2hpdGVzcGFjZUNoYXJhY3RlcnMucmVwbGFjZSgvXFxuL2csICcnKVxuICAgICAgOiBvcHRpb25zLndoaXRlc3BhY2VDaGFyYWN0ZXJzO1xuICAgIGNvbnN0IHdoaXRlc3BhY2VDb2RlcyA9IGNoYXJhY3RlcnNUb0NvZGVzKHRoaXMud2hpdGVzcGFjZUNoYXJzKTtcbiAgICB0aGlzLmxlYWRpbmdXaGl0ZXNwYWNlUmUgPSBuZXcgUmVnRXhwKGBeWyR7d2hpdGVzcGFjZUNvZGVzfV1gKTtcbiAgICB0aGlzLnRyYWlsaW5nV2hpdGVzcGFjZVJlID0gbmV3IFJlZ0V4cChgWyR7d2hpdGVzcGFjZUNvZGVzfV0kYCk7XG4gICAgdGhpcy5hbGxXaGl0ZXNwYWNlT3JFbXB0eVJlID0gbmV3IFJlZ0V4cChgXlske3doaXRlc3BhY2VDb2Rlc31dKiRgKTtcbiAgICB0aGlzLm5ld2xpbmVPck5vbldoaXRlc3BhY2VSZSA9IG5ldyBSZWdFeHAoYChcXFxcbnxbXlxcXFxuJHt3aGl0ZXNwYWNlQ29kZXN9XSlgLCAnZycpO1xuICAgIHRoaXMubmV3bGluZU9yTm9uTmV3bGluZVN0cmluZ1JlID0gbmV3IFJlZ0V4cChgKFxcXFxufFteXFxcXG5dKylgLCAnZycpO1xuXG4gICAgaWYgKG9wdGlvbnMucHJlc2VydmVOZXdsaW5lcykge1xuXG4gICAgICBjb25zdCB3b3JkT3JOZXdsaW5lUmUgPSBuZXcgUmVnRXhwKGBcXFxcbnxbXlxcXFxuJHt3aGl0ZXNwYWNlQ29kZXN9XStgLCAnZ20nKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBTaHJpbmsgd2hpdGVzcGFjZXMgYW5kIHdyYXAgdGV4dCwgYWRkIHRvIHRoZSBidWlsZGVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7IHN0cmluZyB9ICAgICAgICAgICAgICAgICAgdGV4dCAgICAgICAgICAgICAgSW5wdXQgdGV4dC5cbiAgICAgICAqIEBwYXJhbSB7IElubGluZVRleHRCdWlsZGVyIH0gICAgICAgaW5saW5lVGV4dEJ1aWxkZXIgQSBidWlsZGVyIHRvIHJlY2VpdmUgcHJvY2Vzc2VkIHRleHQuXG4gICAgICAgKiBAcGFyYW0geyAoc3RyOiBzdHJpbmcpID0+IHN0cmluZyB9IFsgdHJhbnNmb3JtIF0gICAgIEEgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gd29yZHMuXG4gICAgICAgKiBAcGFyYW0geyBib29sZWFuIH0gICAgICAgICAgICAgICAgIFtub1dyYXBdIERvbid0IHdyYXAgdGV4dCBldmVuIGlmIHRoZSBsaW5lIGlzIHRvbyBsb25nLlxuICAgICAgICovXG4gICAgICB0aGlzLnNocmlua1dyYXBBZGQgPSBmdW5jdGlvbiAodGV4dCwgaW5saW5lVGV4dEJ1aWxkZXIsIHRyYW5zZm9ybSA9IChzdHIgPT4gc3RyKSwgbm9XcmFwID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0ZXh0KSB7IHJldHVybjsgfVxuICAgICAgICBjb25zdCBwcmV2aW91c2x5U3Rhc2hlZFNwYWNlID0gaW5saW5lVGV4dEJ1aWxkZXIuc3Rhc2hlZFNwYWNlO1xuICAgICAgICBsZXQgYW55TWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgbGV0IG0gPSB3b3JkT3JOZXdsaW5lUmUuZXhlYyh0ZXh0KTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICBhbnlNYXRjaCA9IHRydWU7XG4gICAgICAgICAgaWYgKG1bMF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5zdGFydE5ld0xpbmUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzbHlTdGFzaGVkU3BhY2UgfHwgdGhpcy50ZXN0TGVhZGluZ1doaXRlc3BhY2UodGV4dCkpIHtcbiAgICAgICAgICAgIGlubGluZVRleHRCdWlsZGVyLnB1c2hXb3JkKHRyYW5zZm9ybShtWzBdKSwgbm9XcmFwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIuY29uY2F0V29yZCh0cmFuc2Zvcm0obVswXSksIG5vV3JhcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICgobSA9IHdvcmRPck5ld2xpbmVSZS5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG1bMF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIGlubGluZVRleHRCdWlsZGVyLnN0YXJ0TmV3TGluZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIucHVzaFdvcmQodHJhbnNmb3JtKG1bMF0pLCBub1dyYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5zdGFzaGVkU3BhY2UgPSAocHJldmlvdXNseVN0YXNoZWRTcGFjZSAmJiAhYW55TWF0Y2gpIHx8ICh0aGlzLnRlc3RUcmFpbGluZ1doaXRlc3BhY2UodGV4dCkpO1xuICAgICAgICAvLyBObyBuZWVkIHRvIHN0YXNoIGEgc3BhY2UgaW4gY2FzZSBsYXN0IGFkZGVkIGl0ZW0gd2FzIGEgbmV3IGxpbmUsXG4gICAgICAgIC8vIGJ1dCB0aGF0IHdvbid0IGFmZmVjdCBhbnl0aGluZyBsYXRlciBhbnl3YXkuXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc3Qgd29yZFJlID0gbmV3IFJlZ0V4cChgW14ke3doaXRlc3BhY2VDb2Rlc31dK2AsICdnJyk7XG5cbiAgICAgIHRoaXMuc2hyaW5rV3JhcEFkZCA9IGZ1bmN0aW9uICh0ZXh0LCBpbmxpbmVUZXh0QnVpbGRlciwgdHJhbnNmb3JtID0gKHN0ciA9PiBzdHIpLCBub1dyYXAgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRleHQpIHsgcmV0dXJuOyB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzbHlTdGFzaGVkU3BhY2UgPSBpbmxpbmVUZXh0QnVpbGRlci5zdGFzaGVkU3BhY2U7XG4gICAgICAgIGxldCBhbnlNYXRjaCA9IGZhbHNlO1xuICAgICAgICBsZXQgbSA9IHdvcmRSZS5leGVjKHRleHQpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIGFueU1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldmlvdXNseVN0YXNoZWRTcGFjZSB8fCB0aGlzLnRlc3RMZWFkaW5nV2hpdGVzcGFjZSh0ZXh0KSkge1xuICAgICAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIucHVzaFdvcmQodHJhbnNmb3JtKG1bMF0pLCBub1dyYXApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5jb25jYXRXb3JkKHRyYW5zZm9ybShtWzBdKSwgbm9XcmFwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKChtID0gd29yZFJlLmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5wdXNoV29yZCh0cmFuc2Zvcm0obVswXSksIG5vV3JhcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlubGluZVRleHRCdWlsZGVyLnN0YXNoZWRTcGFjZSA9IChwcmV2aW91c2x5U3Rhc2hlZFNwYWNlICYmICFhbnlNYXRjaCkgfHwgdGhpcy50ZXN0VHJhaWxpbmdXaGl0ZXNwYWNlKHRleHQpO1xuICAgICAgfTtcblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGV4dCB3aXRoIG9ubHkgbWluaW1hbCBwcm9jZXNzaW5nLlxuICAgKiBFdmVyeXRoaW5nIGJldHdlZW4gbmV3bGluZXMgY29uc2lkZXJlZCBhIHNpbmdsZSB3b3JkLlxuICAgKiBObyB3aGl0ZXNwYWNlIGlzIHRyaW1tZWQuXG4gICAqIE5vdCBhZmZlY3RlZCBieSBwcmVzZXJ2ZU5ld2xpbmVzIG9wdGlvbiAtIGBcXG5gIGFsd2F5cyBzdGFydHMgYSBuZXcgbGluZS5cbiAgICpcbiAgICogYG5vV3JhcGAgYXJndW1lbnQgaXMgYHRydWVgIGJ5IGRlZmF1bHQgLSB0aGlzIHdvbid0IHN0YXJ0IGEgbmV3IGxpbmVcbiAgICogZXZlbiBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGxlZnQgaW4gdGhlIGN1cnJlbnQgbGluZS5cbiAgICpcbiAgICogQHBhcmFtIHsgc3RyaW5nIH0gICAgICAgICAgICB0ZXh0ICAgICAgICAgICAgICBJbnB1dCB0ZXh0LlxuICAgKiBAcGFyYW0geyBJbmxpbmVUZXh0QnVpbGRlciB9IGlubGluZVRleHRCdWlsZGVyIEEgYnVpbGRlciB0byByZWNlaXZlIHByb2Nlc3NlZCB0ZXh0LlxuICAgKiBAcGFyYW0geyBib29sZWFuIH0gICAgICAgICAgIFtub1dyYXBdIERvbid0IHdyYXAgdGV4dCBldmVuIGlmIHRoZSBsaW5lIGlzIHRvbyBsb25nLlxuICAgKi9cbiAgYWRkTGl0ZXJhbCAodGV4dCwgaW5saW5lVGV4dEJ1aWxkZXIsIG5vV3JhcCA9IHRydWUpIHtcbiAgICBpZiAoIXRleHQpIHsgcmV0dXJuOyB9XG4gICAgY29uc3QgcHJldmlvdXNseVN0YXNoZWRTcGFjZSA9IGlubGluZVRleHRCdWlsZGVyLnN0YXNoZWRTcGFjZTtcbiAgICBsZXQgYW55TWF0Y2ggPSBmYWxzZTtcbiAgICBsZXQgbSA9IHRoaXMubmV3bGluZU9yTm9uTmV3bGluZVN0cmluZ1JlLmV4ZWModGV4dCk7XG4gICAgaWYgKG0pIHtcbiAgICAgIGFueU1hdGNoID0gdHJ1ZTtcbiAgICAgIGlmIChtWzBdID09PSAnXFxuJykge1xuICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5zdGFydE5ld0xpbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNseVN0YXNoZWRTcGFjZSkge1xuICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5wdXNoV29yZChtWzBdLCBub1dyYXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIuY29uY2F0V29yZChtWzBdLCBub1dyYXApO1xuICAgICAgfVxuICAgICAgd2hpbGUgKChtID0gdGhpcy5uZXdsaW5lT3JOb25OZXdsaW5lU3RyaW5nUmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG1bMF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIuc3RhcnROZXdMaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIucHVzaFdvcmQobVswXSwgbm9XcmFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbmxpbmVUZXh0QnVpbGRlci5zdGFzaGVkU3BhY2UgPSAocHJldmlvdXNseVN0YXNoZWRTcGFjZSAmJiAhYW55TWF0Y2gpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gdGV4dCBzdGFydHMgd2l0aCBIVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBAcGFyYW0gICB7IHN0cmluZyB9ICB0ZXh0ICBUaGUgc3RyaW5nIHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gICAqL1xuICB0ZXN0TGVhZGluZ1doaXRlc3BhY2UgKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5sZWFkaW5nV2hpdGVzcGFjZVJlLnRlc3QodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiB0ZXh0IGVuZHMgd2l0aCBIVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBAcGFyYW0gICB7IHN0cmluZyB9ICB0ZXh0ICBUaGUgc3RyaW5nIHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gICAqL1xuICB0ZXN0VHJhaWxpbmdXaGl0ZXNwYWNlICh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhaWxpbmdXaGl0ZXNwYWNlUmUudGVzdCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHRleHQgY29udGFpbnMgYW55IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gIHRleHQgIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAgICogQHJldHVybnMgeyBib29sZWFuIH1cbiAgICovXG4gIHRlc3RDb250YWluc1dvcmRzICh0ZXh0KSB7XG4gICAgcmV0dXJuICF0aGlzLmFsbFdoaXRlc3BhY2VPckVtcHR5UmUudGVzdCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBuZXdsaW5lcyBpZiB0aGVyZSBhcmUgbm8gd29yZHMuXG4gICAqXG4gICAqIElmIGFueSB3b3JkIGlzIGZvdW5kIHRoZW4gcmV0dXJuIHplcm8gcmVnYXJkbGVzcyBvZiB0aGUgYWN0dWFsIG51bWJlciBvZiBuZXdsaW5lcy5cbiAgICpcbiAgICogQHBhcmFtICAgeyBzdHJpbmcgfSAgdGV4dCAgSW5wdXQgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7IG51bWJlciB9XG4gICAqL1xuICBjb3VudE5ld2xpbmVzTm9Xb3JkcyAodGV4dCkge1xuICAgIHRoaXMubmV3bGluZU9yTm9uV2hpdGVzcGFjZVJlLmxhc3RJbmRleCA9IDA7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGxldCBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy5uZXdsaW5lT3JOb25XaGl0ZXNwYWNlUmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgIGlmIChtYXRjaFswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVyO1xuICB9XG5cbn1cblxuLyoqXG4gKiBIZWxwcyB0byBidWlsZCB0ZXh0IGZyb20gaW5saW5lIGFuZCBibG9jayBlbGVtZW50cy5cbiAqXG4gKiBAY2xhc3MgQmxvY2tUZXh0QnVpbGRlclxuICovXG5jbGFzcyBCbG9ja1RleHRCdWlsZGVyIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCbG9ja1RleHRCdWlsZGVyLlxuICAgKlxuICAgKiBAcGFyYW0geyBPcHRpb25zIH0gb3B0aW9ucyBIdG1sVG9UZXh0IG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7IGltcG9ydCgnc2VsZGVyZWUnKS5QaWNrZXI8RG9tTm9kZSwgVGFnRGVmaW5pdGlvbj4gfSBwaWNrZXIgU2VsZWN0b3JzIGRlY2lzaW9uIHRyZWUgcGlja2VyLlxuICAgKiBAcGFyYW0geyBhbnl9IFttZXRhZGF0YV0gT3B0aW9uYWwgbWV0YWRhdGEgZm9yIEhUTUwgZG9jdW1lbnQsIGZvciB1c2UgaW4gZm9ybWF0dGVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zLCBwaWNrZXIsIG1ldGFkYXRhID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnBpY2tlciA9IHBpY2tlcjtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgdGhpcy53aGl0ZXNwYWNlUHJvY2Vzc29yID0gbmV3IFdoaXRlc3BhY2VQcm9jZXNzb3Iob3B0aW9ucyk7XG4gICAgLyoqIEB0eXBlIHsgU3RhY2tJdGVtIH0gKi9cbiAgICB0aGlzLl9zdGFja0l0ZW0gPSBuZXcgQmxvY2tTdGFja0l0ZW0ob3B0aW9ucyk7XG4gICAgLyoqIEB0eXBlIHsgVHJhbnNmb3JtZXJTdGFja0l0ZW0gfSAqL1xuICAgIHRoaXMuX3dvcmRUcmFuc2Zvcm1lciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXQgYSB3b3JkLWJ5LXdvcmQgdHJhbnNmb3JtIGZ1bmN0aW9uIG9udG8gdGhlIHRyYW5zZm9ybWF0aW9ucyBzdGFjay5cbiAgICpcbiAgICogTWFpbmx5IHVzZWQgZm9yIHVwcGVyY2FzaW5nLiBDYW4gYmUgYnlwYXNzZWQgdG8gYWRkIHVuZm9ybWF0dGVkIHRleHQgc3VjaCBhcyBVUkxzLlxuICAgKlxuICAgKiBXb3JkIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIGJlZm9yZSB3cmFwcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHsgKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcgfSB3b3JkVHJhbnNmb3JtIFdvcmQgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24uXG4gICAqL1xuICBwdXNoV29yZFRyYW5zZm9ybSAod29yZFRyYW5zZm9ybSkge1xuICAgIHRoaXMuX3dvcmRUcmFuc2Zvcm1lciA9IG5ldyBUcmFuc2Zvcm1lclN0YWNrSXRlbSh0aGlzLl93b3JkVHJhbnNmb3JtZXIsIHdvcmRUcmFuc2Zvcm0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZ1bmN0aW9uIGZyb20gdGhlIHdvcmQgdHJhbnNmb3JtYXRpb25zIHN0YWNrLlxuICAgKlxuICAgKiBAcmV0dXJucyB7IChzdHI6IHN0cmluZykgPT4gc3RyaW5nIH0gQSBmdW5jdGlvbiB0aGF0IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcG9wV29yZFRyYW5zZm9ybSAoKSB7XG4gICAgaWYgKCF0aGlzLl93b3JkVHJhbnNmb3JtZXIpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuX3dvcmRUcmFuc2Zvcm1lci50cmFuc2Zvcm07XG4gICAgdGhpcy5fd29yZFRyYW5zZm9ybWVyID0gdGhpcy5fd29yZFRyYW5zZm9ybWVyLm5leHQ7XG4gICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZ25vcmUgd29yZHdyYXAgb3B0aW9uIGluIGZvbGxvd3VwIGlubGluZSBhZGRpdGlvbnMgYW5kIGRpc2FibGUgYXV0b21hdGljIHdyYXBwaW5nLlxuICAgKi9cbiAgc3RhcnROb1dyYXAgKCkge1xuICAgIHRoaXMuX3N0YWNrSXRlbS5pc05vV3JhcCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGF1dG9tYXRpYyB3cmFwcGluZyB0byBiZWhhdmlvciBkZWZpbmVkIGJ5IG9wdGlvbnMuXG4gICAqL1xuICBzdG9wTm9XcmFwICgpIHtcbiAgICB0aGlzLl9zdGFja0l0ZW0uaXNOb1dyYXAgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJucyB7IChzdHI6IHN0cmluZykgPT4gc3RyaW5nIH0gKi9cbiAgX2dldENvbWJpbmVkV29yZFRyYW5zZm9ybWVyICgpIHtcbiAgICBjb25zdCB3dCA9ICh0aGlzLl93b3JkVHJhbnNmb3JtZXIpXG4gICAgICA/ICgoc3RyKSA9PiBhcHBseVRyYW5zZm9ybWVyKHN0ciwgdGhpcy5fd29yZFRyYW5zZm9ybWVyKSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNlID0gdGhpcy5vcHRpb25zLmVuY29kZUNoYXJhY3RlcnM7XG4gICAgcmV0dXJuICh3dClcbiAgICAgID8gKChjZSkgPyAoc3RyKSA9PiBjZSh3dChzdHIpKSA6IHd0KVxuICAgICAgOiBjZTtcbiAgfVxuXG4gIF9wb3BTdGFja0l0ZW0gKCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zdGFja0l0ZW07XG4gICAgdGhpcy5fc3RhY2tJdGVtID0gaXRlbS5uZXh0O1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGxpbmUgYnJlYWsgaW50byBjdXJyZW50bHkgYnVpbHQgYmxvY2suXG4gICAqL1xuICBhZGRMaW5lQnJlYWsgKCkge1xuICAgIGlmICghKFxuICAgICAgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgQmxvY2tTdGFja0l0ZW1cbiAgICAgIHx8IHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIExpc3RJdGVtU3RhY2tJdGVtXG4gICAgICB8fCB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBUYWJsZUNlbGxTdGFja0l0ZW1cbiAgICApKSB7IHJldHVybjsgfVxuICAgIGlmICh0aGlzLl9zdGFja0l0ZW0uaXNQcmUpIHtcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5yYXdUZXh0ICs9ICdcXG4nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIuc3RhcnROZXdMaW5lKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IHRvIGJyZWFrIGxpbmUgaW4gY2FzZSBkaXJlY3RseSBmb2xsb3dpbmcgdGV4dCB3aWxsIG5vdCBmaXQuXG4gICAqL1xuICBhZGRXb3JkQnJlYWtPcHBvcnR1bml0eSAoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgQmxvY2tTdGFja0l0ZW1cbiAgICAgIHx8IHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIExpc3RJdGVtU3RhY2tJdGVtXG4gICAgICB8fCB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBUYWJsZUNlbGxTdGFja0l0ZW1cbiAgICApIHtcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlci53b3JkQnJlYWtPcHBvcnR1bml0eSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5vZGUgaW5saW5lIGludG8gdGhlIGN1cnJlbnRseSBidWlsdCBibG9jay5cbiAgICpcbiAgICogQHBhcmFtIHsgc3RyaW5nIH0gc3RyXG4gICAqIFRleHQgY29udGVudCBvZiBhIG5vZGUgdG8gYWRkLlxuICAgKlxuICAgKiBAcGFyYW0geyBvYmplY3QgfSBbcGFyYW0xXVxuICAgKiBPYmplY3QgaG9sZGluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0geyBib29sZWFuIH0gW3BhcmFtMS5ub1dvcmRUcmFuc2Zvcm1dXG4gICAqIElnbm9yZSB3b3JkIHRyYW5zZm9ybWVycyBpZiB0aGVyZSBhcmUgYW55LlxuICAgKiBEb24ndCBlbmNvZGUgY2hhcmFjdGVycyBhcyB3ZWxsLlxuICAgKiAoVXNlIHRoaXMgZm9yIHRoaW5ncyBsaWtlIFVSTCBhZGRyZXNzZXMpLlxuICAgKi9cbiAgYWRkSW5saW5lIChzdHIsIHsgbm9Xb3JkVHJhbnNmb3JtID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgaWYgKCEoXG4gICAgICB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBCbG9ja1N0YWNrSXRlbVxuICAgICAgfHwgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgTGlzdEl0ZW1TdGFja0l0ZW1cbiAgICAgIHx8IHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIFRhYmxlQ2VsbFN0YWNrSXRlbVxuICAgICkpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAodGhpcy5fc3RhY2tJdGVtLmlzUHJlKSB7XG4gICAgICB0aGlzLl9zdGFja0l0ZW0ucmF3VGV4dCArPSBzdHI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgc3RyLmxlbmd0aCA9PT0gMCB8fCAvLyBlbXB0eSBzdHJpbmdcbiAgICAgIChcbiAgICAgICAgdGhpcy5fc3RhY2tJdGVtLnN0YXNoZWRMaW5lQnJlYWtzICYmIC8vIHN0YXNoZWQgbGluZWJyZWFrcyBtYWtlIHdoaXRlc3BhY2UgaXJyZWxldmFudFxuICAgICAgICAhdGhpcy53aGl0ZXNwYWNlUHJvY2Vzc29yLnRlc3RDb250YWluc1dvcmRzKHN0cikgLy8gbm8gd29yZHMgdG8gYWRkXG4gICAgICApXG4gICAgKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZU5ld2xpbmVzKSB7XG4gICAgICBjb25zdCBuZXdsaW5lc051bWJlciA9IHRoaXMud2hpdGVzcGFjZVByb2Nlc3Nvci5jb3VudE5ld2xpbmVzTm9Xb3JkcyhzdHIpO1xuICAgICAgaWYgKG5ld2xpbmVzTnVtYmVyID4gMCkge1xuICAgICAgICB0aGlzLl9zdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIuc3RhcnROZXdMaW5lKG5ld2xpbmVzTnVtYmVyKTtcbiAgICAgICAgLy8ga2VlcCBzdGFzaGVkTGluZUJyZWFrcyB1bmNoYW5nZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGFja0l0ZW0uc3Rhc2hlZExpbmVCcmVha3MpIHtcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlci5zdGFydE5ld0xpbmUodGhpcy5fc3RhY2tJdGVtLnN0YXNoZWRMaW5lQnJlYWtzKTtcbiAgICB9XG4gICAgdGhpcy53aGl0ZXNwYWNlUHJvY2Vzc29yLnNocmlua1dyYXBBZGQoXG4gICAgICBzdHIsXG4gICAgICB0aGlzLl9zdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIsXG4gICAgICAobm9Xb3JkVHJhbnNmb3JtKSA/IHVuZGVmaW5lZCA6IHRoaXMuX2dldENvbWJpbmVkV29yZFRyYW5zZm9ybWVyKCksXG4gICAgICB0aGlzLl9zdGFja0l0ZW0uaXNOb1dyYXBcbiAgICApO1xuICAgIHRoaXMuX3N0YWNrSXRlbS5zdGFzaGVkTGluZUJyZWFrcyA9IDA7IC8vIGlubGluZSB0ZXh0IGRvZXNuJ3QgaW50cm9kdWNlIGxpbmUgYnJlYWtzXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgc3RyaW5nIGlubGluZSBpbnRvIHRoZSBjdXJyZW50bHkgYnVpbHQgYmxvY2suXG4gICAqXG4gICAqIFVzZSB0aGlzIGZvciBtYXJrdXAgZWxlbWVudHMgdGhhdCBkb24ndCBoYXZlIHRvIGFkaGVyZVxuICAgKiB0byB0ZXh0IGxheW91dCBydWxlcy5cbiAgICpcbiAgICogQHBhcmFtIHsgc3RyaW5nIH0gc3RyIFRleHQgdG8gYWRkLlxuICAgKi9cbiAgYWRkTGl0ZXJhbCAoc3RyKSB7XG4gICAgaWYgKCEoXG4gICAgICB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBCbG9ja1N0YWNrSXRlbVxuICAgICAgfHwgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgTGlzdEl0ZW1TdGFja0l0ZW1cbiAgICAgIHx8IHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIFRhYmxlQ2VsbFN0YWNrSXRlbVxuICAgICkpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgIGlmICh0aGlzLl9zdGFja0l0ZW0uaXNQcmUpIHtcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5yYXdUZXh0ICs9IHN0cjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhY2tJdGVtLnN0YXNoZWRMaW5lQnJlYWtzKSB7XG4gICAgICB0aGlzLl9zdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIuc3RhcnROZXdMaW5lKHRoaXMuX3N0YWNrSXRlbS5zdGFzaGVkTGluZUJyZWFrcyk7XG4gICAgfVxuICAgIHRoaXMud2hpdGVzcGFjZVByb2Nlc3Nvci5hZGRMaXRlcmFsKFxuICAgICAgc3RyLFxuICAgICAgdGhpcy5fc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLFxuICAgICAgdGhpcy5fc3RhY2tJdGVtLmlzTm9XcmFwXG4gICAgKTtcbiAgICB0aGlzLl9zdGFja0l0ZW0uc3Rhc2hlZExpbmVCcmVha3MgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGJ1aWxkaW5nIGEgbmV3IGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0geyBvYmplY3QgfSBbcGFyYW0wXVxuICAgKiBPYmplY3QgaG9sZGluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgYmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAubGVhZGluZ0xpbmVCcmVha3NdXG4gICAqIFRoaXMgYmxvY2sgc2hvdWxkIGhhdmUgYXQgbGVhc3QgdGhpcyBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gc2VwYXJhdGUgaXQgZnJvbSBhbnkgcHJlY2VkaW5nIGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSAgW3BhcmFtMC5yZXNlcnZlZExpbmVMZW5ndGhdXG4gICAqIFJlc2VydmUgdGhpcyBudW1iZXIgb2YgY2hhcmFjdGVycyBvbiBlYWNoIGxpbmUgZm9yIGJsb2NrIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHsgYm9vbGVhbiB9IFtwYXJhbTAuaXNQcmVdXG4gICAqIFNob3VsZCBIVE1MIHdoaXRlc3BhY2UgYmUgcHJlc2VydmVkIGluc2lkZSB0aGlzIGJsb2NrLlxuICAgKi9cbiAgb3BlbkJsb2NrICh7IGxlYWRpbmdMaW5lQnJlYWtzID0gMSwgcmVzZXJ2ZWRMaW5lTGVuZ3RoID0gMCwgaXNQcmUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgoMjAsIHRoaXMuX3N0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlci5tYXhMaW5lTGVuZ3RoIC0gcmVzZXJ2ZWRMaW5lTGVuZ3RoKTtcbiAgICB0aGlzLl9zdGFja0l0ZW0gPSBuZXcgQmxvY2tTdGFja0l0ZW0oXG4gICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICB0aGlzLl9zdGFja0l0ZW0sXG4gICAgICBsZWFkaW5nTGluZUJyZWFrcyxcbiAgICAgIG1heExpbmVMZW5ndGhcbiAgICApO1xuICAgIGlmIChpc1ByZSkgeyB0aGlzLl9zdGFja0l0ZW0uaXNQcmUgPSB0cnVlOyB9XG4gIH1cblxuICAvKipcbiAgICogRmluYWxpemUgY3VycmVudGx5IGJ1aWx0IGJsb2NrLCBhZGQgaXQncyBjb250ZW50IHRvIHRoZSBwYXJlbnQgYmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IG9iamVjdCB9IFtwYXJhbTBdXG4gICAqIE9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBibG9jay5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC50cmFpbGluZ0xpbmVCcmVha3NdXG4gICAqIFRoaXMgYmxvY2sgc2hvdWxkIGhhdmUgYXQgbGVhc3QgdGhpcyBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gc2VwYXJhdGUgaXQgZnJvbSBhbnkgZm9sbG93aW5nIGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0geyAoc3RyOiBzdHJpbmcpID0+IHN0cmluZyB9IFtwYXJhbTAuYmxvY2tUcmFuc2Zvcm1dXG4gICAqIEEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHRoZSBibG9jayB0ZXh0IGJlZm9yZSBhZGRpbmcgdG8gdGhlIHBhcmVudCBibG9jay5cbiAgICogVGhpcyBoYXBwZW5zIGFmdGVyIHdvcmQgd3JhcCBhbmQgc2hvdWxkIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCByZXNlcnZlZCBsaW5lIGxlbmd0aFxuICAgKiBpbiBvcmRlciB0byBrZWVwIGxpbmUgbGVuZ3RocyBjb3JyZWN0LlxuICAgKiBVc2VkIGZvciB3aG9sZSBibG9jayBtYXJrdXAuXG4gICAqL1xuICBjbG9zZUJsb2NrICh7IHRyYWlsaW5nTGluZUJyZWFrcyA9IDEsIGJsb2NrVHJhbnNmb3JtID0gdW5kZWZpbmVkIH0gPSB7fSkge1xuICAgIGNvbnN0IGJsb2NrID0gdGhpcy5fcG9wU3RhY2tJdGVtKCk7XG4gICAgY29uc3QgYmxvY2tUZXh0ID0gKGJsb2NrVHJhbnNmb3JtKSA/IGJsb2NrVHJhbnNmb3JtKGdldFRleHQoYmxvY2spKSA6IGdldFRleHQoYmxvY2spO1xuICAgIGFkZFRleHQodGhpcy5fc3RhY2tJdGVtLCBibG9ja1RleHQsIGJsb2NrLmxlYWRpbmdMaW5lQnJlYWtzLCBNYXRoLm1heChibG9jay5zdGFzaGVkTGluZUJyZWFrcywgdHJhaWxpbmdMaW5lQnJlYWtzKSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYnVpbGRpbmcgYSBuZXcgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHsgb2JqZWN0IH0gW3BhcmFtMF1cbiAgICogT2JqZWN0IGhvbGRpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAubWF4UHJlZml4TGVuZ3RoXVxuICAgKiBMZW5ndGggb2YgdGhlIGxvbmdlc3QgbGlzdCBpdGVtIHByZWZpeC5cbiAgICogSWYgbm90IHN1cHBsaWVkIG9yIHRvbyBzbWFsbCB0aGVuIGxpc3QgaXRlbXMgd29uJ3QgYmUgYWxpZ25lZCBwcm9wZXJseS5cbiAgICpcbiAgICogQHBhcmFtIHsgJ2xlZnQnIHwgJ3JpZ2h0JyB9IFtwYXJhbTAucHJlZml4QWxpZ25dXG4gICAqIFNwZWNpZnkgaG93IHByZWZpeGVzIG9mIGRpZmZlcmVudCBsZW5ndGhzIGhhdmUgdG8gYmUgYWxpZ25lZFxuICAgKiB3aXRoaW4gYSBjb2x1bW4uXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAuaW50ZXJSb3dMaW5lQnJlYWtzXVxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGxpc3QgaXRlbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAubGVhZGluZ0xpbmVCcmVha3NdXG4gICAqIFRoaXMgbGlzdCBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0aGlzIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBzZXBhcmF0ZSBpdCBmcm9tIGFueSBwcmVjZWRpbmcgYmxvY2suXG4gICAqL1xuICBvcGVuTGlzdCAoeyBtYXhQcmVmaXhMZW5ndGggPSAwLCBwcmVmaXhBbGlnbiA9ICdsZWZ0JywgaW50ZXJSb3dMaW5lQnJlYWtzID0gMSwgbGVhZGluZ0xpbmVCcmVha3MgPSAyIH0gPSB7fSkge1xuICAgIHRoaXMuX3N0YWNrSXRlbSA9IG5ldyBMaXN0U3RhY2tJdGVtKHRoaXMub3B0aW9ucywgdGhpcy5fc3RhY2tJdGVtLCB7XG4gICAgICBpbnRlclJvd0xpbmVCcmVha3M6IGludGVyUm93TGluZUJyZWFrcyxcbiAgICAgIGxlYWRpbmdMaW5lQnJlYWtzOiBsZWFkaW5nTGluZUJyZWFrcyxcbiAgICAgIG1heExpbmVMZW5ndGg6IHRoaXMuX3N0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlci5tYXhMaW5lTGVuZ3RoLFxuICAgICAgbWF4UHJlZml4TGVuZ3RoOiBtYXhQcmVmaXhMZW5ndGgsXG4gICAgICBwcmVmaXhBbGlnbjogcHJlZml4QWxpZ25cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBidWlsZGluZyBhIG5ldyBsaXN0IGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTBcbiAgICogT2JqZWN0IGhvbGRpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxpc3QgaXRlbS5cbiAgICpcbiAgICogQHBhcmFtIHsgc3RyaW5nIH0gW3BhcmFtMC5wcmVmaXhdXG4gICAqIFByZWZpeCBmb3IgdGhpcyBsaXN0IGl0ZW0gKGl0ZW0gbnVtYmVyLCBidWxsZXQgcG9pbnQsIGV0YykuXG4gICAqL1xuICBvcGVuTGlzdEl0ZW0gKHsgcHJlZml4ID0gJycgfSA9IHt9KSB7XG4gICAgaWYgKCEodGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgTGlzdFN0YWNrSXRlbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBhZGQgYSBsaXN0IGl0ZW0gdG8gc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgbGlzdCEgQ2hlY2sgdGhlIGZvcm1hdHRlci4nKTtcbiAgICB9XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuX3N0YWNrSXRlbTtcbiAgICBjb25zdCBwcmVmaXhMZW5ndGggPSBNYXRoLm1heChwcmVmaXgubGVuZ3RoLCBsaXN0Lm1heFByZWZpeExlbmd0aCk7XG4gICAgY29uc3QgbWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KDIwLCBsaXN0LmlubGluZVRleHRCdWlsZGVyLm1heExpbmVMZW5ndGggLSBwcmVmaXhMZW5ndGgpO1xuICAgIHRoaXMuX3N0YWNrSXRlbSA9IG5ldyBMaXN0SXRlbVN0YWNrSXRlbSh0aGlzLm9wdGlvbnMsIGxpc3QsIHtcbiAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgbWF4TGluZUxlbmd0aDogbWF4TGluZUxlbmd0aCxcbiAgICAgIGxlYWRpbmdMaW5lQnJlYWtzOiBsaXN0LmludGVyUm93TGluZUJyZWFrc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmFsaXplIGN1cnJlbnRseSBidWlsdCBsaXN0IGl0ZW0sIGFkZCBpdCdzIGNvbnRlbnQgdG8gdGhlIHBhcmVudCBsaXN0LlxuICAgKi9cbiAgY2xvc2VMaXN0SXRlbSAoKSB7XG4gICAgY29uc3QgbGlzdEl0ZW0gPSB0aGlzLl9wb3BTdGFja0l0ZW0oKTtcbiAgICBjb25zdCBsaXN0ID0gbGlzdEl0ZW0ubmV4dDtcblxuICAgIGNvbnN0IHByZWZpeExlbmd0aCA9IE1hdGgubWF4KGxpc3RJdGVtLnByZWZpeC5sZW5ndGgsIGxpc3QubWF4UHJlZml4TGVuZ3RoKTtcbiAgICBjb25zdCBzcGFjaW5nID0gJ1xcbicgKyAnICcucmVwZWF0KHByZWZpeExlbmd0aCk7XG4gICAgY29uc3QgcHJlZml4ID0gKGxpc3QucHJlZml4QWxpZ24gPT09ICdyaWdodCcpXG4gICAgICA/IGxpc3RJdGVtLnByZWZpeC5wYWRTdGFydChwcmVmaXhMZW5ndGgpXG4gICAgICA6IGxpc3RJdGVtLnByZWZpeC5wYWRFbmQocHJlZml4TGVuZ3RoKTtcbiAgICBjb25zdCB0ZXh0ID0gcHJlZml4ICsgZ2V0VGV4dChsaXN0SXRlbSkucmVwbGFjZSgvXFxuL2csIHNwYWNpbmcpO1xuXG4gICAgYWRkVGV4dChcbiAgICAgIGxpc3QsXG4gICAgICB0ZXh0LFxuICAgICAgbGlzdEl0ZW0ubGVhZGluZ0xpbmVCcmVha3MsXG4gICAgICBNYXRoLm1heChsaXN0SXRlbS5zdGFzaGVkTGluZUJyZWFrcywgbGlzdC5pbnRlclJvd0xpbmVCcmVha3MpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZSBjdXJyZW50bHkgYnVpbHQgbGlzdCwgYWRkIGl0J3MgY29udGVudCB0byB0aGUgcGFyZW50IGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0geyBvYmplY3QgfSBwYXJhbTBcbiAgICogT2JqZWN0IGhvbGRpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAudHJhaWxpbmdMaW5lQnJlYWtzXVxuICAgKiBUaGlzIGxpc3Qgc2hvdWxkIGhhdmUgYXQgbGVhc3QgdGhpcyBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gc2VwYXJhdGUgaXQgZnJvbSBhbnkgZm9sbG93aW5nIGJsb2NrLlxuICAgKi9cbiAgY2xvc2VMaXN0ICh7IHRyYWlsaW5nTGluZUJyZWFrcyA9IDIgfSA9IHt9KSB7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuX3BvcFN0YWNrSXRlbSgpO1xuICAgIGNvbnN0IHRleHQgPSBnZXRUZXh0KGxpc3QpO1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICBhZGRUZXh0KHRoaXMuX3N0YWNrSXRlbSwgdGV4dCwgbGlzdC5sZWFkaW5nTGluZUJyZWFrcywgdHJhaWxpbmdMaW5lQnJlYWtzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYnVpbGRpbmcgYSB0YWJsZS5cbiAgICovXG4gIG9wZW5UYWJsZSAoKSB7XG4gICAgdGhpcy5fc3RhY2tJdGVtID0gbmV3IFRhYmxlU3RhY2tJdGVtKHRoaXMuX3N0YWNrSXRlbSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYnVpbGRpbmcgYSB0YWJsZSByb3cuXG4gICAqL1xuICBvcGVuVGFibGVSb3cgKCkge1xuICAgIGlmICghKHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIFRhYmxlU3RhY2tJdGVtKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGFkZCBhIHRhYmxlIHJvdyB0byBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSB0YWJsZSEgQ2hlY2sgdGhlIGZvcm1hdHRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhY2tJdGVtID0gbmV3IFRhYmxlUm93U3RhY2tJdGVtKHRoaXMuX3N0YWNrSXRlbSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYnVpbGRpbmcgYSB0YWJsZSBjZWxsLlxuICAgKlxuICAgKiBAcGFyYW0geyBvYmplY3QgfSBbcGFyYW0wXVxuICAgKiBPYmplY3QgaG9sZGluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgY2VsbC5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC5tYXhDb2x1bW5XaWR0aF1cbiAgICogV3JhcCBjZWxsIGNvbnRlbnQgdG8gdGhpcyB3aWR0aC4gRmFsbCBiYWNrIHRvIGdsb2JhbCB3b3Jkd3JhcCB2YWx1ZSBpZiB1bmRlZmluZWQuXG4gICAqL1xuICBvcGVuVGFibGVDZWxsICh7IG1heENvbHVtbldpZHRoID0gdW5kZWZpbmVkIH0gPSB7fSkge1xuICAgIGlmICghKHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIFRhYmxlUm93U3RhY2tJdGVtKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGFkZCBhIHRhYmxlIGNlbGwgdG8gc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgdGFibGUgcm93ISBDaGVjayB0aGUgZm9ybWF0dGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9zdGFja0l0ZW0gPSBuZXcgVGFibGVDZWxsU3RhY2tJdGVtKHRoaXMub3B0aW9ucywgdGhpcy5fc3RhY2tJdGVtLCBtYXhDb2x1bW5XaWR0aCk7XG4gIH1cblxuICAvKipcbiAgICogRmluYWxpemUgY3VycmVudGx5IGJ1aWx0IHRhYmxlIGNlbGwgYW5kIGFkZCBpdCB0byBwYXJlbnQgdGFibGUgcm93J3MgY2VsbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7IG9iamVjdCB9IFtwYXJhbTBdXG4gICAqIE9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBjZWxsLlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLmNvbHNwYW5dIEhvdyBtYW55IGNvbHVtbnMgdGhpcyBjZWxsIHNob3VsZCBvY2N1cHkuXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAucm93c3Bhbl0gSG93IG1hbnkgcm93cyB0aGlzIGNlbGwgc2hvdWxkIG9jY3VweS5cbiAgICovXG4gIGNsb3NlVGFibGVDZWxsICh7IGNvbHNwYW4gPSAxLCByb3dzcGFuID0gMSB9ID0ge30pIHtcbiAgICBjb25zdCBjZWxsID0gdGhpcy5fcG9wU3RhY2tJdGVtKCk7XG4gICAgY29uc3QgdGV4dCA9IHRyaW1DaGFyYWN0ZXIoZ2V0VGV4dChjZWxsKSwgJ1xcbicpO1xuICAgIGNlbGwubmV4dC5jZWxscy5wdXNoKHsgY29sc3BhbjogY29sc3Bhbiwgcm93c3Bhbjogcm93c3BhbiwgdGV4dDogdGV4dCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZSBjdXJyZW50bHkgYnVpbHQgdGFibGUgcm93IGFuZCBhZGQgaXQgdG8gcGFyZW50IHRhYmxlJ3Mgcm93cy5cbiAgICovXG4gIGNsb3NlVGFibGVSb3cgKCkge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMuX3BvcFN0YWNrSXRlbSgpO1xuICAgIHJvdy5uZXh0LnJvd3MucHVzaChyb3cuY2VsbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmFsaXplIGN1cnJlbnRseSBidWlsdCB0YWJsZSBhbmQgYWRkIHRoZSByZW5kZXJlZCB0ZXh0IHRvIHRoZSBwYXJlbnQgYmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IG9iamVjdCB9IHBhcmFtMFxuICAgKiBPYmplY3QgaG9sZGluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IFRhYmxlUHJpbnRlciB9IHBhcmFtMC50YWJsZVRvU3RyaW5nXG4gICAqIEEgZnVuY3Rpb24gdG8gY29udmVydCBhIHRhYmxlIG9mIHN0cmluZ2lmaWVkIGNlbGxzIGludG8gYSBjb21wbGV0ZSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC5sZWFkaW5nTGluZUJyZWFrc11cbiAgICogVGhpcyB0YWJsZSBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0aGlzIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBzZXBhcmF0ZSBpZiBmcm9tIGFueSBwcmVjZWRpbmcgYmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAudHJhaWxpbmdMaW5lQnJlYWtzXVxuICAgKiBUaGlzIHRhYmxlIHNob3VsZCBoYXZlIGF0IGxlYXN0IHRoaXMgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIHNlcGFyYXRlIGl0IGZyb20gYW55IGZvbGxvd2luZyBibG9jay5cbiAgICovXG4gIGNsb3NlVGFibGUgKHsgdGFibGVUb1N0cmluZywgbGVhZGluZ0xpbmVCcmVha3MgPSAyLCB0cmFpbGluZ0xpbmVCcmVha3MgPSAyIH0pIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3BvcFN0YWNrSXRlbSgpO1xuICAgIGNvbnN0IG91dHB1dCA9IHRhYmxlVG9TdHJpbmcodGFibGUucm93cyk7XG4gICAgaWYgKG91dHB1dCkge1xuICAgICAgYWRkVGV4dCh0aGlzLl9zdGFja0l0ZW0sIG91dHB1dCwgbGVhZGluZ0xpbmVCcmVha3MsIHRyYWlsaW5nTGluZUJyZWFrcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcmVuZGVyZWQgdGV4dCBjb250ZW50IG9mIHRoaXMgYnVpbGRlci5cbiAgICpcbiAgICogQHJldHVybnMgeyBzdHJpbmcgfVxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiBnZXRUZXh0KHRoaXMuX3N0YWNrSXRlbS5nZXRSb290KCkpO1xuICAgIC8vIFRoZXJlIHNob3VsZCBvbmx5IGJlIHRoZSByb290IGl0ZW0gaWYgZXZlcnl0aGluZyBpcyBjbG9zZWQgcHJvcGVybHkuXG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXRUZXh0IChzdGFja0l0ZW0pIHtcbiAgaWYgKCEoXG4gICAgc3RhY2tJdGVtIGluc3RhbmNlb2YgQmxvY2tTdGFja0l0ZW1cbiAgICB8fCBzdGFja0l0ZW0gaW5zdGFuY2VvZiBMaXN0SXRlbVN0YWNrSXRlbVxuICAgIHx8IHN0YWNrSXRlbSBpbnN0YW5jZW9mIFRhYmxlQ2VsbFN0YWNrSXRlbVxuICApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGJsb2NrcywgbGlzdCBpdGVtcyBhbmQgdGFibGUgY2VsbHMgY2FuIGJlIHJlcXVlc3RlZCBmb3IgdGV4dCBjb250ZW50cy4nKTtcbiAgfVxuICByZXR1cm4gKHN0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlci5pc0VtcHR5KCkpXG4gICAgPyBzdGFja0l0ZW0ucmF3VGV4dFxuICAgIDogc3RhY2tJdGVtLnJhd1RleHQgKyBzdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gYWRkVGV4dCAoc3RhY2tJdGVtLCB0ZXh0LCBsZWFkaW5nTGluZUJyZWFrcywgdHJhaWxpbmdMaW5lQnJlYWtzKSB7XG4gIGlmICghKFxuICAgIHN0YWNrSXRlbSBpbnN0YW5jZW9mIEJsb2NrU3RhY2tJdGVtXG4gICAgfHwgc3RhY2tJdGVtIGluc3RhbmNlb2YgTGlzdEl0ZW1TdGFja0l0ZW1cbiAgICB8fCBzdGFja0l0ZW0gaW5zdGFuY2VvZiBUYWJsZUNlbGxTdGFja0l0ZW1cbiAgKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSBibG9ja3MsIGxpc3QgaXRlbXMgYW5kIHRhYmxlIGNlbGxzIGNhbiBjb250YWluIHRleHQuJyk7XG4gIH1cbiAgY29uc3QgcGFyZW50VGV4dCA9IGdldFRleHQoc3RhY2tJdGVtKTtcbiAgY29uc3QgbGluZUJyZWFrcyA9IE1hdGgubWF4KHN0YWNrSXRlbS5zdGFzaGVkTGluZUJyZWFrcywgbGVhZGluZ0xpbmVCcmVha3MpO1xuICBzdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIuY2xlYXIoKTtcbiAgaWYgKHBhcmVudFRleHQpIHtcbiAgICBzdGFja0l0ZW0ucmF3VGV4dCA9IHBhcmVudFRleHQgKyAnXFxuJy5yZXBlYXQobGluZUJyZWFrcykgKyB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIHN0YWNrSXRlbS5yYXdUZXh0ID0gdGV4dDtcbiAgICBzdGFja0l0ZW0ubGVhZGluZ0xpbmVCcmVha3MgPSBsaW5lQnJlYWtzO1xuICB9XG4gIHN0YWNrSXRlbS5zdGFzaGVkTGluZUJyZWFrcyA9IHRyYWlsaW5nTGluZUJyZWFrcztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyBzdHJpbmcgfSBzdHIgQSBzdHJpbmcgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHsgVHJhbnNmb3JtZXJTdGFja0l0ZW0gfSB0cmFuc2Zvcm1lciBBIHRyYW5zZm9ybWVyIGl0ZW0gKHdpdGggcG9zc2libGUgY29udGludWF0aW9uKS5cbiAqIEByZXR1cm5zIHsgc3RyaW5nIH1cbiAqL1xuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1lciAoc3RyLCB0cmFuc2Zvcm1lcikge1xuICByZXR1cm4gKCh0cmFuc2Zvcm1lcikgPyBhcHBseVRyYW5zZm9ybWVyKHRyYW5zZm9ybWVyLnRyYW5zZm9ybShzdHIpLCB0cmFuc2Zvcm1lci5uZXh0KSA6IHN0cik7XG59XG5cbi8qKlxuICogQ29tcGlsZSBzZWxlY3RvcnMgaW50byBhIGRlY2lzaW9uIHRyZWUsXG4gKiByZXR1cm4gYSBmdW5jdGlvbiBpbnRlbmRlZCBmb3IgYmF0Y2ggcHJvY2Vzc2luZy5cbiAqXG4gKiBAcGFyYW0gICB7IE9wdGlvbnMgfSBbb3B0aW9ucyA9IHt9XSAgIEh0bWxUb1RleHQgb3B0aW9ucyAoZGVmYXVsdHMsIGZvcm1hdHRlcnMsIHVzZXIgb3B0aW9ucyBtZXJnZWQsIGRlZHVwbGljYXRlZCkuXG4gKiBAcmV0dXJucyB7IChodG1sOiBzdHJpbmcsIG1ldGFkYXRhPzogYW55KSA9PiBzdHJpbmcgfSBQcmUtY29uZmlndXJlZCBjb252ZXJ0ZXIgZnVuY3Rpb24uXG4gKiBAc3RhdGljXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUkMSAob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHNlbGVjdG9yc1dpdGhvdXRGb3JtYXQgPSBvcHRpb25zLnNlbGVjdG9ycy5maWx0ZXIocyA9PiAhcy5mb3JtYXQpO1xuICBpZiAoc2VsZWN0b3JzV2l0aG91dEZvcm1hdC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRm9sbG93aW5nIHNlbGVjdG9ycyBoYXZlIG5vIHNwZWNpZmllZCBmb3JtYXQ6ICcgK1xuICAgICAgc2VsZWN0b3JzV2l0aG91dEZvcm1hdC5tYXAocyA9PiBgXFxgJHtzLnNlbGVjdG9yfVxcYGApLmpvaW4oJywgJylcbiAgICApO1xuICB9XG4gIGNvbnN0IHBpY2tlciA9IG5ldyBzZWxkZXJlZS5EZWNpc2lvblRyZWUoXG4gICAgb3B0aW9ucy5zZWxlY3RvcnMubWFwKHMgPT4gW3Muc2VsZWN0b3IsIHNdKVxuICApLmJ1aWxkKHBsdWdpbkh0bWxwYXJzZXIyLmhwMkJ1aWxkZXIpO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5lbmNvZGVDaGFyYWN0ZXJzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5lbmNvZGVDaGFyYWN0ZXJzID0gbWFrZVJlcGxhY2VyRnJvbURpY3Qob3B0aW9ucy5lbmNvZGVDaGFyYWN0ZXJzKTtcbiAgfVxuXG4gIGNvbnN0IGJhc2VTZWxlY3RvcnNQaWNrZXIgPSBuZXcgc2VsZGVyZWUuRGVjaXNpb25UcmVlKFxuICAgIG9wdGlvbnMuYmFzZUVsZW1lbnRzLnNlbGVjdG9ycy5tYXAoKHMsIGkpID0+IFtzLCBpICsgMV0pXG4gICkuYnVpbGQocGx1Z2luSHRtbHBhcnNlcjIuaHAyQnVpbGRlcik7XG4gIGZ1bmN0aW9uIGZpbmRCYXNlRWxlbWVudHMgKGRvbSkge1xuICAgIHJldHVybiBmaW5kQmFzZXMoZG9tLCBvcHRpb25zLCBiYXNlU2VsZWN0b3JzUGlja2VyKTtcbiAgfVxuXG4gIGNvbnN0IGxpbWl0ZWRXYWxrID0gbGltaXRlZERlcHRoUmVjdXJzaXZlKFxuICAgIG9wdGlvbnMubGltaXRzLm1heERlcHRoLFxuICAgIHJlY3Vyc2l2ZVdhbGssXG4gICAgZnVuY3Rpb24gKGRvbSwgYnVpbGRlcikge1xuICAgICAgYnVpbGRlci5hZGRJbmxpbmUob3B0aW9ucy5saW1pdHMuZWxsaXBzaXMgfHwgJycpO1xuICAgIH1cbiAgKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGh0bWwsIG1ldGFkYXRhID0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MoaHRtbCwgbWV0YWRhdGEsIG9wdGlvbnMsIHBpY2tlciwgZmluZEJhc2VFbGVtZW50cywgbGltaXRlZFdhbGspO1xuICB9O1xufVxuXG5cbi8qKlxuICogQ29udmVydCBnaXZlbiBIVE1MIGFjY29yZGluZyB0byBwcmVwcm9jZXNzZWQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0geyBzdHJpbmcgfSBodG1sIEhUTUwgY29udGVudCB0byBjb252ZXJ0LlxuICogQHBhcmFtIHsgYW55IH0gbWV0YWRhdGEgT3B0aW9uYWwgbWV0YWRhdGEgZm9yIEhUTUwgZG9jdW1lbnQsIGZvciB1c2UgaW4gZm9ybWF0dGVycy5cbiAqIEBwYXJhbSB7IE9wdGlvbnMgfSBvcHRpb25zIEh0bWxUb1RleHQgb3B0aW9ucyAocHJlcHJvY2Vzc2VkKS5cbiAqIEBwYXJhbSB7IGltcG9ydCgnc2VsZGVyZWUnKS5QaWNrZXI8RG9tTm9kZSwgVGFnRGVmaW5pdGlvbj4gfSBwaWNrZXJcbiAqIFRhZyBkZWZpbml0aW9uIHBpY2tlciBmb3IgRE9NIG5vZGVzIHByb2Nlc3NpbmcuXG4gKiBAcGFyYW0geyAoZG9tOiBEb21Ob2RlW10pID0+IERvbU5vZGVbXSB9IGZpbmRCYXNlRWxlbWVudHNcbiAqIEZ1bmN0aW9uIHRvIGV4dHJhY3QgZWxlbWVudHMgZnJvbSBIVE1MIERPTVxuICogdGhhdCB3aWxsIG9ubHkgYmUgcHJlc2VudCBpbiB0aGUgb3V0cHV0IHRleHQuXG4gKiBAcGFyYW0geyBSZWN1cnNpdmVDYWxsYmFjayB9IHdhbGsgUmVjdXJzaXZlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyBzdHJpbmcgfVxuICovXG5mdW5jdGlvbiBwcm9jZXNzIChodG1sLCBtZXRhZGF0YSwgb3B0aW9ucywgcGlja2VyLCBmaW5kQmFzZUVsZW1lbnRzLCB3YWxrKSB7XG4gIGNvbnN0IG1heElucHV0TGVuZ3RoID0gb3B0aW9ucy5saW1pdHMubWF4SW5wdXRMZW5ndGg7XG4gIGlmIChtYXhJbnB1dExlbmd0aCAmJiBodG1sICYmIGh0bWwubGVuZ3RoID4gbWF4SW5wdXRMZW5ndGgpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgSW5wdXQgbGVuZ3RoICR7aHRtbC5sZW5ndGh9IGlzIGFib3ZlIGFsbG93ZWQgbGltaXQgb2YgJHttYXhJbnB1dExlbmd0aH0uIFRydW5jYXRpbmcgd2l0aG91dCBlbGxpcHNpcy5gXG4gICAgKTtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcoMCwgbWF4SW5wdXRMZW5ndGgpO1xuICB9XG5cbiAgY29uc3QgZG9jdW1lbnQgPSBodG1scGFyc2VyMi5wYXJzZURvY3VtZW50KGh0bWwsIHsgZGVjb2RlRW50aXRpZXM6IG9wdGlvbnMuZGVjb2RlRW50aXRpZXMgfSk7XG4gIGNvbnN0IGJhc2VzID0gZmluZEJhc2VFbGVtZW50cyhkb2N1bWVudC5jaGlsZHJlbik7XG4gIGNvbnN0IGJ1aWxkZXIgPSBuZXcgQmxvY2tUZXh0QnVpbGRlcihvcHRpb25zLCBwaWNrZXIsIG1ldGFkYXRhKTtcbiAgd2FsayhiYXNlcywgYnVpbGRlcik7XG4gIHJldHVybiBidWlsZGVyLnRvU3RyaW5nKCk7XG59XG5cblxuZnVuY3Rpb24gZmluZEJhc2VzIChkb20sIG9wdGlvbnMsIGJhc2VTZWxlY3RvcnNQaWNrZXIpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZVdhbGsgKHdhbGssIC8qKiBAdHlwZSB7IERvbU5vZGVbXSB9ICovIGRvbSkge1xuICAgIGRvbSA9IGRvbS5zbGljZSgwLCBvcHRpb25zLmxpbWl0cy5tYXhDaGlsZE5vZGVzKTtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgZG9tKSB7XG4gICAgICBpZiAoZWxlbS50eXBlICE9PSAndGFnJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBpY2tlZFNlbGVjdG9ySW5kZXggPSBiYXNlU2VsZWN0b3JzUGlja2VyLnBpY2sxKGVsZW0pO1xuICAgICAgaWYgKHBpY2tlZFNlbGVjdG9ySW5kZXggPiAwKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7IHNlbGVjdG9ySW5kZXg6IHBpY2tlZFNlbGVjdG9ySW5kZXgsIGVsZW1lbnQ6IGVsZW0gfSk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgd2FsayhlbGVtLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+PSBvcHRpb25zLmxpbWl0cy5tYXhCYXNlRWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGxpbWl0ZWRXYWxrID0gbGltaXRlZERlcHRoUmVjdXJzaXZlKFxuICAgIG9wdGlvbnMubGltaXRzLm1heERlcHRoLFxuICAgIHJlY3Vyc2l2ZVdhbGtcbiAgKTtcbiAgbGltaXRlZFdhbGsoZG9tKTtcblxuICBpZiAob3B0aW9ucy5iYXNlRWxlbWVudHMub3JkZXJCeSAhPT0gJ29jY3VycmVuY2UnKSB7IC8vICdzZWxlY3RvcnMnXG4gICAgcmVzdWx0cy5zb3J0KChhLCBiKSA9PiBhLnNlbGVjdG9ySW5kZXggLSBiLnNlbGVjdG9ySW5kZXgpO1xuICB9XG4gIHJldHVybiAob3B0aW9ucy5iYXNlRWxlbWVudHMucmV0dXJuRG9tQnlEZWZhdWx0ICYmIHJlc3VsdHMubGVuZ3RoID09PSAwKVxuICAgID8gZG9tXG4gICAgOiByZXN1bHRzLm1hcCh4ID0+IHguZWxlbWVudCk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gd2FsayB0aHJvdWdoIERPTSBub2RlcyBhbmQgYWNjdW11bGF0ZSB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb25zLlxuICpcbiAqIEBwYXJhbSAgIHsgUmVjdXJzaXZlQ2FsbGJhY2sgfSB3YWxrICAgIFJlY3Vyc2l2ZSBjYWxsYmFjay5cbiAqIEBwYXJhbSAgIHsgRG9tTm9kZVtdIH0gICAgICAgICBbZG9tXSAgIE5vZGVzIGFycmF5IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0gICB7IEJsb2NrVGV4dEJ1aWxkZXIgfSAgYnVpbGRlciBQYXNzZWQgYXJvdW5kIHRvIGFjY3VtdWxhdGUgb3V0cHV0IHRleHQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVXYWxrICh3YWxrLCBkb20sIGJ1aWxkZXIpIHtcbiAgaWYgKCFkb20pIHsgcmV0dXJuOyB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IGJ1aWxkZXIub3B0aW9ucztcblxuICBjb25zdCB0b29NYW55Q2hpbGROb2RlcyA9IGRvbS5sZW5ndGggPiBvcHRpb25zLmxpbWl0cy5tYXhDaGlsZE5vZGVzO1xuICBpZiAodG9vTWFueUNoaWxkTm9kZXMpIHtcbiAgICBkb20gPSBkb20uc2xpY2UoMCwgb3B0aW9ucy5saW1pdHMubWF4Q2hpbGROb2Rlcyk7XG4gICAgZG9tLnB1c2goe1xuICAgICAgZGF0YTogb3B0aW9ucy5saW1pdHMuZWxsaXBzaXMsXG4gICAgICB0eXBlOiAndGV4dCdcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgZWxlbSBvZiBkb20pIHtcbiAgICBzd2l0Y2ggKGVsZW0udHlwZSkge1xuICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgYnVpbGRlci5hZGRJbmxpbmUoZWxlbS5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICd0YWcnOiB7XG4gICAgICAgIGNvbnN0IHRhZ0RlZmluaXRpb24gPSBidWlsZGVyLnBpY2tlci5waWNrMShlbGVtKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXR0ZXJzW3RhZ0RlZmluaXRpb24uZm9ybWF0XTtcbiAgICAgICAgZm9ybWF0KGVsZW0sIHdhbGssIGJ1aWxkZXIsIHRhZ0RlZmluaXRpb24ub3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyBPYmplY3Q8c3RyaW5nLHN0cmluZyB8IGZhbHNlPiB9IGRpY3RcbiAqIEEgZGljdGlvbmFyeSB3aGVyZSBrZXlzIGFyZSBjaGFyYWN0ZXJzIHRvIHJlcGxhY2VcbiAqIGFuZCB2YWx1ZXMgYXJlIHJlcGxhY2VtZW50IHN0cmluZ3MuXG4gKlxuICogRmlyc3QgY29kZSBwb2ludCBmcm9tIGRpY3Qga2V5cyBpcyB1c2VkLlxuICogQ29tcG91bmQgZW1vamlzIHdpdGggWldKIGFyZSBub3Qgc3VwcG9ydGVkIChub3QgdW50aWwgTm9kZSAxNikuXG4gKlxuICogQHJldHVybnMgeyAoKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcpIHwgdW5kZWZpbmVkIH1cbiAqL1xuZnVuY3Rpb24gbWFrZVJlcGxhY2VyRnJvbURpY3QgKGRpY3QpIHtcbiAgaWYgKCFkaWN0IHx8IE9iamVjdC5rZXlzKGRpY3QpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqIEB0eXBlIHsgW3N0cmluZywgc3RyaW5nXVtdIH0gKi9cbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGRpY3QpLmZpbHRlcigoWywgdl0pID0+IHYgIT09IGZhbHNlKTtcbiAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKFxuICAgIGVudHJpZXNcbiAgICAgIC5tYXAoKFtjXSkgPT4gYCgke3VuaWNvZGVFc2NhcGUoWy4uLmNdWzBdKX0pYClcbiAgICAgIC5qb2luKCd8JyksXG4gICAgJ2cnXG4gICk7XG4gIGNvbnN0IHZhbHVlcyA9IGVudHJpZXMubWFwKChbLCB2XSkgPT4gdik7XG4gIGNvbnN0IHJlcGxhY2VyID0gKG0sIC4uLmNncykgPT4gdmFsdWVzW2Nncy5maW5kSW5kZXgoY2cgPT4gY2cpXTtcbiAgcmV0dXJuIChzdHIpID0+IHN0ci5yZXBsYWNlKHJlZ2V4LCByZXBsYWNlcik7XG59XG5cbi8qKlxuICogRHVtbXkgZm9ybWF0dGVyIHRoYXQgZGlzY2FyZHMgdGhlIGlucHV0IGFuZCBkb2VzIG5vdGhpbmcuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFNraXAgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgLyogZG8gbm90aGluZyAqL1xufVxuXG4vKipcbiAqIEluc2VydCB0aGUgZ2l2ZW4gc3RyaW5nIGxpdGVyYWwgaW5saW5lIGluc3RlYWQgb2YgYSB0YWcuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdElubGluZVN0cmluZyAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLmFkZExpdGVyYWwoZm9ybWF0T3B0aW9ucy5zdHJpbmcgfHwgJycpO1xufVxuXG4vKipcbiAqIEluc2VydCBhIGJsb2NrIHdpdGggdGhlIGdpdmVuIHN0cmluZyBsaXRlcmFsIGluc3RlYWQgb2YgYSB0YWcuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEJsb2NrU3RyaW5nIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlbkJsb2NrKHsgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbiAgYnVpbGRlci5hZGRMaXRlcmFsKGZvcm1hdE9wdGlvbnMuc3RyaW5nIHx8ICcnKTtcbiAgYnVpbGRlci5jbG9zZUJsb2NrKHsgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYW4gaW5saW5lLWxldmVsIGVsZW1lbnQuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdElubGluZSAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBibG9jay1sZXZlbCBjb250YWluZXIuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEJsb2NrJDEgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuQmxvY2soeyBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xuICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICBidWlsZGVyLmNsb3NlQmxvY2soeyB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlck9wZW5UYWcgKGVsZW0pIHtcbiAgY29uc3QgYXR0cnMgPSAoZWxlbS5hdHRyaWJzICYmIGVsZW0uYXR0cmlicy5sZW5ndGgpXG4gICAgPyAnICcgKyBPYmplY3QuZW50cmllcyhlbGVtLmF0dHJpYnMpXG4gICAgICAubWFwKChbaywgdl0pID0+ICgodiA9PT0gJycpID8gayA6IGAke2t9PSR7di5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyl9YCkpXG4gICAgICAuam9pbignICcpXG4gICAgOiAnJztcbiAgcmV0dXJuIGA8JHtlbGVtLm5hbWV9JHthdHRyc30+YDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xvc2VUYWcgKGVsZW0pIHtcbiAgcmV0dXJuIGA8LyR7ZWxlbS5uYW1lfT5gO1xufVxuXG4vKipcbiAqIFJlbmRlciBhbiBlbGVtZW50IGFzIGlubGluZSBIVE1MIHRhZywgd2FsayB0aHJvdWdoIGl0J3MgY2hpbGRyZW4uXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdElubGluZVRhZyAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLnN0YXJ0Tm9XcmFwKCk7XG4gIGJ1aWxkZXIuYWRkTGl0ZXJhbChyZW5kZXJPcGVuVGFnKGVsZW0pKTtcbiAgYnVpbGRlci5zdG9wTm9XcmFwKCk7XG4gIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gIGJ1aWxkZXIuc3RhcnROb1dyYXAoKTtcbiAgYnVpbGRlci5hZGRMaXRlcmFsKHJlbmRlckNsb3NlVGFnKGVsZW0pKTtcbiAgYnVpbGRlci5zdG9wTm9XcmFwKCk7XG59XG5cbi8qKlxuICogUmVuZGVyIGFuIGVsZW1lbnQgYXMgSFRNTCBibG9jayBiYWcsIHdhbGsgdGhyb3VnaCBpdCdzIGNoaWxkcmVuLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRCbG9ja1RhZyAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5CbG9jayh7IGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG4gIGJ1aWxkZXIuc3RhcnROb1dyYXAoKTtcbiAgYnVpbGRlci5hZGRMaXRlcmFsKHJlbmRlck9wZW5UYWcoZWxlbSkpO1xuICBidWlsZGVyLnN0b3BOb1dyYXAoKTtcbiAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgYnVpbGRlci5zdGFydE5vV3JhcCgpO1xuICBidWlsZGVyLmFkZExpdGVyYWwocmVuZGVyQ2xvc2VUYWcoZWxlbSkpO1xuICBidWlsZGVyLnN0b3BOb1dyYXAoKTtcbiAgYnVpbGRlci5jbG9zZUJsb2NrKHsgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xufVxuXG4vKipcbiAqIFJlbmRlciBhbiBlbGVtZW50IHdpdGggYWxsIGl0J3MgY2hpbGRyZW4gYXMgaW5saW5lIEhUTUwuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdElubGluZUh0bWwgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5zdGFydE5vV3JhcCgpO1xuICBidWlsZGVyLmFkZExpdGVyYWwoXG4gICAgZG9tU2VyaWFsaXplci5yZW5kZXIoZWxlbSwgeyBkZWNvZGVFbnRpdGllczogYnVpbGRlci5vcHRpb25zLmRlY29kZUVudGl0aWVzIH0pXG4gICk7XG4gIGJ1aWxkZXIuc3RvcE5vV3JhcCgpO1xufVxuXG4vKipcbiAqIFJlbmRlciBhbiBlbGVtZW50IHdpdGggYWxsIGl0J3MgY2hpbGRyZW4gYXMgSFRNTCBibG9jay5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0QmxvY2tIdG1sIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlbkJsb2NrKHsgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbiAgYnVpbGRlci5zdGFydE5vV3JhcCgpO1xuICBidWlsZGVyLmFkZExpdGVyYWwoXG4gICAgZG9tU2VyaWFsaXplci5yZW5kZXIoZWxlbSwgeyBkZWNvZGVFbnRpdGllczogYnVpbGRlci5vcHRpb25zLmRlY29kZUVudGl0aWVzIH0pXG4gICk7XG4gIGJ1aWxkZXIuc3RvcE5vV3JhcCgpO1xuICBidWlsZGVyLmNsb3NlQmxvY2soeyB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG59XG5cbi8qKlxuICogUmVuZGVyIGlubGluZSBlbGVtZW50IHdyYXBwZWQgd2l0aCBnaXZlbiBzdHJpbmdzLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRJbmxpbmVTdXJyb3VuZCAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLmFkZExpdGVyYWwoZm9ybWF0T3B0aW9ucy5wcmVmaXggfHwgJycpO1xuICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICBidWlsZGVyLmFkZExpdGVyYWwoZm9ybWF0T3B0aW9ucy5zdWZmaXggfHwgJycpO1xufVxuXG52YXIgZ2VuZXJpY0Zvcm1hdHRlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYmxvY2s6IGZvcm1hdEJsb2NrJDEsXG4gIGJsb2NrSHRtbDogZm9ybWF0QmxvY2tIdG1sLFxuICBibG9ja1N0cmluZzogZm9ybWF0QmxvY2tTdHJpbmcsXG4gIGJsb2NrVGFnOiBmb3JtYXRCbG9ja1RhZyxcbiAgaW5saW5lOiBmb3JtYXRJbmxpbmUsXG4gIGlubGluZUh0bWw6IGZvcm1hdElubGluZUh0bWwsXG4gIGlubGluZVN0cmluZzogZm9ybWF0SW5saW5lU3RyaW5nLFxuICBpbmxpbmVTdXJyb3VuZDogZm9ybWF0SW5saW5lU3Vycm91bmQsXG4gIGlubGluZVRhZzogZm9ybWF0SW5saW5lVGFnLFxuICBza2lwOiBmb3JtYXRTa2lwXG59KTtcblxuZnVuY3Rpb24gZ2V0Um93IChtYXRyaXgsIGopIHtcbiAgaWYgKCFtYXRyaXhbal0pIHsgbWF0cml4W2pdID0gW107IH1cbiAgcmV0dXJuIG1hdHJpeFtqXTtcbn1cblxuZnVuY3Rpb24gZmluZEZpcnN0VmFjYW50SW5kZXggKHJvdywgeCA9IDApIHtcbiAgd2hpbGUgKHJvd1t4XSkgeyB4Kys7IH1cbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIHRyYW5zcG9zZUluUGxhY2UgKG1hdHJpeCwgbWF4U2l6ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFNpemU7IGkrKykge1xuICAgIGNvbnN0IHJvd0kgPSBnZXRSb3cobWF0cml4LCBpKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgY29uc3Qgcm93SiA9IGdldFJvdyhtYXRyaXgsIGopO1xuICAgICAgY29uc3QgdGVtcCA9IHJvd0lbal07XG4gICAgICByb3dJW2pdID0gcm93SltpXTtcbiAgICAgIHJvd0pbaV0gPSB0ZW1wO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwdXRDZWxsSW50b0xheW91dCAoY2VsbCwgbGF5b3V0LCBiYXNlUm93LCBiYXNlQ29sKSB7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgY2VsbC5yb3dzcGFuOyByKyspIHtcbiAgICBjb25zdCBsYXlvdXRSb3cgPSBnZXRSb3cobGF5b3V0LCBiYXNlUm93ICsgcik7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjZWxsLmNvbHNwYW47IGMrKykge1xuICAgICAgbGF5b3V0Um93W2Jhc2VDb2wgKyBjXSA9IGNlbGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9mZnNldCAob2Zmc2V0cywgYmFzZSwgc3BhbiwgdmFsdWUpIHtcbiAgb2Zmc2V0c1tiYXNlICsgc3Bhbl0gPSBNYXRoLm1heChcbiAgICBvZmZzZXRzW2Jhc2UgKyBzcGFuXSB8fCAwLFxuICAgIG9mZnNldHNbYmFzZV0gKyB2YWx1ZVxuICApO1xufVxuXG4vKipcbiAqIFJlbmRlciBhIHRhYmxlIGludG8gYSBzdHJpbmcuXG4gKiBDZWxscyBjYW4gY29udGFpbiBtdWx0aWxpbmUgdGV4dCBhbmQgc3BhbiBhY3Jvc3MgbXVsdGlwbGUgcm93cyBhbmQgY29sdW1ucy5cbiAqXG4gKiBNb2RpZmllcyBjZWxscyB0byBhZGQgbGluZXMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHsgVGFibGVQcmludGVyQ2VsbFtdW10gfSB0YWJsZVJvd3MgVGFibGUgdG8gcmVuZGVyLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gcm93U3BhY2luZyBOdW1iZXIgb2Ygc3BhY2VzIGJldHdlZW4gY29sdW1ucy5cbiAqIEBwYXJhbSB7IG51bWJlciB9IGNvbFNwYWNpbmcgTnVtYmVyIG9mIGVtcHR5IGxpbmVzIGJldHdlZW4gcm93cy5cbiAqIEByZXR1cm5zIHsgc3RyaW5nIH1cbiAqL1xuZnVuY3Rpb24gdGFibGVUb1N0cmluZyAodGFibGVSb3dzLCByb3dTcGFjaW5nLCBjb2xTcGFjaW5nKSB7XG4gIGNvbnN0IGxheW91dCA9IFtdO1xuICBsZXQgY29sTnVtYmVyID0gMDtcbiAgY29uc3Qgcm93TnVtYmVyID0gdGFibGVSb3dzLmxlbmd0aDtcbiAgY29uc3Qgcm93T2Zmc2V0cyA9IFswXTtcbiAgLy8gRmlsbCB0aGUgbGF5b3V0IHRhYmxlIGFuZCByb3cgb2Zmc2V0cyByb3ctYnktcm93LlxuICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd051bWJlcjsgaisrKSB7XG4gICAgY29uc3QgbGF5b3V0Um93ID0gZ2V0Um93KGxheW91dCwgaik7XG4gICAgY29uc3QgY2VsbHMgPSB0YWJsZVJvd3Nbal07XG4gICAgbGV0IHggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNlbGwgPSBjZWxsc1tpXTtcbiAgICAgIHggPSBmaW5kRmlyc3RWYWNhbnRJbmRleChsYXlvdXRSb3csIHgpO1xuICAgICAgcHV0Q2VsbEludG9MYXlvdXQoY2VsbCwgbGF5b3V0LCBqLCB4KTtcbiAgICAgIHggKz0gY2VsbC5jb2xzcGFuO1xuICAgICAgY2VsbC5saW5lcyA9IGNlbGwudGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICBjb25zdCBjZWxsSGVpZ2h0ID0gY2VsbC5saW5lcy5sZW5ndGg7XG4gICAgICB1cGRhdGVPZmZzZXQocm93T2Zmc2V0cywgaiwgY2VsbC5yb3dzcGFuLCBjZWxsSGVpZ2h0ICsgcm93U3BhY2luZyk7XG4gICAgfVxuICAgIGNvbE51bWJlciA9IChsYXlvdXRSb3cubGVuZ3RoID4gY29sTnVtYmVyKSA/IGxheW91dFJvdy5sZW5ndGggOiBjb2xOdW1iZXI7XG4gIH1cblxuICB0cmFuc3Bvc2VJblBsYWNlKGxheW91dCwgKHJvd051bWJlciA+IGNvbE51bWJlcikgPyByb3dOdW1iZXIgOiBjb2xOdW1iZXIpO1xuXG4gIGNvbnN0IG91dHB1dExpbmVzID0gW107XG4gIGNvbnN0IGNvbE9mZnNldHMgPSBbMF07XG4gIC8vIEZpbGwgY29sdW1uIG9mZnNldHMgYW5kIG91dHB1dCBsaW5lcyBjb2x1bW4tYnktY29sdW1uLlxuICBmb3IgKGxldCB4ID0gMDsgeCA8IGNvbE51bWJlcjsgeCsrKSB7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBjZWxsO1xuICAgIHdoaWxlICh5IDwgcm93TnVtYmVyICYmIChjZWxsID0gbGF5b3V0W3hdW3ldKSkge1xuICAgICAgaWYgKCFjZWxsLnJlbmRlcmVkKSB7XG4gICAgICAgIGxldCBjZWxsV2lkdGggPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNlbGwubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBsaW5lID0gY2VsbC5saW5lc1tqXTtcbiAgICAgICAgICBjb25zdCBsaW5lT2Zmc2V0ID0gcm93T2Zmc2V0c1t5XSArIGo7XG4gICAgICAgICAgb3V0cHV0TGluZXNbbGluZU9mZnNldF0gPSAob3V0cHV0TGluZXNbbGluZU9mZnNldF0gfHwgJycpLnBhZEVuZChjb2xPZmZzZXRzW3hdKSArIGxpbmU7XG4gICAgICAgICAgY2VsbFdpZHRoID0gKGxpbmUubGVuZ3RoID4gY2VsbFdpZHRoKSA/IGxpbmUubGVuZ3RoIDogY2VsbFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU9mZnNldChjb2xPZmZzZXRzLCB4LCBjZWxsLmNvbHNwYW4sIGNlbGxXaWR0aCArIGNvbFNwYWNpbmcpO1xuICAgICAgICBjZWxsLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHkgKz0gY2VsbC5yb3dzcGFuO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXRMaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgbGluZS1icmVhay5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0TGluZUJyZWFrIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIuYWRkTGluZUJyZWFrKCk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIGB3YnJgIHRhZyAod29yZCBicmVhayBvcHBvcnR1bml0eSkuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFdiciAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLmFkZFdvcmRCcmVha09wcG9ydHVuaXR5KCk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIGhvcml6b250YWwgbGluZS5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0SG9yaXpvbnRhbExpbmUgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuQmxvY2soeyBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xuICBidWlsZGVyLmFkZElubGluZSgnLScucmVwZWF0KGZvcm1hdE9wdGlvbnMubGVuZ3RoIHx8IGJ1aWxkZXIub3B0aW9ucy53b3Jkd3JhcCB8fCA0MCkpO1xuICBidWlsZGVyLmNsb3NlQmxvY2soeyB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIHBhcmFncmFwaC5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0UGFyYWdyYXBoIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlbkJsb2NrKHsgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbiAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgYnVpbGRlci5jbG9zZUJsb2NrKHsgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBwcmVmb3JtYXR0ZWQgY29udGVudC5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0UHJlIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlbkJsb2NrKHtcbiAgICBpc1ByZTogdHJ1ZSxcbiAgICBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB8fCAyXG4gIH0pO1xuICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICBidWlsZGVyLmNsb3NlQmxvY2soeyB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIGhlYWRpbmcuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEhlYWRpbmcgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuQmxvY2soeyBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xuICBpZiAoZm9ybWF0T3B0aW9ucy51cHBlcmNhc2UgIT09IGZhbHNlKSB7XG4gICAgYnVpbGRlci5wdXNoV29yZFRyYW5zZm9ybShzdHIgPT4gc3RyLnRvVXBwZXJDYXNlKCkpO1xuICAgIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gICAgYnVpbGRlci5wb3BXb3JkVHJhbnNmb3JtKCk7XG4gIH0gZWxzZSB7XG4gICAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgfVxuICBidWlsZGVyLmNsb3NlQmxvY2soeyB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIGJsb2NrcXVvdGUuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEJsb2NrcXVvdGUgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuQmxvY2soe1xuICAgIGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIHx8IDIsXG4gICAgcmVzZXJ2ZWRMaW5lTGVuZ3RoOiAyXG4gIH0pO1xuICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICBidWlsZGVyLmNsb3NlQmxvY2soe1xuICAgIHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfHwgMixcbiAgICBibG9ja1RyYW5zZm9ybTogc3RyID0+ICgoZm9ybWF0T3B0aW9ucy50cmltRW1wdHlMaW5lcyAhPT0gZmFsc2UpID8gdHJpbUNoYXJhY3RlcihzdHIsICdcXG4nKSA6IHN0cilcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5tYXAobGluZSA9PiAnPiAnICsgbGluZSlcbiAgICAgIC5qb2luKCdcXG4nKVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2l0aEJyYWNrZXRzIChzdHIsIGJyYWNrZXRzKSB7XG4gIGlmICghYnJhY2tldHMpIHsgcmV0dXJuIHN0cjsgfVxuXG4gIGNvbnN0IGxiciA9ICh0eXBlb2YgYnJhY2tldHNbMF0gPT09ICdzdHJpbmcnKVxuICAgID8gYnJhY2tldHNbMF1cbiAgICA6ICdbJztcbiAgY29uc3QgcmJyID0gKHR5cGVvZiBicmFja2V0c1sxXSA9PT0gJ3N0cmluZycpXG4gICAgPyBicmFja2V0c1sxXVxuICAgIDogJ10nO1xuICByZXR1cm4gbGJyICsgc3RyICsgcmJyO1xufVxuXG5mdW5jdGlvbiBwYXRoUmV3cml0ZSAocGF0aCwgcmV3cml0ZXIsIGJhc2VVcmwsIG1ldGFkYXRhLCBlbGVtKSB7XG4gIGNvbnN0IG1vZGlmaWVkUGF0aCA9ICh0eXBlb2YgcmV3cml0ZXIgPT09ICdmdW5jdGlvbicpXG4gICAgPyByZXdyaXRlcihwYXRoLCBtZXRhZGF0YSwgZWxlbSlcbiAgICA6IHBhdGg7XG4gIHJldHVybiAobW9kaWZpZWRQYXRoWzBdID09PSAnLycgJiYgYmFzZVVybClcbiAgICA/IHRyaW1DaGFyYWN0ZXJFbmQoYmFzZVVybCwgJy8nKSArIG1vZGlmaWVkUGF0aFxuICAgIDogbW9kaWZpZWRQYXRoO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYW4gaW1hZ2UuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEltYWdlIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGNvbnN0IGF0dHJpYnMgPSBlbGVtLmF0dHJpYnMgfHwge307XG4gIGNvbnN0IGFsdCA9IChhdHRyaWJzLmFsdClcbiAgICA/IGF0dHJpYnMuYWx0XG4gICAgOiAnJztcbiAgY29uc3Qgc3JjID0gKCFhdHRyaWJzLnNyYylcbiAgICA/ICcnXG4gICAgOiBwYXRoUmV3cml0ZShhdHRyaWJzLnNyYywgZm9ybWF0T3B0aW9ucy5wYXRoUmV3cml0ZSwgZm9ybWF0T3B0aW9ucy5iYXNlVXJsLCBidWlsZGVyLm1ldGFkYXRhLCBlbGVtKTtcbiAgY29uc3QgdGV4dCA9ICghc3JjKVxuICAgID8gYWx0XG4gICAgOiAoIWFsdClcbiAgICAgID8gd2l0aEJyYWNrZXRzKHNyYywgZm9ybWF0T3B0aW9ucy5saW5rQnJhY2tldHMpXG4gICAgICA6IGFsdCArICcgJyArIHdpdGhCcmFja2V0cyhzcmMsIGZvcm1hdE9wdGlvbnMubGlua0JyYWNrZXRzKTtcblxuICBidWlsZGVyLmFkZElubGluZSh0ZXh0LCB7IG5vV29yZFRyYW5zZm9ybTogdHJ1ZSB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGFuIGFuY2hvci5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0QW5jaG9yIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGZ1bmN0aW9uIGdldEhyZWYgKCkge1xuICAgIGlmIChmb3JtYXRPcHRpb25zLmlnbm9yZUhyZWYpIHsgcmV0dXJuICcnOyB9XG4gICAgaWYgKCFlbGVtLmF0dHJpYnMgfHwgIWVsZW0uYXR0cmlicy5ocmVmKSB7IHJldHVybiAnJzsgfVxuICAgIGxldCBocmVmID0gZWxlbS5hdHRyaWJzLmhyZWYucmVwbGFjZSgvXm1haWx0bzovLCAnJyk7XG4gICAgaWYgKGZvcm1hdE9wdGlvbnMubm9BbmNob3JVcmwgJiYgaHJlZlswXSA9PT0gJyMnKSB7IHJldHVybiAnJzsgfVxuICAgIGhyZWYgPSBwYXRoUmV3cml0ZShocmVmLCBmb3JtYXRPcHRpb25zLnBhdGhSZXdyaXRlLCBmb3JtYXRPcHRpb25zLmJhc2VVcmwsIGJ1aWxkZXIubWV0YWRhdGEsIGVsZW0pO1xuICAgIHJldHVybiBocmVmO1xuICB9XG4gIGNvbnN0IGhyZWYgPSBnZXRIcmVmKCk7XG4gIGlmICghaHJlZikge1xuICAgIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHRleHQgPSAnJztcbiAgICBidWlsZGVyLnB1c2hXb3JkVHJhbnNmb3JtKFxuICAgICAgc3RyID0+IHtcbiAgICAgICAgaWYgKHN0cikgeyB0ZXh0ICs9IHN0cjsgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICk7XG4gICAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgICBidWlsZGVyLnBvcFdvcmRUcmFuc2Zvcm0oKTtcblxuICAgIGNvbnN0IGhpZGVTYW1lTGluayA9IGZvcm1hdE9wdGlvbnMuaGlkZUxpbmtIcmVmSWZTYW1lQXNUZXh0ICYmIGhyZWYgPT09IHRleHQ7XG4gICAgaWYgKCFoaWRlU2FtZUxpbmspIHtcbiAgICAgIGJ1aWxkZXIuYWRkSW5saW5lKFxuICAgICAgICAoIXRleHQpXG4gICAgICAgICAgPyBocmVmXG4gICAgICAgICAgOiAnICcgKyB3aXRoQnJhY2tldHMoaHJlZiwgZm9ybWF0T3B0aW9ucy5saW5rQnJhY2tldHMpLFxuICAgICAgICB7IG5vV29yZFRyYW5zZm9ybTogdHJ1ZSB9XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7IERvbU5vZGUgfSAgICAgICAgICAgZWxlbSAgICAgICAgICAgICAgIExpc3QgaXRlbXMgd2l0aCB0aGVpciBwcmVmaXhlcy5cbiAqIEBwYXJhbSB7IFJlY3Vyc2l2ZUNhbGxiYWNrIH0gd2FsayAgICAgICAgICAgICAgIFJlY3Vyc2l2ZSBjYWxsYmFjayB0byBwcm9jZXNzIGNoaWxkIG5vZGVzLlxuICogQHBhcmFtIHsgQmxvY2tUZXh0QnVpbGRlciB9ICBidWlsZGVyICAgICAgICAgICAgUGFzc2VkIGFyb3VuZCB0byBhY2N1bXVsYXRlIG91dHB1dCB0ZXh0LlxuICogQHBhcmFtIHsgRm9ybWF0T3B0aW9ucyB9ICAgICBmb3JtYXRPcHRpb25zICAgICAgT3B0aW9ucyBzcGVjaWZpYyB0byBhIGZvcm1hdHRlci5cbiAqIEBwYXJhbSB7ICgpID0+IHN0cmluZyB9ICAgICAgbmV4dFByZWZpeENhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpbmNyZWFzaW5nIGluZGV4IGVhY2ggdGltZSBpdCBpcyBjYWxsZWQuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdExpc3QgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMsIG5leHRQcmVmaXhDYWxsYmFjaykge1xuICBjb25zdCBpc05lc3RlZExpc3QgPSBnZXQoZWxlbSwgWydwYXJlbnQnLCAnbmFtZSddKSA9PT0gJ2xpJztcblxuICAvLyBXaXRoIFJvbWFuIG51bWJlcnMsIGluZGV4IGxlbmd0aCBpcyBub3QgYXMgc3RyYWlnaHRmb3J3YXJkIGFzIHdpdGggQXJhYmljIG51bWJlcnMgb3IgbGV0dGVycyxcbiAgLy8gc28gdGhlIGR1bWIgbGVuZ3RoIGNvbXBhcmlzb24gaXMgdGhlIG1vc3Qgcm9idXN0IHdheSB0byBnZXQgdGhlIGNvcnJlY3QgdmFsdWUuXG4gIGxldCBtYXhQcmVmaXhMZW5ndGggPSAwO1xuICBjb25zdCBsaXN0SXRlbXMgPSAoZWxlbS5jaGlsZHJlbiB8fCBbXSlcbiAgICAvLyBpdCBtaWdodCBiZSBtb3JlIGFjY3VyYXRlIHRvIGNoZWNrIG9ubHkgZm9yIGh0bWwgc3BhY2VzIGhlcmUsIGJ1dCBubyBzaWduaWZpY2FudCBiZW5lZml0XG4gICAgLmZpbHRlcihjaGlsZCA9PiBjaGlsZC50eXBlICE9PSAndGV4dCcgfHwgIS9eXFxzKiQvLnRlc3QoY2hpbGQuZGF0YSkpXG4gICAgLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5uYW1lICE9PSAnbGknKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IGNoaWxkLCBwcmVmaXg6ICcnIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcmVmaXggPSAoaXNOZXN0ZWRMaXN0KVxuICAgICAgICA/IG5leHRQcmVmaXhDYWxsYmFjaygpLnRyaW1TdGFydCgpXG4gICAgICAgIDogbmV4dFByZWZpeENhbGxiYWNrKCk7XG4gICAgICBpZiAocHJlZml4Lmxlbmd0aCA+IG1heFByZWZpeExlbmd0aCkgeyBtYXhQcmVmaXhMZW5ndGggPSBwcmVmaXgubGVuZ3RoOyB9XG4gICAgICByZXR1cm4geyBub2RlOiBjaGlsZCwgcHJlZml4OiBwcmVmaXggfTtcbiAgICB9KTtcbiAgaWYgKCFsaXN0SXRlbXMubGVuZ3RoKSB7IHJldHVybjsgfVxuXG4gIGJ1aWxkZXIub3Blbkxpc3Qoe1xuICAgIGludGVyUm93TGluZUJyZWFrczogMSxcbiAgICBsZWFkaW5nTGluZUJyZWFrczogaXNOZXN0ZWRMaXN0ID8gMSA6IChmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIHx8IDIpLFxuICAgIG1heFByZWZpeExlbmd0aDogbWF4UHJlZml4TGVuZ3RoLFxuICAgIHByZWZpeEFsaWduOiAnbGVmdCdcbiAgfSk7XG5cbiAgZm9yIChjb25zdCB7IG5vZGUsIHByZWZpeCB9IG9mIGxpc3RJdGVtcykge1xuICAgIGJ1aWxkZXIub3Blbkxpc3RJdGVtKHsgcHJlZml4OiBwcmVmaXggfSk7XG4gICAgd2Fsayhbbm9kZV0sIGJ1aWxkZXIpO1xuICAgIGJ1aWxkZXIuY2xvc2VMaXN0SXRlbSgpO1xuICB9XG5cbiAgYnVpbGRlci5jbG9zZUxpc3QoeyB0cmFpbGluZ0xpbmVCcmVha3M6IGlzTmVzdGVkTGlzdCA/IDEgOiAoZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfHwgMikgfSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhbiB1bm9yZGVyZWQgbGlzdC5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0VW5vcmRlcmVkTGlzdCAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBjb25zdCBwcmVmaXggPSBmb3JtYXRPcHRpb25zLml0ZW1QcmVmaXggfHwgJyAqICc7XG4gIHJldHVybiBmb3JtYXRMaXN0KGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMsICgpID0+IHByZWZpeCk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhbiBvcmRlcmVkIGxpc3QuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdE9yZGVyZWRMaXN0IChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGxldCBuZXh0SW5kZXggPSBOdW1iZXIoZWxlbS5hdHRyaWJzLnN0YXJ0IHx8ICcxJyk7XG4gIGNvbnN0IGluZGV4RnVuY3Rpb24gPSBnZXRPcmRlcmVkTGlzdEluZGV4RnVuY3Rpb24oZWxlbS5hdHRyaWJzLnR5cGUpO1xuICBjb25zdCBuZXh0UHJlZml4Q2FsbGJhY2sgPSAoKSA9PiAnICcgKyBpbmRleEZ1bmN0aW9uKG5leHRJbmRleCsrKSArICcuICc7XG4gIHJldHVybiBmb3JtYXRMaXN0KGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMsIG5leHRQcmVmaXhDYWxsYmFjayk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSBpbmRleCBtYXJrZXJzIG9mIGEgc3BlY2lmaWVkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9IFtvbFR5cGU9JzEnXSBNYXJrZXIgdHlwZS5cbiAqIEByZXR1cm5zIHsgKGk6IG51bWJlcikgPT4gc3RyaW5nIH1cbiAqL1xuZnVuY3Rpb24gZ2V0T3JkZXJlZExpc3RJbmRleEZ1bmN0aW9uIChvbFR5cGUgPSAnMScpIHtcbiAgc3dpdGNoIChvbFR5cGUpIHtcbiAgICBjYXNlICdhJzogcmV0dXJuIChpKSA9PiBudW1iZXJUb0xldHRlclNlcXVlbmNlKGksICdhJyk7XG4gICAgY2FzZSAnQSc6IHJldHVybiAoaSkgPT4gbnVtYmVyVG9MZXR0ZXJTZXF1ZW5jZShpLCAnQScpO1xuICAgIGNhc2UgJ2knOiByZXR1cm4gKGkpID0+IG51bWJlclRvUm9tYW4oaSkudG9Mb3dlckNhc2UoKTtcbiAgICBjYXNlICdJJzogcmV0dXJuIChpKSA9PiBudW1iZXJUb1JvbWFuKGkpO1xuICAgIGNhc2UgJzEnOlxuICAgIGRlZmF1bHQ6IHJldHVybiAoaSkgPT4gKGkpLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgY2xhc3MgYW5kIElEIHNlbGVjdG9ycyAocHJlZml4ZWQgd2l0aCAnLicgYW5kICcjJyksXG4gKiByZXR1cm4gdGhlbSBhcyBzZXBhcmF0ZSBsaXN0cyBvZiBuYW1lcyB3aXRob3V0IHByZWZpeGVzLlxuICpcbiAqIEBwYXJhbSB7IHN0cmluZ1tdIH0gc2VsZWN0b3JzIENsYXNzIGFuZCBJRCBzZWxlY3RvcnMgKGBbXCIuY2xhc3NcIiwgXCIjaWRcIl1gIGV0YykuXG4gKiBAcmV0dXJucyB7IHsgY2xhc3Nlczogc3RyaW5nW10sIGlkczogc3RyaW5nW10gfSB9XG4gKi9cbmZ1bmN0aW9uIHNwbGl0Q2xhc3Nlc0FuZElkcyAoc2VsZWN0b3JzKSB7XG4gIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgY29uc3QgaWRzID0gW107XG4gIGZvciAoY29uc3Qgc2VsZWN0b3Igb2Ygc2VsZWN0b3JzKSB7XG4gICAgaWYgKHNlbGVjdG9yLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgY2xhc3Nlcy5wdXNoKHNlbGVjdG9yLnN1YnN0cmluZygxKSk7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvci5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgIGlkcy5wdXNoKHNlbGVjdG9yLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGNsYXNzZXM6IGNsYXNzZXMsIGlkczogaWRzIH07XG59XG5cbmZ1bmN0aW9uIGlzRGF0YVRhYmxlIChhdHRyLCB0YWJsZXMpIHtcbiAgaWYgKHRhYmxlcyA9PT0gdHJ1ZSkgeyByZXR1cm4gdHJ1ZTsgfVxuICBpZiAoIWF0dHIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY29uc3QgeyBjbGFzc2VzLCBpZHMgfSA9IHNwbGl0Q2xhc3Nlc0FuZElkcyh0YWJsZXMpO1xuICBjb25zdCBhdHRyQ2xhc3NlcyA9IChhdHRyWydjbGFzcyddIHx8ICcnKS5zcGxpdCgnICcpO1xuICBjb25zdCBhdHRySWRzID0gKGF0dHJbJ2lkJ10gfHwgJycpLnNwbGl0KCcgJyk7XG5cbiAgcmV0dXJuIGF0dHJDbGFzc2VzLnNvbWUoeCA9PiBjbGFzc2VzLmluY2x1ZGVzKHgpKSB8fCBhdHRySWRzLnNvbWUoeCA9PiBpZHMuaW5jbHVkZXMoeCkpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSB0YWJsZSAoZWl0aGVyIGFzIGEgY29udGFpbmVyIG9yIGFzIGEgZGF0YSB0YWJsZSwgZGVwZW5kaW5nIG9uIG9wdGlvbnMpLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRUYWJsZSAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICByZXR1cm4gaXNEYXRhVGFibGUoZWxlbS5hdHRyaWJzLCBidWlsZGVyLm9wdGlvbnMudGFibGVzKVxuICAgID8gZm9ybWF0RGF0YVRhYmxlKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpXG4gICAgOiBmb3JtYXRCbG9jayhlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0QmxvY2sgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuQmxvY2soeyBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB9KTtcbiAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgYnVpbGRlci5jbG9zZUJsb2NrKHsgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgZGF0YSB0YWJsZS5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0RGF0YVRhYmxlIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlblRhYmxlKCk7XG4gIGVsZW0uY2hpbGRyZW4uZm9yRWFjaCh3YWxrVGFibGUpO1xuICBidWlsZGVyLmNsb3NlVGFibGUoe1xuICAgIHRhYmxlVG9TdHJpbmc6IChyb3dzKSA9PiB0YWJsZVRvU3RyaW5nKHJvd3MsIGZvcm1hdE9wdGlvbnMucm93U3BhY2luZyA/PyAwLCBmb3JtYXRPcHRpb25zLmNvbFNwYWNpbmcgPz8gMyksXG4gICAgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MsXG4gICAgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrc1xuICB9KTtcblxuICBmdW5jdGlvbiBmb3JtYXRDZWxsIChjZWxsTm9kZSkge1xuICAgIGNvbnN0IGNvbHNwYW4gPSArZ2V0KGNlbGxOb2RlLCBbJ2F0dHJpYnMnLCAnY29sc3BhbiddKSB8fCAxO1xuICAgIGNvbnN0IHJvd3NwYW4gPSArZ2V0KGNlbGxOb2RlLCBbJ2F0dHJpYnMnLCAncm93c3BhbiddKSB8fCAxO1xuICAgIGJ1aWxkZXIub3BlblRhYmxlQ2VsbCh7IG1heENvbHVtbldpZHRoOiBmb3JtYXRPcHRpb25zLm1heENvbHVtbldpZHRoIH0pO1xuICAgIHdhbGsoY2VsbE5vZGUuY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICAgIGJ1aWxkZXIuY2xvc2VUYWJsZUNlbGwoeyBjb2xzcGFuOiBjb2xzcGFuLCByb3dzcGFuOiByb3dzcGFuIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2Fsa1RhYmxlIChlbGVtKSB7XG4gICAgaWYgKGVsZW0udHlwZSAhPT0gJ3RhZycpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBmb3JtYXRIZWFkZXJDZWxsID0gKGZvcm1hdE9wdGlvbnMudXBwZXJjYXNlSGVhZGVyQ2VsbHMgIT09IGZhbHNlKVxuICAgICAgPyAoY2VsbE5vZGUpID0+IHtcbiAgICAgICAgYnVpbGRlci5wdXNoV29yZFRyYW5zZm9ybShzdHIgPT4gc3RyLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICBmb3JtYXRDZWxsKGNlbGxOb2RlKTtcbiAgICAgICAgYnVpbGRlci5wb3BXb3JkVHJhbnNmb3JtKCk7XG4gICAgICB9XG4gICAgICA6IGZvcm1hdENlbGw7XG5cbiAgICBzd2l0Y2ggKGVsZW0ubmFtZSkge1xuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgZWxlbS5jaGlsZHJlbi5mb3JFYWNoKHdhbGtUYWJsZSk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAndHInOiB7XG4gICAgICAgIGJ1aWxkZXIub3BlblRhYmxlUm93KCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRPZlRyIG9mIGVsZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoY2hpbGRPZlRyLnR5cGUgIT09ICd0YWcnKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgc3dpdGNoIChjaGlsZE9mVHIubmFtZSkge1xuICAgICAgICAgICAgY2FzZSAndGgnOiB7XG4gICAgICAgICAgICAgIGZvcm1hdEhlYWRlckNlbGwoY2hpbGRPZlRyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICd0ZCc6IHtcbiAgICAgICAgICAgICAgZm9ybWF0Q2VsbChjaGlsZE9mVHIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLmNsb3NlVGFibGVSb3coKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG4gIH1cbn1cblxudmFyIHRleHRGb3JtYXR0ZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFuY2hvcjogZm9ybWF0QW5jaG9yLFxuICBibG9ja3F1b3RlOiBmb3JtYXRCbG9ja3F1b3RlLFxuICBkYXRhVGFibGU6IGZvcm1hdERhdGFUYWJsZSxcbiAgaGVhZGluZzogZm9ybWF0SGVhZGluZyxcbiAgaG9yaXpvbnRhbExpbmU6IGZvcm1hdEhvcml6b250YWxMaW5lLFxuICBpbWFnZTogZm9ybWF0SW1hZ2UsXG4gIGxpbmVCcmVhazogZm9ybWF0TGluZUJyZWFrLFxuICBvcmRlcmVkTGlzdDogZm9ybWF0T3JkZXJlZExpc3QsXG4gIHBhcmFncmFwaDogZm9ybWF0UGFyYWdyYXBoLFxuICBwcmU6IGZvcm1hdFByZSxcbiAgdGFibGU6IGZvcm1hdFRhYmxlLFxuICB1bm9yZGVyZWRMaXN0OiBmb3JtYXRVbm9yZGVyZWRMaXN0LFxuICB3YnI6IGZvcm1hdFdiclxufSk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIEBjb25zdGFudFxuICogQHR5cGUgeyBPcHRpb25zIH1cbiAqIEBkZWZhdWx0XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIGJhc2VFbGVtZW50czoge1xuICAgIHNlbGVjdG9yczogWyAnYm9keScgXSxcbiAgICBvcmRlckJ5OiAnc2VsZWN0b3JzJywgLy8gJ3NlbGVjdG9ycycgfCAnb2NjdXJyZW5jZSdcbiAgICByZXR1cm5Eb21CeURlZmF1bHQ6IHRydWVcbiAgfSxcbiAgZGVjb2RlRW50aXRpZXM6IHRydWUsXG4gIGVuY29kZUNoYXJhY3RlcnM6IHt9LFxuICBmb3JtYXR0ZXJzOiB7fSxcbiAgbGltaXRzOiB7XG4gICAgZWxsaXBzaXM6ICcuLi4nLFxuICAgIG1heEJhc2VFbGVtZW50czogdW5kZWZpbmVkLFxuICAgIG1heENoaWxkTm9kZXM6IHVuZGVmaW5lZCxcbiAgICBtYXhEZXB0aDogdW5kZWZpbmVkLFxuICAgIG1heElucHV0TGVuZ3RoOiAoMSA8PCAyNCkgLy8gMTZfNzc3XzIxNlxuICB9LFxuICBsb25nV29yZFNwbGl0OiB7XG4gICAgZm9yY2VXcmFwT25MaW1pdDogZmFsc2UsXG4gICAgd3JhcENoYXJhY3RlcnM6IFtdXG4gIH0sXG4gIHByZXNlcnZlTmV3bGluZXM6IGZhbHNlLFxuICBzZWxlY3RvcnM6IFtcbiAgICB7IHNlbGVjdG9yOiAnKicsIGZvcm1hdDogJ2lubGluZScgfSxcbiAgICB7XG4gICAgICBzZWxlY3RvcjogJ2EnLFxuICAgICAgZm9ybWF0OiAnYW5jaG9yJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYmFzZVVybDogbnVsbCxcbiAgICAgICAgaGlkZUxpbmtIcmVmSWZTYW1lQXNUZXh0OiBmYWxzZSxcbiAgICAgICAgaWdub3JlSHJlZjogZmFsc2UsXG4gICAgICAgIGxpbmtCcmFja2V0czogWydbJywgJ10nXSxcbiAgICAgICAgbm9BbmNob3JVcmw6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHsgc2VsZWN0b3I6ICdhcnRpY2xlJywgZm9ybWF0OiAnYmxvY2snLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAxLCB0cmFpbGluZ0xpbmVCcmVha3M6IDEgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdhc2lkZScsIGZvcm1hdDogJ2Jsb2NrJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMSwgdHJhaWxpbmdMaW5lQnJlYWtzOiAxIH0gfSxcbiAgICB7XG4gICAgICBzZWxlY3RvcjogJ2Jsb2NrcXVvdGUnLFxuICAgICAgZm9ybWF0OiAnYmxvY2txdW90ZScsXG4gICAgICBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAyLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIsIHRyaW1FbXB0eUxpbmVzOiB0cnVlIH1cbiAgICB9LFxuICAgIHsgc2VsZWN0b3I6ICdicicsIGZvcm1hdDogJ2xpbmVCcmVhaycgfSxcbiAgICB7IHNlbGVjdG9yOiAnZGl2JywgZm9ybWF0OiAnYmxvY2snLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAxLCB0cmFpbGluZ0xpbmVCcmVha3M6IDEgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdmb290ZXInLCBmb3JtYXQ6ICdibG9jaycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDEsIHRyYWlsaW5nTGluZUJyZWFrczogMSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ2Zvcm0nLCBmb3JtYXQ6ICdibG9jaycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDEsIHRyYWlsaW5nTGluZUJyZWFrczogMSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ2gxJywgZm9ybWF0OiAnaGVhZGluZycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDMsIHRyYWlsaW5nTGluZUJyZWFrczogMiwgdXBwZXJjYXNlOiB0cnVlIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnaDInLCBmb3JtYXQ6ICdoZWFkaW5nJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMywgdHJhaWxpbmdMaW5lQnJlYWtzOiAyLCB1cHBlcmNhc2U6IHRydWUgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdoMycsIGZvcm1hdDogJ2hlYWRpbmcnLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAzLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIsIHVwcGVyY2FzZTogdHJ1ZSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ2g0JywgZm9ybWF0OiAnaGVhZGluZycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDIsIHRyYWlsaW5nTGluZUJyZWFrczogMiwgdXBwZXJjYXNlOiB0cnVlIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnaDUnLCBmb3JtYXQ6ICdoZWFkaW5nJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMiwgdHJhaWxpbmdMaW5lQnJlYWtzOiAyLCB1cHBlcmNhc2U6IHRydWUgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdoNicsIGZvcm1hdDogJ2hlYWRpbmcnLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAyLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIsIHVwcGVyY2FzZTogdHJ1ZSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ2hlYWRlcicsIGZvcm1hdDogJ2Jsb2NrJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMSwgdHJhaWxpbmdMaW5lQnJlYWtzOiAxIH0gfSxcbiAgICB7XG4gICAgICBzZWxlY3RvcjogJ2hyJyxcbiAgICAgIGZvcm1hdDogJ2hvcml6b250YWxMaW5lJyxcbiAgICAgIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDIsIGxlbmd0aDogdW5kZWZpbmVkLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIgfVxuICAgIH0sXG4gICAge1xuICAgICAgc2VsZWN0b3I6ICdpbWcnLFxuICAgICAgZm9ybWF0OiAnaW1hZ2UnLFxuICAgICAgb3B0aW9uczogeyBiYXNlVXJsOiBudWxsLCBsaW5rQnJhY2tldHM6IFsnWycsICddJ10gfVxuICAgIH0sXG4gICAgeyBzZWxlY3RvcjogJ21haW4nLCBmb3JtYXQ6ICdibG9jaycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDEsIHRyYWlsaW5nTGluZUJyZWFrczogMSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ25hdicsIGZvcm1hdDogJ2Jsb2NrJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMSwgdHJhaWxpbmdMaW5lQnJlYWtzOiAxIH0gfSxcbiAgICB7XG4gICAgICBzZWxlY3RvcjogJ29sJyxcbiAgICAgIGZvcm1hdDogJ29yZGVyZWRMaXN0JyxcbiAgICAgIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDIsIHRyYWlsaW5nTGluZUJyZWFrczogMiB9XG4gICAgfSxcbiAgICB7IHNlbGVjdG9yOiAncCcsIGZvcm1hdDogJ3BhcmFncmFwaCcsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDIsIHRyYWlsaW5nTGluZUJyZWFrczogMiB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ3ByZScsIGZvcm1hdDogJ3ByZScsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDIsIHRyYWlsaW5nTGluZUJyZWFrczogMiB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ3NlY3Rpb24nLCBmb3JtYXQ6ICdibG9jaycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDEsIHRyYWlsaW5nTGluZUJyZWFrczogMSB9IH0sXG4gICAge1xuICAgICAgc2VsZWN0b3I6ICd0YWJsZScsXG4gICAgICBmb3JtYXQ6ICd0YWJsZScsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGNvbFNwYWNpbmc6IDMsXG4gICAgICAgIGxlYWRpbmdMaW5lQnJlYWtzOiAyLFxuICAgICAgICBtYXhDb2x1bW5XaWR0aDogNjAsXG4gICAgICAgIHJvd1NwYWNpbmc6IDAsXG4gICAgICAgIHRyYWlsaW5nTGluZUJyZWFrczogMixcbiAgICAgICAgdXBwZXJjYXNlSGVhZGVyQ2VsbHM6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIHNlbGVjdG9yOiAndWwnLFxuICAgICAgZm9ybWF0OiAndW5vcmRlcmVkTGlzdCcsXG4gICAgICBvcHRpb25zOiB7IGl0ZW1QcmVmaXg6ICcgKiAnLCBsZWFkaW5nTGluZUJyZWFrczogMiwgdHJhaWxpbmdMaW5lQnJlYWtzOiAyIH1cbiAgICB9LFxuICAgIHsgc2VsZWN0b3I6ICd3YnInLCBmb3JtYXQ6ICd3YnInIH0sXG4gIF0sXG4gIHRhYmxlczogW10sIC8vIGRlcHJlY2F0ZWRcbiAgd2hpdGVzcGFjZUNoYXJhY3RlcnM6ICcgXFx0XFxyXFxuXFxmXFx1MjAwYicsXG4gIHdvcmR3cmFwOiA4MFxufTtcblxuY29uc3QgY29uY2F0TWVyZ2UgPSAoYWNjLCBzcmMsIG9wdGlvbnMpID0+IFsuLi5hY2MsIC4uLnNyY107XG5jb25zdCBvdmVyd3JpdGVNZXJnZSA9IChhY2MsIHNyYywgb3B0aW9ucykgPT4gWy4uLnNyY107XG5jb25zdCBzZWxlY3RvcnNNZXJnZSA9IChhY2MsIHNyYywgb3B0aW9ucykgPT4gKFxuICAoYWNjLnNvbWUocyA9PiB0eXBlb2YgcyA9PT0gJ29iamVjdCcpKVxuICAgID8gY29uY2F0TWVyZ2UoYWNjLCBzcmMpIC8vIHNlbGVjdG9yc1xuICAgIDogb3ZlcndyaXRlTWVyZ2UoYWNjLCBzcmMpIC8vIGJhc2VFbGVtZW50cy5zZWxlY3RvcnNcbik7XG5cbi8qKlxuICogUHJlcHJvY2VzcyBvcHRpb25zLCBjb21waWxlIHNlbGVjdG9ycyBpbnRvIGEgZGVjaXNpb24gdHJlZSxcbiAqIHJldHVybiBhIGZ1bmN0aW9uIGludGVuZGVkIGZvciBiYXRjaCBwcm9jZXNzaW5nLlxuICpcbiAqIEBwYXJhbSAgIHsgT3B0aW9ucyB9IFtvcHRpb25zID0ge31dICAgSHRtbFRvVGV4dCBvcHRpb25zLlxuICogQHJldHVybnMgeyAoaHRtbDogc3RyaW5nLCBtZXRhZGF0YT86IGFueSkgPT4gc3RyaW5nIH0gUHJlLWNvbmZpZ3VyZWQgY29udmVydGVyIGZ1bmN0aW9uLlxuICogQHN0YXRpY1xuICovXG5mdW5jdGlvbiBjb21waWxlIChvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IG1lcmdlX19kZWZhdWx0W1wiZGVmYXVsdFwiXShcbiAgICBERUZBVUxUX09QVElPTlMsXG4gICAgb3B0aW9ucyxcbiAgICB7XG4gICAgICBhcnJheU1lcmdlOiBvdmVyd3JpdGVNZXJnZSxcbiAgICAgIGN1c3RvbU1lcmdlOiAoa2V5KSA9PiAoKGtleSA9PT0gJ3NlbGVjdG9ycycpID8gc2VsZWN0b3JzTWVyZ2UgOiB1bmRlZmluZWQpXG4gICAgfVxuICApO1xuICBvcHRpb25zLmZvcm1hdHRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBnZW5lcmljRm9ybWF0dGVycywgdGV4dEZvcm1hdHRlcnMsIG9wdGlvbnMuZm9ybWF0dGVycyk7XG4gIG9wdGlvbnMuc2VsZWN0b3JzID0gbWVyZ2VEdXBsaWNhdGVzUHJlZmVyTGFzdChvcHRpb25zLnNlbGVjdG9ycywgKHMgPT4gcy5zZWxlY3RvcikpO1xuXG4gIGhhbmRsZURlcHJlY2F0ZWRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiBjb21waWxlJDEob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ29udmVydCBnaXZlbiBIVE1MIGNvbnRlbnQgdG8gcGxhaW4gdGV4dCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICAgeyBzdHJpbmcgfSAgaHRtbCAgICAgICAgICAgSFRNTCBjb250ZW50IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gICB7IE9wdGlvbnMgfSBbb3B0aW9ucyA9IHt9XSBIdG1sVG9UZXh0IG9wdGlvbnMuXG4gKiBAcGFyYW0gICB7IGFueSB9ICAgICBbbWV0YWRhdGFdICAgICBPcHRpb25hbCBtZXRhZGF0YSBmb3IgSFRNTCBkb2N1bWVudCwgZm9yIHVzZSBpbiBmb3JtYXR0ZXJzLlxuICogQHJldHVybnMgeyBzdHJpbmcgfSAgICAgICAgICAgICAgICAgUGxhaW4gdGV4dCBzdHJpbmcuXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHsgY29udmVydCB9ID0gcmVxdWlyZSgnaHRtbC10by10ZXh0Jyk7XG4gKiBjb25zdCB0ZXh0ID0gY29udmVydCgnPGgxPkhlbGxvIFdvcmxkPC9oMT4nLCB7XG4gKiAgIHdvcmR3cmFwOiAxMzBcbiAqIH0pO1xuICogY29uc29sZS5sb2codGV4dCk7IC8vIEhFTExPIFdPUkxEXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnQgKGh0bWwsIG9wdGlvbnMgPSB7fSwgbWV0YWRhdGEgPSB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIGNvbXBpbGUob3B0aW9ucykoaHRtbCwgbWV0YWRhdGEpO1xufVxuXG4vKipcbiAqIE1hcCBwcmV2aW91c2x5IGV4aXN0aW5nIGFuZCBub3cgZGVwcmVjYXRlZCBvcHRpb25zIHRvIHRoZSBuZXcgb3B0aW9ucyBsYXlvdXQuXG4gKiBUaGlzIGlzIGEgc3ViamVjdCBmb3IgY2xlYW51cCBpbiBtYWpvciByZWxlYXNlcy5cbiAqXG4gKiBAcGFyYW0geyBPcHRpb25zIH0gb3B0aW9ucyBIdG1sVG9UZXh0IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZURlcHJlY2F0ZWRPcHRpb25zIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnRhZ3MpIHtcbiAgICBjb25zdCB0YWdEZWZpbml0aW9ucyA9IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMudGFncykubWFwKFxuICAgICAgKFtzZWxlY3RvciwgZGVmaW5pdGlvbl0pID0+ICh7IC4uLmRlZmluaXRpb24sIHNlbGVjdG9yOiBzZWxlY3RvciB8fCAnKicgfSlcbiAgICApO1xuICAgIG9wdGlvbnMuc2VsZWN0b3JzLnB1c2goLi4udGFnRGVmaW5pdGlvbnMpO1xuICAgIG9wdGlvbnMuc2VsZWN0b3JzID0gbWVyZ2VEdXBsaWNhdGVzUHJlZmVyTGFzdChvcHRpb25zLnNlbGVjdG9ycywgKHMgPT4gcy5zZWxlY3RvcikpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0IChvYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVLZXkgPSBwYXRoLnBvcCgpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHBhdGgpIHtcbiAgICAgIGxldCBuZXN0ZWQgPSBvYmpba2V5XTtcbiAgICAgIGlmICghbmVzdGVkKSB7XG4gICAgICAgIG5lc3RlZCA9IHt9O1xuICAgICAgICBvYmpba2V5XSA9IG5lc3RlZDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG5lc3RlZDtcbiAgICB9XG4gICAgb2JqW3ZhbHVlS2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnNbJ2Jhc2VFbGVtZW50J10pIHtcbiAgICBjb25zdCBiYXNlRWxlbWVudCA9IG9wdGlvbnNbJ2Jhc2VFbGVtZW50J107XG4gICAgc2V0KFxuICAgICAgb3B0aW9ucyxcbiAgICAgIFsnYmFzZUVsZW1lbnRzJywgJ3NlbGVjdG9ycyddLFxuICAgICAgKEFycmF5LmlzQXJyYXkoYmFzZUVsZW1lbnQpID8gYmFzZUVsZW1lbnQgOiBbYmFzZUVsZW1lbnRdKVxuICAgICk7XG4gIH1cbiAgaWYgKG9wdGlvbnNbJ3JldHVybkRvbUJ5RGVmYXVsdCddICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQob3B0aW9ucywgWydiYXNlRWxlbWVudHMnLCAncmV0dXJuRG9tQnlEZWZhdWx0J10sIG9wdGlvbnNbJ3JldHVybkRvbUJ5RGVmYXVsdCddKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgZGVmaW5pdGlvbiBvZiBvcHRpb25zLnNlbGVjdG9ycykge1xuICAgIGlmIChkZWZpbml0aW9uLmZvcm1hdCA9PT0gJ2FuY2hvcicgJiYgZ2V0KGRlZmluaXRpb24sIFsnb3B0aW9ucycsICdub0xpbmtCcmFja2V0cyddKSkge1xuICAgICAgc2V0KGRlZmluaXRpb24sIFsnb3B0aW9ucycsICdsaW5rQnJhY2tldHMnXSwgZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuZXhwb3J0cy5jb252ZXJ0ID0gY29udmVydDtcbmV4cG9ydHMuaHRtbFRvVGV4dCA9IGNvbnZlcnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwbHVnaW5IdG1scGFyc2VyMiIsInJlcXVpcmUiLCJodG1scGFyc2VyMiIsInNlbGRlcmVlIiwibWVyZ2UiLCJkb21TZXJpYWxpemVyIiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsIm1lcmdlX19kZWZhdWx0IiwibGltaXRlZERlcHRoUmVjdXJzaXZlIiwibiIsImYiLCJnIiwidW5kZWZpbmVkIiwiZjEiLCJhcmdzIiwidHJpbUNoYXJhY3RlciIsInN0ciIsImNoYXIiLCJzdGFydCIsImVuZCIsImxlbmd0aCIsInN1YnN0cmluZyIsInRyaW1DaGFyYWN0ZXJFbmQiLCJ1bmljb2RlRXNjYXBlIiwicmVwbGFjZSIsImMiLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJwYWRTdGFydCIsIm1lcmdlRHVwbGljYXRlc1ByZWZlckxhc3QiLCJpdGVtcyIsImdldEtleSIsIm1hcCIsIk1hcCIsImkiLCJpdGVtIiwia2V5Iiwic2V0IiwiaGFzIiwiZ2V0IiwiYXJyYXlNZXJnZSIsIm92ZXJ3cml0ZU1lcmdlJDEiLCJ2YWx1ZXMiLCJyZXZlcnNlIiwiYWNjIiwic3JjIiwib3B0aW9ucyIsIm9iaiIsInBhdGgiLCJudW1iZXJUb0xldHRlclNlcXVlbmNlIiwibnVtIiwiYmFzZUNoYXIiLCJiYXNlIiwiZGlnaXRzIiwicHVzaCIsImJhc2VDb2RlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiam9pbiIsIkkiLCJWIiwibnVtYmVyVG9Sb21hbiIsInYiLCJyZXBlYXQiLCJJbmxpbmVUZXh0QnVpbGRlciIsImNvbnN0cnVjdG9yIiwibWF4TGluZUxlbmd0aCIsImxpbmVzIiwibmV4dExpbmVXb3JkcyIsIndvcmR3cmFwIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwibmV4dExpbmVBdmFpbGFibGVDaGFycyIsIndyYXBDaGFyYWN0ZXJzIiwiZm9yY2VXcmFwT25MaW1pdCIsInN0YXNoZWRTcGFjZSIsIndvcmRCcmVha09wcG9ydHVuaXR5IiwicHVzaFdvcmQiLCJ3b3JkIiwibm9XcmFwIiwic3RhcnROZXdMaW5lIiwiaXNMaW5lU3RhcnQiLCJjb3N0IiwiZmlyc3QiLCJyZXN0Iiwic3BsaXRMb25nV29yZCIsInBhcnQiLCJwb3BXb3JkIiwibGFzdFdvcmQiLCJwb3AiLCJjb25jYXRXb3JkIiwiY29uY2F0IiwiQXJyYXkiLCJmcm9tIiwiaXNFbXB0eSIsImNsZWFyIiwid29yZHMiLCJwYXJ0cyIsImlkeCIsImZpcnN0TGluZSIsInJlbWFpbmluZ0NoYXJzIiwic3BsaXRJbmRleCIsImxhc3RJbmRleE9mIiwiU3RhY2tJdGVtIiwibmV4dCIsImdldFJvb3QiLCJCbG9ja1N0YWNrSXRlbSIsImxlYWRpbmdMaW5lQnJlYWtzIiwiaW5saW5lVGV4dEJ1aWxkZXIiLCJyYXdUZXh0Iiwic3Rhc2hlZExpbmVCcmVha3MiLCJpc1ByZSIsImlzTm9XcmFwIiwiTGlzdFN0YWNrSXRlbSIsImludGVyUm93TGluZUJyZWFrcyIsIm1heFByZWZpeExlbmd0aCIsInByZWZpeEFsaWduIiwiTGlzdEl0ZW1TdGFja0l0ZW0iLCJwcmVmaXgiLCJUYWJsZVN0YWNrSXRlbSIsInJvd3MiLCJUYWJsZVJvd1N0YWNrSXRlbSIsImNlbGxzIiwiVGFibGVDZWxsU3RhY2tJdGVtIiwibWF4Q29sdW1uV2lkdGgiLCJUcmFuc2Zvcm1lclN0YWNrSXRlbSIsInRyYW5zZm9ybSIsImNoYXJhY3RlcnNUb0NvZGVzIiwiV2hpdGVzcGFjZVByb2Nlc3NvciIsIndoaXRlc3BhY2VDaGFycyIsInByZXNlcnZlTmV3bGluZXMiLCJ3aGl0ZXNwYWNlQ2hhcmFjdGVycyIsIndoaXRlc3BhY2VDb2RlcyIsImxlYWRpbmdXaGl0ZXNwYWNlUmUiLCJSZWdFeHAiLCJ0cmFpbGluZ1doaXRlc3BhY2VSZSIsImFsbFdoaXRlc3BhY2VPckVtcHR5UmUiLCJuZXdsaW5lT3JOb25XaGl0ZXNwYWNlUmUiLCJuZXdsaW5lT3JOb25OZXdsaW5lU3RyaW5nUmUiLCJ3b3JkT3JOZXdsaW5lUmUiLCJzaHJpbmtXcmFwQWRkIiwidGV4dCIsInByZXZpb3VzbHlTdGFzaGVkU3BhY2UiLCJhbnlNYXRjaCIsIm0iLCJleGVjIiwidGVzdExlYWRpbmdXaGl0ZXNwYWNlIiwidGVzdFRyYWlsaW5nV2hpdGVzcGFjZSIsIndvcmRSZSIsImFkZExpdGVyYWwiLCJ0ZXN0IiwidGVzdENvbnRhaW5zV29yZHMiLCJjb3VudE5ld2xpbmVzTm9Xb3JkcyIsImxhc3RJbmRleCIsImNvdW50ZXIiLCJtYXRjaCIsIkJsb2NrVGV4dEJ1aWxkZXIiLCJwaWNrZXIiLCJtZXRhZGF0YSIsIndoaXRlc3BhY2VQcm9jZXNzb3IiLCJfc3RhY2tJdGVtIiwiX3dvcmRUcmFuc2Zvcm1lciIsInB1c2hXb3JkVHJhbnNmb3JtIiwid29yZFRyYW5zZm9ybSIsInBvcFdvcmRUcmFuc2Zvcm0iLCJzdGFydE5vV3JhcCIsInN0b3BOb1dyYXAiLCJfZ2V0Q29tYmluZWRXb3JkVHJhbnNmb3JtZXIiLCJ3dCIsImFwcGx5VHJhbnNmb3JtZXIiLCJjZSIsImVuY29kZUNoYXJhY3RlcnMiLCJfcG9wU3RhY2tJdGVtIiwiYWRkTGluZUJyZWFrIiwiYWRkV29yZEJyZWFrT3Bwb3J0dW5pdHkiLCJhZGRJbmxpbmUiLCJub1dvcmRUcmFuc2Zvcm0iLCJuZXdsaW5lc051bWJlciIsIm9wZW5CbG9jayIsInJlc2VydmVkTGluZUxlbmd0aCIsIk1hdGgiLCJtYXgiLCJjbG9zZUJsb2NrIiwidHJhaWxpbmdMaW5lQnJlYWtzIiwiYmxvY2tUcmFuc2Zvcm0iLCJibG9jayIsImJsb2NrVGV4dCIsImdldFRleHQiLCJhZGRUZXh0Iiwib3Blbkxpc3QiLCJvcGVuTGlzdEl0ZW0iLCJFcnJvciIsImxpc3QiLCJwcmVmaXhMZW5ndGgiLCJjbG9zZUxpc3RJdGVtIiwibGlzdEl0ZW0iLCJzcGFjaW5nIiwicGFkRW5kIiwiY2xvc2VMaXN0Iiwib3BlblRhYmxlIiwib3BlblRhYmxlUm93Iiwib3BlblRhYmxlQ2VsbCIsImNsb3NlVGFibGVDZWxsIiwiY29sc3BhbiIsInJvd3NwYW4iLCJjZWxsIiwiY2xvc2VUYWJsZVJvdyIsInJvdyIsImNsb3NlVGFibGUiLCJ0YWJsZVRvU3RyaW5nIiwidGFibGUiLCJvdXRwdXQiLCJzdGFja0l0ZW0iLCJwYXJlbnRUZXh0IiwibGluZUJyZWFrcyIsInRyYW5zZm9ybWVyIiwiY29tcGlsZSQxIiwic2VsZWN0b3JzV2l0aG91dEZvcm1hdCIsInNlbGVjdG9ycyIsImZpbHRlciIsInMiLCJmb3JtYXQiLCJzZWxlY3RvciIsIkRlY2lzaW9uVHJlZSIsImJ1aWxkIiwiaHAyQnVpbGRlciIsIm1ha2VSZXBsYWNlckZyb21EaWN0IiwiYmFzZVNlbGVjdG9yc1BpY2tlciIsImJhc2VFbGVtZW50cyIsImZpbmRCYXNlRWxlbWVudHMiLCJkb20iLCJmaW5kQmFzZXMiLCJsaW1pdGVkV2FsayIsImxpbWl0cyIsIm1heERlcHRoIiwicmVjdXJzaXZlV2FsayIsImJ1aWxkZXIiLCJlbGxpcHNpcyIsImh0bWwiLCJwcm9jZXNzIiwid2FsayIsIm1heElucHV0TGVuZ3RoIiwiY29uc29sZSIsIndhcm4iLCJkb2N1bWVudCIsInBhcnNlRG9jdW1lbnQiLCJkZWNvZGVFbnRpdGllcyIsImJhc2VzIiwiY2hpbGRyZW4iLCJyZXN1bHRzIiwic2xpY2UiLCJtYXhDaGlsZE5vZGVzIiwiZWxlbSIsInR5cGUiLCJwaWNrZWRTZWxlY3RvckluZGV4IiwicGljazEiLCJzZWxlY3RvckluZGV4IiwiZWxlbWVudCIsIm1heEJhc2VFbGVtZW50cyIsIm9yZGVyQnkiLCJzb3J0IiwiYSIsImIiLCJyZXR1cm5Eb21CeURlZmF1bHQiLCJ4IiwidG9vTWFueUNoaWxkTm9kZXMiLCJkYXRhIiwidGFnRGVmaW5pdGlvbiIsImZvcm1hdHRlcnMiLCJkaWN0Iiwia2V5cyIsImVudHJpZXMiLCJyZWdleCIsInJlcGxhY2VyIiwiY2dzIiwiZmluZEluZGV4IiwiY2ciLCJmb3JtYXRTa2lwIiwiZm9ybWF0T3B0aW9ucyIsImZvcm1hdElubGluZVN0cmluZyIsInN0cmluZyIsImZvcm1hdEJsb2NrU3RyaW5nIiwiZm9ybWF0SW5saW5lIiwiZm9ybWF0QmxvY2skMSIsInJlbmRlck9wZW5UYWciLCJhdHRycyIsImF0dHJpYnMiLCJrIiwibmFtZSIsInJlbmRlckNsb3NlVGFnIiwiZm9ybWF0SW5saW5lVGFnIiwiZm9ybWF0QmxvY2tUYWciLCJmb3JtYXRJbmxpbmVIdG1sIiwicmVuZGVyIiwiZm9ybWF0QmxvY2tIdG1sIiwiZm9ybWF0SW5saW5lU3Vycm91bmQiLCJzdWZmaXgiLCJnZW5lcmljRm9ybWF0dGVycyIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImJsb2NrSHRtbCIsImJsb2NrU3RyaW5nIiwiYmxvY2tUYWciLCJpbmxpbmUiLCJpbmxpbmVIdG1sIiwiaW5saW5lU3RyaW5nIiwiaW5saW5lU3Vycm91bmQiLCJpbmxpbmVUYWciLCJza2lwIiwiZ2V0Um93IiwibWF0cml4IiwiaiIsImZpbmRGaXJzdFZhY2FudEluZGV4IiwidHJhbnNwb3NlSW5QbGFjZSIsIm1heFNpemUiLCJyb3dJIiwicm93SiIsInRlbXAiLCJwdXRDZWxsSW50b0xheW91dCIsImxheW91dCIsImJhc2VSb3ciLCJiYXNlQ29sIiwiciIsImxheW91dFJvdyIsInVwZGF0ZU9mZnNldCIsIm9mZnNldHMiLCJzcGFuIiwidGFibGVSb3dzIiwicm93U3BhY2luZyIsImNvbFNwYWNpbmciLCJjb2xOdW1iZXIiLCJyb3dOdW1iZXIiLCJyb3dPZmZzZXRzIiwic3BsaXQiLCJjZWxsSGVpZ2h0Iiwib3V0cHV0TGluZXMiLCJjb2xPZmZzZXRzIiwieSIsInJlbmRlcmVkIiwiY2VsbFdpZHRoIiwibGluZSIsImxpbmVPZmZzZXQiLCJmb3JtYXRMaW5lQnJlYWsiLCJmb3JtYXRXYnIiLCJmb3JtYXRIb3Jpem9udGFsTGluZSIsImZvcm1hdFBhcmFncmFwaCIsImZvcm1hdFByZSIsImZvcm1hdEhlYWRpbmciLCJ1cHBlcmNhc2UiLCJ0b1VwcGVyQ2FzZSIsImZvcm1hdEJsb2NrcXVvdGUiLCJ0cmltRW1wdHlMaW5lcyIsIndpdGhCcmFja2V0cyIsImJyYWNrZXRzIiwibGJyIiwicmJyIiwicGF0aFJld3JpdGUiLCJyZXdyaXRlciIsImJhc2VVcmwiLCJtb2RpZmllZFBhdGgiLCJmb3JtYXRJbWFnZSIsImFsdCIsImxpbmtCcmFja2V0cyIsImZvcm1hdEFuY2hvciIsImdldEhyZWYiLCJpZ25vcmVIcmVmIiwiaHJlZiIsIm5vQW5jaG9yVXJsIiwiaGlkZVNhbWVMaW5rIiwiaGlkZUxpbmtIcmVmSWZTYW1lQXNUZXh0IiwiZm9ybWF0TGlzdCIsIm5leHRQcmVmaXhDYWxsYmFjayIsImlzTmVzdGVkTGlzdCIsImxpc3RJdGVtcyIsImNoaWxkIiwibm9kZSIsInRyaW1TdGFydCIsImZvcm1hdFVub3JkZXJlZExpc3QiLCJpdGVtUHJlZml4IiwiZm9ybWF0T3JkZXJlZExpc3QiLCJuZXh0SW5kZXgiLCJpbmRleEZ1bmN0aW9uIiwiZ2V0T3JkZXJlZExpc3RJbmRleEZ1bmN0aW9uIiwib2xUeXBlIiwidG9Mb3dlckNhc2UiLCJzcGxpdENsYXNzZXNBbmRJZHMiLCJjbGFzc2VzIiwiaWRzIiwic3RhcnRzV2l0aCIsImlzRGF0YVRhYmxlIiwiYXR0ciIsInRhYmxlcyIsImF0dHJDbGFzc2VzIiwiYXR0cklkcyIsInNvbWUiLCJpbmNsdWRlcyIsImZvcm1hdFRhYmxlIiwiZm9ybWF0RGF0YVRhYmxlIiwiZm9ybWF0QmxvY2siLCJmb3JFYWNoIiwid2Fsa1RhYmxlIiwiZm9ybWF0Q2VsbCIsImNlbGxOb2RlIiwiZm9ybWF0SGVhZGVyQ2VsbCIsInVwcGVyY2FzZUhlYWRlckNlbGxzIiwiY2hpbGRPZlRyIiwidGV4dEZvcm1hdHRlcnMiLCJhbmNob3IiLCJibG9ja3F1b3RlIiwiZGF0YVRhYmxlIiwiaGVhZGluZyIsImhvcml6b250YWxMaW5lIiwiaW1hZ2UiLCJsaW5lQnJlYWsiLCJvcmRlcmVkTGlzdCIsInBhcmFncmFwaCIsInByZSIsInVub3JkZXJlZExpc3QiLCJ3YnIiLCJERUZBVUxUX09QVElPTlMiLCJsb25nV29yZFNwbGl0IiwiY29uY2F0TWVyZ2UiLCJvdmVyd3JpdGVNZXJnZSIsInNlbGVjdG9yc01lcmdlIiwiY29tcGlsZSIsImN1c3RvbU1lcmdlIiwiYXNzaWduIiwiaGFuZGxlRGVwcmVjYXRlZE9wdGlvbnMiLCJjb252ZXJ0IiwidGFncyIsInRhZ0RlZmluaXRpb25zIiwiZGVmaW5pdGlvbiIsInZhbHVlS2V5IiwibmVzdGVkIiwiYmFzZUVsZW1lbnQiLCJpc0FycmF5IiwiaHRtbFRvVGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/html-to-text/lib/html-to-text.cjs\n");

/***/ }),

/***/ "(rsc)/../node_modules/html-to-text/lib/html-to-text.cjs":
/*!*********************************************************!*\
  !*** ../node_modules/html-to-text/lib/html-to-text.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar pluginHtmlparser2 = __webpack_require__(/*! @selderee/plugin-htmlparser2 */ \"(rsc)/../node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.cjs\");\nvar htmlparser2 = __webpack_require__(/*! htmlparser2 */ \"(rsc)/../node_modules/htmlparser2/lib/index.js\");\nvar selderee = __webpack_require__(/*! selderee */ \"(rsc)/../node_modules/selderee/lib/selderee.cjs\");\nvar merge = __webpack_require__(/*! deepmerge */ \"(rsc)/../node_modules/deepmerge/dist/cjs.js\");\nvar domSerializer = __webpack_require__(/*! dom-serializer */ \"(rsc)/../node_modules/dom-serializer/lib/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar merge__default = /*#__PURE__*/ _interopDefaultLegacy(merge);\n/**\n * Make a recursive function that will only run to a given depth\n * and switches to an alternative function at that depth. \\\n * No limitation if `n` is `undefined` (Just wraps `f` in that case).\n *\n * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.\n * @param   { Function }           f   Function that accepts recursive callback as the first argument.\n * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.\n * @returns { Function }\n */ function limitedDepthRecursive(n, f, g = ()=>undefined) {\n    if (n === undefined) {\n        const f1 = function(...args) {\n            return f(f1, ...args);\n        };\n        return f1;\n    }\n    if (n >= 0) {\n        return function(...args) {\n            return f(limitedDepthRecursive(n - 1, f, g), ...args);\n        };\n    }\n    return g;\n}\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from each side.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */ function trimCharacter(str, char) {\n    let start = 0;\n    let end = str.length;\n    while(start < end && str[start] === char){\n        ++start;\n    }\n    while(end > start && str[end - 1] === char){\n        --end;\n    }\n    return start > 0 || end < str.length ? str.substring(start, end) : str;\n}\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from the end only.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */ function trimCharacterEnd(str, char) {\n    let end = str.length;\n    while(end > 0 && str[end - 1] === char){\n        --end;\n    }\n    return end < str.length ? str.substring(0, end) : str;\n}\n/**\n * Return a new string will all characters replaced with unicode escape sequences.\n * This extreme kind of escaping can used to be safely compose regular expressions.\n *\n * @param { string } str A string to escape.\n * @returns { string } A string of unicode escape sequences.\n */ function unicodeEscape(str) {\n    return str.replace(/[\\s\\S]/g, (c)=>\"\\\\u\" + c.charCodeAt().toString(16).padStart(4, \"0\"));\n}\n/**\n * Deduplicate an array by a given key callback.\n * Item properties are merged recursively and with the preference for last defined values.\n * Of items with the same key, merged item takes the place of the last item,\n * others are omitted.\n *\n * @param { any[] } items An array to deduplicate.\n * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.\n * @returns { any[] }\n */ function mergeDuplicatesPreferLast(items, getKey) {\n    const map = new Map();\n    for(let i = items.length; i-- > 0;){\n        const item = items[i];\n        const key = getKey(item);\n        map.set(key, map.has(key) ? merge__default[\"default\"](item, map.get(key), {\n            arrayMerge: overwriteMerge$1\n        }) : item);\n    }\n    return [\n        ...map.values()\n    ].reverse();\n}\nconst overwriteMerge$1 = (acc, src, options)=>[\n        ...src\n    ];\n/**\n * Get a nested property from an object.\n *\n * @param   { object }   obj  The object to query for the value.\n * @param   { string[] } path The path to the property.\n * @returns { any }\n */ function get(obj, path) {\n    for (const key of path){\n        if (!obj) {\n            return undefined;\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n/**\n * Convert a number into alphabetic sequence representation (Sequence without zeroes).\n *\n * For example: `a, ..., z, aa, ..., zz, aaa, ...`.\n *\n * @param   { number } num              Number to convert. Must be >= 1.\n * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.\n * @param   { number } [base = 26]      Number of characters in the sequence.\n * @returns { string }\n */ function numberToLetterSequence(num, baseChar = \"a\", base = 26) {\n    const digits = [];\n    do {\n        num -= 1;\n        digits.push(num % base);\n        num = num / base >> 0; // quick `floor`\n    }while (num > 0);\n    const baseCode = baseChar.charCodeAt(0);\n    return digits.reverse().map((n)=>String.fromCharCode(baseCode + n)).join(\"\");\n}\nconst I = [\n    \"I\",\n    \"X\",\n    \"C\",\n    \"M\"\n];\nconst V = [\n    \"V\",\n    \"L\",\n    \"D\"\n];\n/**\n * Convert a number to it's Roman representation. No large numbers extension.\n *\n * @param   { number } num Number to convert. `0 < num <= 3999`.\n * @returns { string }\n */ function numberToRoman(num) {\n    return [\n        ...num + \"\"\n    ].map((n)=>+n).reverse().map((v, i)=>v % 5 < 4 ? (v < 5 ? \"\" : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join(\"\");\n}\n/**\n * Helps to build text from words.\n */ class InlineTextBuilder {\n    /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */ constructor(options, maxLineLength = undefined){\n        /** @type { string[][] } */ this.lines = [];\n        /** @type { string[] }   */ this.nextLineWords = [];\n        this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n        this.nextLineAvailableChars = this.maxLineLength;\n        this.wrapCharacters = get(options, [\n            \"longWordSplit\",\n            \"wrapCharacters\"\n        ]) || [];\n        this.forceWrapOnLimit = get(options, [\n            \"longWordSplit\",\n            \"forceWrapOnLimit\"\n        ]) || false;\n        this.stashedSpace = false;\n        this.wordBreakOpportunity = false;\n    }\n    /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */ pushWord(word, noWrap = false) {\n        if (this.nextLineAvailableChars <= 0 && !noWrap) {\n            this.startNewLine();\n        }\n        const isLineStart = this.nextLineWords.length === 0;\n        const cost = word.length + (isLineStart ? 0 : 1);\n        if (cost <= this.nextLineAvailableChars || noWrap) {\n            this.nextLineWords.push(word);\n            this.nextLineAvailableChars -= cost;\n        } else {\n            // The word is moved to a new line - prefer to wrap between words.\n            const [first, ...rest] = this.splitLongWord(word);\n            if (!isLineStart) {\n                this.startNewLine();\n            }\n            this.nextLineWords.push(first);\n            this.nextLineAvailableChars -= first.length;\n            for (const part of rest){\n                this.startNewLine();\n                this.nextLineWords.push(part);\n                this.nextLineAvailableChars -= part.length;\n            }\n        }\n    }\n    /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */ popWord() {\n        const lastWord = this.nextLineWords.pop();\n        if (lastWord !== undefined) {\n            const isLineStart = this.nextLineWords.length === 0;\n            const cost = lastWord.length + (isLineStart ? 0 : 1);\n            this.nextLineAvailableChars += cost;\n        }\n        return lastWord;\n    }\n    /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */ concatWord(word, noWrap = false) {\n        if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n            this.pushWord(word, noWrap);\n            this.wordBreakOpportunity = false;\n        } else {\n            const lastWord = this.popWord();\n            this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);\n        }\n    }\n    /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */ startNewLine(n = 1) {\n        this.lines.push(this.nextLineWords);\n        if (n > 1) {\n            this.lines.push(...Array.from({\n                length: n - 1\n            }, ()=>[]));\n        }\n        this.nextLineWords = [];\n        this.nextLineAvailableChars = this.maxLineLength;\n    }\n    /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */ isEmpty() {\n        return this.lines.length === 0 && this.nextLineWords.length === 0;\n    }\n    clear() {\n        this.lines.length = 0;\n        this.nextLineWords.length = 0;\n        this.nextLineAvailableChars = this.maxLineLength;\n    }\n    /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */ toString() {\n        return [\n            ...this.lines,\n            this.nextLineWords\n        ].map((words)=>words.join(\" \")).join(\"\\n\");\n    }\n    /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */ splitLongWord(word) {\n        const parts = [];\n        let idx = 0;\n        while(word.length > this.maxLineLength){\n            const firstLine = word.substring(0, this.maxLineLength);\n            const remainingChars = word.substring(this.maxLineLength);\n            const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n            if (splitIndex > -1) {\n                word = firstLine.substring(splitIndex + 1) + remainingChars;\n                parts.push(firstLine.substring(0, splitIndex + 1));\n            } else {\n                idx++;\n                if (idx < this.wrapCharacters.length) {\n                    word = firstLine + remainingChars;\n                } else {\n                    if (this.forceWrapOnLimit) {\n                        parts.push(firstLine);\n                        word = remainingChars;\n                        if (word.length > this.maxLineLength) {\n                            continue;\n                        }\n                    } else {\n                        word = firstLine + remainingChars;\n                    }\n                    break;\n                }\n            }\n        }\n        parts.push(word); // Add remaining part to array\n        return parts;\n    }\n}\n/* eslint-disable max-classes-per-file */ class StackItem {\n    constructor(next = null){\n        this.next = next;\n    }\n    getRoot() {\n        return this.next ? this.next : this;\n    }\n}\nclass BlockStackItem extends StackItem {\n    constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined){\n        super(next);\n        this.leadingLineBreaks = leadingLineBreaks;\n        this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);\n        this.rawText = \"\";\n        this.stashedLineBreaks = 0;\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass ListStackItem extends BlockStackItem {\n    constructor(options, next = null, { interRowLineBreaks = 1, leadingLineBreaks = 2, maxLineLength = undefined, maxPrefixLength = 0, prefixAlign = \"left\" } = {}){\n        super(options, next, leadingLineBreaks, maxLineLength);\n        this.maxPrefixLength = maxPrefixLength;\n        this.prefixAlign = prefixAlign;\n        this.interRowLineBreaks = interRowLineBreaks;\n    }\n}\nclass ListItemStackItem extends BlockStackItem {\n    constructor(options, next = null, { leadingLineBreaks = 1, maxLineLength = undefined, prefix = \"\" } = {}){\n        super(options, next, leadingLineBreaks, maxLineLength);\n        this.prefix = prefix;\n    }\n}\nclass TableStackItem extends StackItem {\n    constructor(next = null){\n        super(next);\n        this.rows = [];\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass TableRowStackItem extends StackItem {\n    constructor(next = null){\n        super(next);\n        this.cells = [];\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass TableCellStackItem extends StackItem {\n    constructor(options, next = null, maxColumnWidth = undefined){\n        super(next);\n        this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);\n        this.rawText = \"\";\n        this.stashedLineBreaks = 0;\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass TransformerStackItem extends StackItem {\n    constructor(next = null, transform){\n        super(next);\n        this.transform = transform;\n    }\n}\nfunction charactersToCodes(str) {\n    return [\n        ...str\n    ].map((c)=>\"\\\\u\" + c.charCodeAt(0).toString(16).padStart(4, \"0\")).join(\"\");\n}\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */ class WhitespaceProcessor {\n    /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */ constructor(options){\n        this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\\n/g, \"\") : options.whitespaceCharacters;\n        const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n        this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n        this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n        this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n        this.newlineOrNonWhitespaceRe = new RegExp(`(\\\\n|[^\\\\n${whitespaceCodes}])`, \"g\");\n        this.newlineOrNonNewlineStringRe = new RegExp(`(\\\\n|[^\\\\n]+)`, \"g\");\n        if (options.preserveNewlines) {\n            const wordOrNewlineRe = new RegExp(`\\\\n|[^\\\\n${whitespaceCodes}]+`, \"gm\");\n            /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.\n       */ this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str)=>str, noWrap = false) {\n                if (!text) {\n                    return;\n                }\n                const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n                let anyMatch = false;\n                let m = wordOrNewlineRe.exec(text);\n                if (m) {\n                    anyMatch = true;\n                    if (m[0] === \"\\n\") {\n                        inlineTextBuilder.startNewLine();\n                    } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                    } else {\n                        inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n                    }\n                    while((m = wordOrNewlineRe.exec(text)) !== null){\n                        if (m[0] === \"\\n\") {\n                            inlineTextBuilder.startNewLine();\n                        } else {\n                            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                        }\n                    }\n                }\n                inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n            // No need to stash a space in case last added item was a new line,\n            // but that won't affect anything later anyway.\n            };\n        } else {\n            const wordRe = new RegExp(`[^${whitespaceCodes}]+`, \"g\");\n            this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str)=>str, noWrap = false) {\n                if (!text) {\n                    return;\n                }\n                const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n                let anyMatch = false;\n                let m = wordRe.exec(text);\n                if (m) {\n                    anyMatch = true;\n                    if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                    } else {\n                        inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n                    }\n                    while((m = wordRe.exec(text)) !== null){\n                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                    }\n                }\n                inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n            };\n        }\n    }\n    /**\n   * Add text with only minimal processing.\n   * Everything between newlines considered a single word.\n   * No whitespace is trimmed.\n   * Not affected by preserveNewlines option - `\\n` always starts a new line.\n   *\n   * `noWrap` argument is `true` by default - this won't start a new line\n   * even if there is not enough space left in the current line.\n   *\n   * @param { string }            text              Input text.\n   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.\n   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.\n   */ addLiteral(text, inlineTextBuilder, noWrap = true) {\n        if (!text) {\n            return;\n        }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = this.newlineOrNonNewlineStringRe.exec(text);\n        if (m) {\n            anyMatch = true;\n            if (m[0] === \"\\n\") {\n                inlineTextBuilder.startNewLine();\n            } else if (previouslyStashedSpace) {\n                inlineTextBuilder.pushWord(m[0], noWrap);\n            } else {\n                inlineTextBuilder.concatWord(m[0], noWrap);\n            }\n            while((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null){\n                if (m[0] === \"\\n\") {\n                    inlineTextBuilder.startNewLine();\n                } else {\n                    inlineTextBuilder.pushWord(m[0], noWrap);\n                }\n            }\n        }\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;\n    }\n    /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */ testLeadingWhitespace(text) {\n        return this.leadingWhitespaceRe.test(text);\n    }\n    /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */ testTrailingWhitespace(text) {\n        return this.trailingWhitespaceRe.test(text);\n    }\n    /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */ testContainsWords(text) {\n        return !this.allWhitespaceOrEmptyRe.test(text);\n    }\n    /**\n   * Return the number of newlines if there are no words.\n   *\n   * If any word is found then return zero regardless of the actual number of newlines.\n   *\n   * @param   { string }  text  Input string.\n   * @returns { number }\n   */ countNewlinesNoWords(text) {\n        this.newlineOrNonWhitespaceRe.lastIndex = 0;\n        let counter = 0;\n        let match;\n        while((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null){\n            if (match[0] === \"\\n\") {\n                counter++;\n            } else {\n                return 0;\n            }\n        }\n        return counter;\n    }\n}\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */ class BlockTextBuilder {\n    /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.\n   */ constructor(options, picker, metadata = undefined){\n        this.options = options;\n        this.picker = picker;\n        this.metadata = metadata;\n        this.whitespaceProcessor = new WhitespaceProcessor(options);\n        /** @type { StackItem } */ this._stackItem = new BlockStackItem(options);\n        /** @type { TransformerStackItem } */ this._wordTransformer = undefined;\n    }\n    /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */ pushWordTransform(wordTransform) {\n        this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n    }\n    /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */ popWordTransform() {\n        if (!this._wordTransformer) {\n            return undefined;\n        }\n        const transform = this._wordTransformer.transform;\n        this._wordTransformer = this._wordTransformer.next;\n        return transform;\n    }\n    /**\n   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.\n   */ startNoWrap() {\n        this._stackItem.isNoWrap = true;\n    }\n    /**\n   * Return automatic wrapping to behavior defined by options.\n   */ stopNoWrap() {\n        this._stackItem.isNoWrap = false;\n    }\n    /** @returns { (str: string) => string } */ _getCombinedWordTransformer() {\n        const wt = this._wordTransformer ? (str)=>applyTransformer(str, this._wordTransformer) : undefined;\n        const ce = this.options.encodeCharacters;\n        return wt ? ce ? (str)=>ce(wt(str)) : wt : ce;\n    }\n    _popStackItem() {\n        const item = this._stackItem;\n        this._stackItem = item.next;\n        return item;\n    }\n    /**\n   * Add a line break into currently built block.\n   */ addLineBreak() {\n        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n            return;\n        }\n        if (this._stackItem.isPre) {\n            this._stackItem.rawText += \"\\n\";\n        } else {\n            this._stackItem.inlineTextBuilder.startNewLine();\n        }\n    }\n    /**\n   * Allow to break line in case directly following text will not fit.\n   */ addWordBreakOpportunity() {\n        if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {\n            this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n        }\n    }\n    /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object } [param1]\n   * Object holding the parameters of the operation.\n   *\n   * @param { boolean } [param1.noWordTransform]\n   * Ignore word transformers if there are any.\n   * Don't encode characters as well.\n   * (Use this for things like URL addresses).\n   */ addInline(str, { noWordTransform = false } = {}) {\n        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n            return;\n        }\n        if (this._stackItem.isPre) {\n            this._stackItem.rawText += str;\n            return;\n        }\n        if (str.length === 0 || // empty string\n        this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant\n        !this.whitespaceProcessor.testContainsWords(str) // no words to add\n        ) {\n            return;\n        }\n        if (this.options.preserveNewlines) {\n            const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n            if (newlinesNumber > 0) {\n                this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);\n                // keep stashedLineBreaks unchanged\n                return;\n            }\n        }\n        if (this._stackItem.stashedLineBreaks) {\n            this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n        }\n        this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);\n        this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n    }\n    /**\n   * Add a string inline into the currently built block.\n   *\n   * Use this for markup elements that don't have to adhere\n   * to text layout rules.\n   *\n   * @param { string } str Text to add.\n   */ addLiteral(str) {\n        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n            return;\n        }\n        if (str.length === 0) {\n            return;\n        }\n        if (this._stackItem.isPre) {\n            this._stackItem.rawText += str;\n            return;\n        }\n        if (this._stackItem.stashedLineBreaks) {\n            this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n        }\n        this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);\n        this._stackItem.stashedLineBreaks = 0;\n    }\n    /**\n   * Start building a new block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any preceding block.\n   *\n   * @param { number }  [param0.reservedLineLength]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [param0.isPre]\n   * Should HTML whitespace be preserved inside this block.\n   */ openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {\n        const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n        this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n        if (isPre) {\n            this._stackItem.isPre = true;\n        }\n    }\n    /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [param0.blockTransform]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   */ closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {\n        const block = this._popStackItem();\n        const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n        addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n    }\n    /**\n   * Start building a new list.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.maxPrefixLength]\n   * Length of the longest list item prefix.\n   * If not supplied or too small then list items won't be aligned properly.\n   *\n   * @param { 'left' | 'right' } [param0.prefixAlign]\n   * Specify how prefixes of different lengths have to be aligned\n   * within a column.\n   *\n   * @param { number } [param0.interRowLineBreaks]\n   * Minimum number of line breaks between list items.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any preceding block.\n   */ openList({ maxPrefixLength = 0, prefixAlign = \"left\", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {\n        this._stackItem = new ListStackItem(this.options, this._stackItem, {\n            interRowLineBreaks: interRowLineBreaks,\n            leadingLineBreaks: leadingLineBreaks,\n            maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,\n            maxPrefixLength: maxPrefixLength,\n            prefixAlign: prefixAlign\n        });\n    }\n    /**\n   * Start building a new list item.\n   *\n   * @param {object} param0\n   * Object holding the parameters of the list item.\n   *\n   * @param { string } [param0.prefix]\n   * Prefix for this list item (item number, bullet point, etc).\n   */ openListItem({ prefix = \"\" } = {}) {\n        if (!(this._stackItem instanceof ListStackItem)) {\n            throw new Error(\"Can't add a list item to something that is not a list! Check the formatter.\");\n        }\n        const list = this._stackItem;\n        const prefixLength = Math.max(prefix.length, list.maxPrefixLength);\n        const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);\n        this._stackItem = new ListItemStackItem(this.options, list, {\n            prefix: prefix,\n            maxLineLength: maxLineLength,\n            leadingLineBreaks: list.interRowLineBreaks\n        });\n    }\n    /**\n   * Finalize currently built list item, add it's content to the parent list.\n   */ closeListItem() {\n        const listItem = this._popStackItem();\n        const list = listItem.next;\n        const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);\n        const spacing = \"\\n\" + \" \".repeat(prefixLength);\n        const prefix = list.prefixAlign === \"right\" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);\n        const text = prefix + getText(listItem).replace(/\\n/g, spacing);\n        addText(list, text, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));\n    }\n    /**\n   * Finalize currently built list, add it's content to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any following block.\n   */ closeList({ trailingLineBreaks = 2 } = {}) {\n        const list = this._popStackItem();\n        const text = getText(list);\n        if (text) {\n            addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);\n        }\n    }\n    /**\n   * Start building a table.\n   */ openTable() {\n        this._stackItem = new TableStackItem(this._stackItem);\n    }\n    /**\n   * Start building a table row.\n   */ openTableRow() {\n        if (!(this._stackItem instanceof TableStackItem)) {\n            throw new Error(\"Can't add a table row to something that is not a table! Check the formatter.\");\n        }\n        this._stackItem = new TableRowStackItem(this._stackItem);\n    }\n    /**\n   * Start building a table cell.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.maxColumnWidth]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */ openTableCell({ maxColumnWidth = undefined } = {}) {\n        if (!(this._stackItem instanceof TableRowStackItem)) {\n            throw new Error(\"Can't add a table cell to something that is not a table row! Check the formatter.\");\n        }\n        this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n    }\n    /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.colspan] How many columns this cell should occupy.\n   * @param { number } [param0.rowspan] How many rows this cell should occupy.\n   */ closeTableCell({ colspan = 1, rowspan = 1 } = {}) {\n        const cell = this._popStackItem();\n        const text = trimCharacter(getText(cell), \"\\n\");\n        cell.next.cells.push({\n            colspan: colspan,\n            rowspan: rowspan,\n            text: text\n        });\n    }\n    /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */ closeTableRow() {\n        const row = this._popStackItem();\n        row.next.rows.push(row.cells);\n    }\n    /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the table.\n   *\n   * @param { TablePrinter } param0.tableToString\n   * A function to convert a table of stringified cells into a complete table.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   */ closeTable({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {\n        const table = this._popStackItem();\n        const output = tableToString(table.rows);\n        if (output) {\n            addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n        }\n    }\n    /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */ toString() {\n        return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n    }\n}\nfunction getText(stackItem) {\n    if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n        throw new Error(\"Only blocks, list items and table cells can be requested for text contents.\");\n    }\n    return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n    if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n        throw new Error(\"Only blocks, list items and table cells can contain text.\");\n    }\n    const parentText = getText(stackItem);\n    const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n    stackItem.inlineTextBuilder.clear();\n    if (parentText) {\n        stackItem.rawText = parentText + \"\\n\".repeat(lineBreaks) + text;\n    } else {\n        stackItem.rawText = text;\n        stackItem.leadingLineBreaks = lineBreaks;\n    }\n    stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n/**\n * @param { string } str A string to transform.\n * @param { TransformerStackItem } transformer A transformer item (with possible continuation).\n * @returns { string }\n */ function applyTransformer(str, transformer) {\n    return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n}\n/**\n * Compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */ function compile$1(options = {}) {\n    const selectorsWithoutFormat = options.selectors.filter((s)=>!s.format);\n    if (selectorsWithoutFormat.length) {\n        throw new Error(\"Following selectors have no specified format: \" + selectorsWithoutFormat.map((s)=>`\\`${s.selector}\\``).join(\", \"));\n    }\n    const picker = new selderee.DecisionTree(options.selectors.map((s)=>[\n            s.selector,\n            s\n        ])).build(pluginHtmlparser2.hp2Builder);\n    if (typeof options.encodeCharacters !== \"function\") {\n        options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);\n    }\n    const baseSelectorsPicker = new selderee.DecisionTree(options.baseElements.selectors.map((s, i)=>[\n            s,\n            i + 1\n        ])).build(pluginHtmlparser2.hp2Builder);\n    function findBaseElements(dom) {\n        return findBases(dom, options, baseSelectorsPicker);\n    }\n    const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {\n        builder.addInline(options.limits.ellipsis || \"\");\n    });\n    return function(html, metadata = undefined) {\n        return process(html, metadata, options, picker, findBaseElements, limitedWalk);\n    };\n}\n/**\n * Convert given HTML according to preprocessed options.\n *\n * @param { string } html HTML content to convert.\n * @param { any } metadata Optional metadata for HTML document, for use in formatters.\n * @param { Options } options HtmlToText options (preprocessed).\n * @param { import('selderee').Picker<DomNode, TagDefinition> } picker\n * Tag definition picker for DOM nodes processing.\n * @param { (dom: DomNode[]) => DomNode[] } findBaseElements\n * Function to extract elements from HTML DOM\n * that will only be present in the output text.\n * @param { RecursiveCallback } walk Recursive callback.\n * @returns { string }\n */ function process(html, metadata, options, picker, findBaseElements, walk) {\n    const maxInputLength = options.limits.maxInputLength;\n    if (maxInputLength && html && html.length > maxInputLength) {\n        console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);\n        html = html.substring(0, maxInputLength);\n    }\n    const document = htmlparser2.parseDocument(html, {\n        decodeEntities: options.decodeEntities\n    });\n    const bases = findBaseElements(document.children);\n    const builder = new BlockTextBuilder(options, picker, metadata);\n    walk(bases, builder);\n    return builder.toString();\n}\nfunction findBases(dom, options, baseSelectorsPicker) {\n    const results = [];\n    function recursiveWalk(walk, /** @type { DomNode[] } */ dom) {\n        dom = dom.slice(0, options.limits.maxChildNodes);\n        for (const elem of dom){\n            if (elem.type !== \"tag\") {\n                continue;\n            }\n            const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);\n            if (pickedSelectorIndex > 0) {\n                results.push({\n                    selectorIndex: pickedSelectorIndex,\n                    element: elem\n                });\n            } else if (elem.children) {\n                walk(elem.children);\n            }\n            if (results.length >= options.limits.maxBaseElements) {\n                return;\n            }\n        }\n    }\n    const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);\n    limitedWalk(dom);\n    if (options.baseElements.orderBy !== \"occurrence\") {\n        results.sort((a, b)=>a.selectorIndex - b.selectorIndex);\n    }\n    return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x)=>x.element);\n}\n/**\n * Function to walk through DOM nodes and accumulate their string representations.\n *\n * @param   { RecursiveCallback } walk    Recursive callback.\n * @param   { DomNode[] }         [dom]   Nodes array to process.\n * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.\n * @private\n */ function recursiveWalk(walk, dom, builder) {\n    if (!dom) {\n        return;\n    }\n    const options = builder.options;\n    const tooManyChildNodes = dom.length > options.limits.maxChildNodes;\n    if (tooManyChildNodes) {\n        dom = dom.slice(0, options.limits.maxChildNodes);\n        dom.push({\n            data: options.limits.ellipsis,\n            type: \"text\"\n        });\n    }\n    for (const elem of dom){\n        switch(elem.type){\n            case \"text\":\n                {\n                    builder.addInline(elem.data);\n                    break;\n                }\n            case \"tag\":\n                {\n                    const tagDefinition = builder.picker.pick1(elem);\n                    const format = options.formatters[tagDefinition.format];\n                    format(elem, walk, builder, tagDefinition.options || {});\n                    break;\n                }\n        }\n    }\n    return;\n}\n/**\n * @param { Object<string,string | false> } dict\n * A dictionary where keys are characters to replace\n * and values are replacement strings.\n *\n * First code point from dict keys is used.\n * Compound emojis with ZWJ are not supported (not until Node 16).\n *\n * @returns { ((str: string) => string) | undefined }\n */ function makeReplacerFromDict(dict) {\n    if (!dict || Object.keys(dict).length === 0) {\n        return undefined;\n    }\n    /** @type { [string, string][] } */ const entries = Object.entries(dict).filter(([, v])=>v !== false);\n    const regex = new RegExp(entries.map(([c])=>`(${unicodeEscape([\n            ...c\n        ][0])})`).join(\"|\"), \"g\");\n    const values = entries.map(([, v])=>v);\n    const replacer = (m, ...cgs)=>values[cgs.findIndex((cg)=>cg)];\n    return (str)=>str.replace(regex, replacer);\n}\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */ function formatSkip(elem, walk, builder, formatOptions) {\n/* do nothing */ }\n/**\n * Insert the given string literal inline instead of a tag.\n *\n * @type { FormatCallback }\n */ function formatInlineString(elem, walk, builder, formatOptions) {\n    builder.addLiteral(formatOptions.string || \"\");\n}\n/**\n * Insert a block with the given string literal instead of a tag.\n *\n * @type { FormatCallback }\n */ function formatBlockString(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.addLiteral(formatOptions.string || \"\");\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */ function formatInline(elem, walk, builder, formatOptions) {\n    walk(elem.children, builder);\n}\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */ function formatBlock$1(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\nfunction renderOpenTag(elem) {\n    const attrs = elem.attribs && elem.attribs.length ? \" \" + Object.entries(elem.attribs).map(([k, v])=>v === \"\" ? k : `${k}=${v.replace(/\"/g, \"&quot;\")}`).join(\" \") : \"\";\n    return `<${elem.name}${attrs}>`;\n}\nfunction renderCloseTag(elem) {\n    return `</${elem.name}>`;\n}\n/**\n * Render an element as inline HTML tag, walk through it's children.\n *\n * @type { FormatCallback }\n */ function formatInlineTag(elem, walk, builder, formatOptions) {\n    builder.startNoWrap();\n    builder.addLiteral(renderOpenTag(elem));\n    builder.stopNoWrap();\n    walk(elem.children, builder);\n    builder.startNoWrap();\n    builder.addLiteral(renderCloseTag(elem));\n    builder.stopNoWrap();\n}\n/**\n * Render an element as HTML block bag, walk through it's children.\n *\n * @type { FormatCallback }\n */ function formatBlockTag(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.startNoWrap();\n    builder.addLiteral(renderOpenTag(elem));\n    builder.stopNoWrap();\n    walk(elem.children, builder);\n    builder.startNoWrap();\n    builder.addLiteral(renderCloseTag(elem));\n    builder.stopNoWrap();\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Render an element with all it's children as inline HTML.\n *\n * @type { FormatCallback }\n */ function formatInlineHtml(elem, walk, builder, formatOptions) {\n    builder.startNoWrap();\n    builder.addLiteral(domSerializer.render(elem, {\n        decodeEntities: builder.options.decodeEntities\n    }));\n    builder.stopNoWrap();\n}\n/**\n * Render an element with all it's children as HTML block.\n *\n * @type { FormatCallback }\n */ function formatBlockHtml(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.startNoWrap();\n    builder.addLiteral(domSerializer.render(elem, {\n        decodeEntities: builder.options.decodeEntities\n    }));\n    builder.stopNoWrap();\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Render inline element wrapped with given strings.\n *\n * @type { FormatCallback }\n */ function formatInlineSurround(elem, walk, builder, formatOptions) {\n    builder.addLiteral(formatOptions.prefix || \"\");\n    walk(elem.children, builder);\n    builder.addLiteral(formatOptions.suffix || \"\");\n}\nvar genericFormatters = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    block: formatBlock$1,\n    blockHtml: formatBlockHtml,\n    blockString: formatBlockString,\n    blockTag: formatBlockTag,\n    inline: formatInline,\n    inlineHtml: formatInlineHtml,\n    inlineString: formatInlineString,\n    inlineSurround: formatInlineSurround,\n    inlineTag: formatInlineTag,\n    skip: formatSkip\n});\nfunction getRow(matrix, j) {\n    if (!matrix[j]) {\n        matrix[j] = [];\n    }\n    return matrix[j];\n}\nfunction findFirstVacantIndex(row, x = 0) {\n    while(row[x]){\n        x++;\n    }\n    return x;\n}\nfunction transposeInPlace(matrix, maxSize) {\n    for(let i = 0; i < maxSize; i++){\n        const rowI = getRow(matrix, i);\n        for(let j = 0; j < i; j++){\n            const rowJ = getRow(matrix, j);\n            const temp = rowI[j];\n            rowI[j] = rowJ[i];\n            rowJ[i] = temp;\n        }\n    }\n}\nfunction putCellIntoLayout(cell, layout, baseRow, baseCol) {\n    for(let r = 0; r < cell.rowspan; r++){\n        const layoutRow = getRow(layout, baseRow + r);\n        for(let c = 0; c < cell.colspan; c++){\n            layoutRow[baseCol + c] = cell;\n        }\n    }\n}\nfunction updateOffset(offsets, base, span, value) {\n    offsets[base + span] = Math.max(offsets[base + span] || 0, offsets[base] + value);\n}\n/**\n * Render a table into a string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */ function tableToString(tableRows, rowSpacing, colSpacing) {\n    const layout = [];\n    let colNumber = 0;\n    const rowNumber = tableRows.length;\n    const rowOffsets = [\n        0\n    ];\n    // Fill the layout table and row offsets row-by-row.\n    for(let j = 0; j < rowNumber; j++){\n        const layoutRow = getRow(layout, j);\n        const cells = tableRows[j];\n        let x = 0;\n        for(let i = 0; i < cells.length; i++){\n            const cell = cells[i];\n            x = findFirstVacantIndex(layoutRow, x);\n            putCellIntoLayout(cell, layout, j, x);\n            x += cell.colspan;\n            cell.lines = cell.text.split(\"\\n\");\n            const cellHeight = cell.lines.length;\n            updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n        }\n        colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;\n    }\n    transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);\n    const outputLines = [];\n    const colOffsets = [\n        0\n    ];\n    // Fill column offsets and output lines column-by-column.\n    for(let x = 0; x < colNumber; x++){\n        let y = 0;\n        let cell;\n        while(y < rowNumber && (cell = layout[x][y])){\n            if (!cell.rendered) {\n                let cellWidth = 0;\n                for(let j = 0; j < cell.lines.length; j++){\n                    const line = cell.lines[j];\n                    const lineOffset = rowOffsets[y] + j;\n                    outputLines[lineOffset] = (outputLines[lineOffset] || \"\").padEnd(colOffsets[x]) + line;\n                    cellWidth = line.length > cellWidth ? line.length : cellWidth;\n                }\n                updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n                cell.rendered = true;\n            }\n            y += cell.rowspan;\n        }\n    }\n    return outputLines.join(\"\\n\");\n}\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */ function formatLineBreak(elem, walk, builder, formatOptions) {\n    builder.addLineBreak();\n}\n/**\n * Process a `wbr` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */ function formatWbr(elem, walk, builder, formatOptions) {\n    builder.addWordBreakOpportunity();\n}\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */ function formatHorizontalLine(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.addInline(\"-\".repeat(formatOptions.length || builder.options.wordwrap || 40));\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */ function formatParagraph(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */ function formatPre(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        isPre: true,\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */ function formatHeading(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    if (formatOptions.uppercase !== false) {\n        builder.pushWordTransform((str)=>str.toUpperCase());\n        walk(elem.children, builder);\n        builder.popWordTransform();\n    } else {\n        walk(elem.children, builder);\n    }\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */ function formatBlockquote(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n        reservedLineLength: 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n        blockTransform: (str)=>(formatOptions.trimEmptyLines !== false ? trimCharacter(str, \"\\n\") : str).split(\"\\n\").map((line)=>\"> \" + line).join(\"\\n\")\n    });\n}\nfunction withBrackets(str, brackets) {\n    if (!brackets) {\n        return str;\n    }\n    const lbr = typeof brackets[0] === \"string\" ? brackets[0] : \"[\";\n    const rbr = typeof brackets[1] === \"string\" ? brackets[1] : \"]\";\n    return lbr + str + rbr;\n}\nfunction pathRewrite(path, rewriter, baseUrl, metadata, elem) {\n    const modifiedPath = typeof rewriter === \"function\" ? rewriter(path, metadata, elem) : path;\n    return modifiedPath[0] === \"/\" && baseUrl ? trimCharacterEnd(baseUrl, \"/\") + modifiedPath : modifiedPath;\n}\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */ function formatImage(elem, walk, builder, formatOptions) {\n    const attribs = elem.attribs || {};\n    const alt = attribs.alt ? attribs.alt : \"\";\n    const src = !attribs.src ? \"\" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n    const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + \" \" + withBrackets(src, formatOptions.linkBrackets);\n    builder.addInline(text, {\n        noWordTransform: true\n    });\n}\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */ function formatAnchor(elem, walk, builder, formatOptions) {\n    function getHref() {\n        if (formatOptions.ignoreHref) {\n            return \"\";\n        }\n        if (!elem.attribs || !elem.attribs.href) {\n            return \"\";\n        }\n        let href = elem.attribs.href.replace(/^mailto:/, \"\");\n        if (formatOptions.noAnchorUrl && href[0] === \"#\") {\n            return \"\";\n        }\n        href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n        return href;\n    }\n    const href = getHref();\n    if (!href) {\n        walk(elem.children, builder);\n    } else {\n        let text = \"\";\n        builder.pushWordTransform((str)=>{\n            if (str) {\n                text += str;\n            }\n            return str;\n        });\n        walk(elem.children, builder);\n        builder.popWordTransform();\n        const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n        if (!hideSameLink) {\n            builder.addInline(!text ? href : \" \" + withBrackets(href, formatOptions.linkBrackets), {\n                noWordTransform: true\n            });\n        }\n    }\n}\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.\n */ function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {\n    const isNestedList = get(elem, [\n        \"parent\",\n        \"name\"\n    ]) === \"li\";\n    // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n    // so the dumb length comparison is the most robust way to get the correct value.\n    let maxPrefixLength = 0;\n    const listItems = (elem.children || [])// it might be more accurate to check only for html spaces here, but no significant benefit\n    .filter((child)=>child.type !== \"text\" || !/^\\s*$/.test(child.data)).map(function(child) {\n        if (child.name !== \"li\") {\n            return {\n                node: child,\n                prefix: \"\"\n            };\n        }\n        const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();\n        if (prefix.length > maxPrefixLength) {\n            maxPrefixLength = prefix.length;\n        }\n        return {\n            node: child,\n            prefix: prefix\n        };\n    });\n    if (!listItems.length) {\n        return;\n    }\n    builder.openList({\n        interRowLineBreaks: 1,\n        leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,\n        maxPrefixLength: maxPrefixLength,\n        prefixAlign: \"left\"\n    });\n    for (const { node, prefix } of listItems){\n        builder.openListItem({\n            prefix: prefix\n        });\n        walk([\n            node\n        ], builder);\n        builder.closeListItem();\n    }\n    builder.closeList({\n        trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */ function formatUnorderedList(elem, walk, builder, formatOptions) {\n    const prefix = formatOptions.itemPrefix || \" * \";\n    return formatList(elem, walk, builder, formatOptions, ()=>prefix);\n}\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */ function formatOrderedList(elem, walk, builder, formatOptions) {\n    let nextIndex = Number(elem.attribs.start || \"1\");\n    const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n    const nextPrefixCallback = ()=>\" \" + indexFunction(nextIndex++) + \". \";\n    return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */ function getOrderedListIndexFunction(olType = \"1\") {\n    switch(olType){\n        case \"a\":\n            return (i)=>numberToLetterSequence(i, \"a\");\n        case \"A\":\n            return (i)=>numberToLetterSequence(i, \"A\");\n        case \"i\":\n            return (i)=>numberToRoman(i).toLowerCase();\n        case \"I\":\n            return (i)=>numberToRoman(i);\n        case \"1\":\n        default:\n            return (i)=>i.toString();\n    }\n}\n/**\n * Given a list of class and ID selectors (prefixed with '.' and '#'),\n * return them as separate lists of names without prefixes.\n *\n * @param { string[] } selectors Class and ID selectors (`[\".class\", \"#id\"]` etc).\n * @returns { { classes: string[], ids: string[] } }\n */ function splitClassesAndIds(selectors) {\n    const classes = [];\n    const ids = [];\n    for (const selector of selectors){\n        if (selector.startsWith(\".\")) {\n            classes.push(selector.substring(1));\n        } else if (selector.startsWith(\"#\")) {\n            ids.push(selector.substring(1));\n        }\n    }\n    return {\n        classes: classes,\n        ids: ids\n    };\n}\nfunction isDataTable(attr, tables) {\n    if (tables === true) {\n        return true;\n    }\n    if (!attr) {\n        return false;\n    }\n    const { classes, ids } = splitClassesAndIds(tables);\n    const attrClasses = (attr[\"class\"] || \"\").split(\" \");\n    const attrIds = (attr[\"id\"] || \"\").split(\" \");\n    return attrClasses.some((x)=>classes.includes(x)) || attrIds.some((x)=>ids.includes(x));\n}\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */ function formatTable(elem, walk, builder, formatOptions) {\n    return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);\n}\nfunction formatBlock(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks\n    });\n}\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */ function formatDataTable(elem, walk, builder, formatOptions) {\n    builder.openTable();\n    elem.children.forEach(walkTable);\n    builder.closeTable({\n        tableToString: (rows)=>tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),\n        leadingLineBreaks: formatOptions.leadingLineBreaks,\n        trailingLineBreaks: formatOptions.trailingLineBreaks\n    });\n    function formatCell(cellNode) {\n        const colspan = +get(cellNode, [\n            \"attribs\",\n            \"colspan\"\n        ]) || 1;\n        const rowspan = +get(cellNode, [\n            \"attribs\",\n            \"rowspan\"\n        ]) || 1;\n        builder.openTableCell({\n            maxColumnWidth: formatOptions.maxColumnWidth\n        });\n        walk(cellNode.children, builder);\n        builder.closeTableCell({\n            colspan: colspan,\n            rowspan: rowspan\n        });\n    }\n    function walkTable(elem) {\n        if (elem.type !== \"tag\") {\n            return;\n        }\n        const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode)=>{\n            builder.pushWordTransform((str)=>str.toUpperCase());\n            formatCell(cellNode);\n            builder.popWordTransform();\n        } : formatCell;\n        switch(elem.name){\n            case \"thead\":\n            case \"tbody\":\n            case \"tfoot\":\n            case \"center\":\n                elem.children.forEach(walkTable);\n                return;\n            case \"tr\":\n                {\n                    builder.openTableRow();\n                    for (const childOfTr of elem.children){\n                        if (childOfTr.type !== \"tag\") {\n                            continue;\n                        }\n                        switch(childOfTr.name){\n                            case \"th\":\n                                {\n                                    formatHeaderCell(childOfTr);\n                                    break;\n                                }\n                            case \"td\":\n                                {\n                                    formatCell(childOfTr);\n                                    break;\n                                }\n                        }\n                    }\n                    builder.closeTableRow();\n                    break;\n                }\n        }\n    }\n}\nvar textFormatters = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    anchor: formatAnchor,\n    blockquote: formatBlockquote,\n    dataTable: formatDataTable,\n    heading: formatHeading,\n    horizontalLine: formatHorizontalLine,\n    image: formatImage,\n    lineBreak: formatLineBreak,\n    orderedList: formatOrderedList,\n    paragraph: formatParagraph,\n    pre: formatPre,\n    table: formatTable,\n    unorderedList: formatUnorderedList,\n    wbr: formatWbr\n});\n/**\n * Default options.\n *\n * @constant\n * @type { Options }\n * @default\n * @private\n */ const DEFAULT_OPTIONS = {\n    baseElements: {\n        selectors: [\n            \"body\"\n        ],\n        orderBy: \"selectors\",\n        returnDomByDefault: true\n    },\n    decodeEntities: true,\n    encodeCharacters: {},\n    formatters: {},\n    limits: {\n        ellipsis: \"...\",\n        maxBaseElements: undefined,\n        maxChildNodes: undefined,\n        maxDepth: undefined,\n        maxInputLength: 1 << 24 // 16_777_216\n    },\n    longWordSplit: {\n        forceWrapOnLimit: false,\n        wrapCharacters: []\n    },\n    preserveNewlines: false,\n    selectors: [\n        {\n            selector: \"*\",\n            format: \"inline\"\n        },\n        {\n            selector: \"a\",\n            format: \"anchor\",\n            options: {\n                baseUrl: null,\n                hideLinkHrefIfSameAsText: false,\n                ignoreHref: false,\n                linkBrackets: [\n                    \"[\",\n                    \"]\"\n                ],\n                noAnchorUrl: true\n            }\n        },\n        {\n            selector: \"article\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"aside\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"blockquote\",\n            format: \"blockquote\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                trimEmptyLines: true\n            }\n        },\n        {\n            selector: \"br\",\n            format: \"lineBreak\"\n        },\n        {\n            selector: \"div\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"footer\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"form\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"h1\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 3,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h2\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 3,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h3\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 3,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h4\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h5\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h6\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"header\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"hr\",\n            format: \"horizontalLine\",\n            options: {\n                leadingLineBreaks: 2,\n                length: undefined,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"img\",\n            format: \"image\",\n            options: {\n                baseUrl: null,\n                linkBrackets: [\n                    \"[\",\n                    \"]\"\n                ]\n            }\n        },\n        {\n            selector: \"main\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"nav\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"ol\",\n            format: \"orderedList\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"p\",\n            format: \"paragraph\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"pre\",\n            format: \"pre\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"section\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"table\",\n            format: \"table\",\n            options: {\n                colSpacing: 3,\n                leadingLineBreaks: 2,\n                maxColumnWidth: 60,\n                rowSpacing: 0,\n                trailingLineBreaks: 2,\n                uppercaseHeaderCells: true\n            }\n        },\n        {\n            selector: \"ul\",\n            format: \"unorderedList\",\n            options: {\n                itemPrefix: \" * \",\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"wbr\",\n            format: \"wbr\"\n        }\n    ],\n    tables: [],\n    whitespaceCharacters: \" \t\\r\\n\\f\",\n    wordwrap: 80\n};\nconst concatMerge = (acc, src, options)=>[\n        ...acc,\n        ...src\n    ];\nconst overwriteMerge = (acc, src, options)=>[\n        ...src\n    ];\nconst selectorsMerge = (acc, src, options)=>acc.some((s)=>typeof s === \"object\") ? concatMerge(acc, src) // selectors\n     : overwriteMerge(acc, src) // baseElements.selectors\n;\n/**\n * Preprocess options, compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options.\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */ function compile(options = {}) {\n    options = merge__default[\"default\"](DEFAULT_OPTIONS, options, {\n        arrayMerge: overwriteMerge,\n        customMerge: (key)=>key === \"selectors\" ? selectorsMerge : undefined\n    });\n    options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);\n    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s)=>s.selector);\n    handleDeprecatedOptions(options);\n    return compile$1(options);\n}\n/**\n * Convert given HTML content to plain text string.\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.\n * @returns { string }                 Plain text string.\n * @static\n *\n * @example\n * const { convert } = require('html-to-text');\n * const text = convert('<h1>Hello World</h1>', {\n *   wordwrap: 130\n * });\n * console.log(text); // HELLO WORLD\n */ function convert(html, options = {}, metadata = undefined) {\n    return compile(options)(html, metadata);\n}\n/**\n * Map previously existing and now deprecated options to the new options layout.\n * This is a subject for cleanup in major releases.\n *\n * @param { Options } options HtmlToText options.\n */ function handleDeprecatedOptions(options) {\n    if (options.tags) {\n        const tagDefinitions = Object.entries(options.tags).map(([selector, definition])=>({\n                ...definition,\n                selector: selector || \"*\"\n            }));\n        options.selectors.push(...tagDefinitions);\n        options.selectors = mergeDuplicatesPreferLast(options.selectors, (s)=>s.selector);\n    }\n    function set(obj, path, value) {\n        const valueKey = path.pop();\n        for (const key of path){\n            let nested = obj[key];\n            if (!nested) {\n                nested = {};\n                obj[key] = nested;\n            }\n            obj = nested;\n        }\n        obj[valueKey] = value;\n    }\n    if (options[\"baseElement\"]) {\n        const baseElement = options[\"baseElement\"];\n        set(options, [\n            \"baseElements\",\n            \"selectors\"\n        ], Array.isArray(baseElement) ? baseElement : [\n            baseElement\n        ]);\n    }\n    if (options[\"returnDomByDefault\"] !== undefined) {\n        set(options, [\n            \"baseElements\",\n            \"returnDomByDefault\"\n        ], options[\"returnDomByDefault\"]);\n    }\n    for (const definition of options.selectors){\n        if (definition.format === \"anchor\" && get(definition, [\n            \"options\",\n            \"noLinkBrackets\"\n        ])) {\n            set(definition, [\n                \"options\",\n                \"linkBrackets\"\n            ], false);\n        }\n    }\n}\nexports.compile = compile;\nexports.convert = convert;\nexports.htmlToText = convert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2h0bWwtdG8tdGV4dC9saWIvaHRtbC10by10ZXh0LmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBQ2hDLElBQUlDLGNBQWNELG1CQUFPQSxDQUFDO0FBQzFCLElBQUlFLFdBQVdGLG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlHLFFBQVFILG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlJLGdCQUFnQkosbUJBQU9BLENBQUM7QUFFNUIsU0FBU0ssc0JBQXVCQyxDQUFDO0lBQUksT0FBT0EsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBYUEsSUFBSUEsSUFBSTtRQUFFLFdBQVdBO0lBQUU7QUFBRztBQUVqSCxJQUFJQyxpQkFBaUIsV0FBVyxHQUFFRixzQkFBc0JGO0FBRXhEOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNLLHNCQUF1QkMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLElBQUksSUFBTUMsU0FBUztJQUN2RCxJQUFJSCxNQUFNRyxXQUFXO1FBQ25CLE1BQU1DLEtBQUssU0FBVSxHQUFHQyxJQUFJO1lBQUksT0FBT0osRUFBRUcsT0FBT0M7UUFBTztRQUN2RCxPQUFPRDtJQUNUO0lBQ0EsSUFBSUosS0FBSyxHQUFHO1FBQ1YsT0FBTyxTQUFVLEdBQUdLLElBQUk7WUFBSSxPQUFPSixFQUFFRixzQkFBc0JDLElBQUksR0FBR0MsR0FBR0MsT0FBT0c7UUFBTztJQUNyRjtJQUNBLE9BQU9IO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0ksY0FBZUMsR0FBRyxFQUFFQyxJQUFJO0lBQy9CLElBQUlDLFFBQVE7SUFDWixJQUFJQyxNQUFNSCxJQUFJSSxNQUFNO0lBQ3BCLE1BQU9GLFFBQVFDLE9BQU9ILEdBQUcsQ0FBQ0UsTUFBTSxLQUFLRCxLQUFNO1FBQUUsRUFBRUM7SUFBTztJQUN0RCxNQUFPQyxNQUFNRCxT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O2dCQUFXO2FBQWUsRUFBRTtRQUMvQztJQUNGO0FBQ0Y7QUFFQWxiLGVBQWUsR0FBRzJhO0FBQ2xCM2EsZUFBZSxHQUFHK2E7QUFDbEIvYSxrQkFBa0IsR0FBRythIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwtY2xpZW50Ly4uL25vZGVfbW9kdWxlcy9odG1sLXRvLXRleHQvbGliL2h0bWwtdG8tdGV4dC5janM/MzhkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBwbHVnaW5IdG1scGFyc2VyMiA9IHJlcXVpcmUoJ0BzZWxkZXJlZS9wbHVnaW4taHRtbHBhcnNlcjInKTtcbnZhciBodG1scGFyc2VyMiA9IHJlcXVpcmUoJ2h0bWxwYXJzZXIyJyk7XG52YXIgc2VsZGVyZWUgPSByZXF1aXJlKCdzZWxkZXJlZScpO1xudmFyIG1lcmdlID0gcmVxdWlyZSgnZGVlcG1lcmdlJyk7XG52YXIgZG9tU2VyaWFsaXplciA9IHJlcXVpcmUoJ2RvbS1zZXJpYWxpemVyJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgbWVyZ2VfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KG1lcmdlKTtcblxuLyoqXG4gKiBNYWtlIGEgcmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IHJ1biB0byBhIGdpdmVuIGRlcHRoXG4gKiBhbmQgc3dpdGNoZXMgdG8gYW4gYWx0ZXJuYXRpdmUgZnVuY3Rpb24gYXQgdGhhdCBkZXB0aC4gXFxcbiAqIE5vIGxpbWl0YXRpb24gaWYgYG5gIGlzIGB1bmRlZmluZWRgIChKdXN0IHdyYXBzIGBmYCBpbiB0aGF0IGNhc2UpLlxuICpcbiAqIEBwYXJhbSAgIHsgbnVtYmVyIHwgdW5kZWZpbmVkIH0gbiAgIEFsbG93ZWQgZGVwdGggb2YgcmVjdXJzaW9uLiBgdW5kZWZpbmVkYCBmb3Igbm8gbGltaXRhdGlvbi5cbiAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSAgICAgICAgICAgZiAgIEZ1bmN0aW9uIHRoYXQgYWNjZXB0cyByZWN1cnNpdmUgY2FsbGJhY2sgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICogQHBhcmFtICAgeyBGdW5jdGlvbiB9ICAgICAgICAgICBbZ10gRnVuY3Rpb24gdG8gcnVuIGluc3RlYWQsIHdoZW4gbWF4aW11bSBkZXB0aCB3YXMgcmVhY2hlZC4gRG8gbm90aGluZyBieSBkZWZhdWx0LlxuICogQHJldHVybnMgeyBGdW5jdGlvbiB9XG4gKi9cbmZ1bmN0aW9uIGxpbWl0ZWREZXB0aFJlY3Vyc2l2ZSAobiwgZiwgZyA9ICgpID0+IHVuZGVmaW5lZCkge1xuICBpZiAobiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZjEgPSBmdW5jdGlvbiAoLi4uYXJncykgeyByZXR1cm4gZihmMSwgLi4uYXJncyk7IH07XG4gICAgcmV0dXJuIGYxO1xuICB9XG4gIGlmIChuID49IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHsgcmV0dXJuIGYobGltaXRlZERlcHRoUmVjdXJzaXZlKG4gLSAxLCBmLCBnKSwgLi4uYXJncyk7IH07XG4gIH1cbiAgcmV0dXJuIGc7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHN0cmluZyBvciBhIHN1YnN0cmluZyB3aXRoXG4gKiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIG9jY3VycmVuY2VzIHJlbW92ZWQgZnJvbSBlYWNoIHNpZGUuXG4gKlxuICogQHBhcmFtICAgeyBzdHJpbmcgfSBzdHIgIEEgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9IGNoYXIgQSBjaGFyYWN0ZXIgdG8gYmUgdHJpbW1lZC5cbiAqIEByZXR1cm5zIHsgc3RyaW5nIH1cbiAqL1xuZnVuY3Rpb24gdHJpbUNoYXJhY3RlciAoc3RyLCBjaGFyKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBzdHIubGVuZ3RoO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgc3RyW3N0YXJ0XSA9PT0gY2hhcikgeyArK3N0YXJ0OyB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBzdHJbZW5kIC0gMV0gPT09IGNoYXIpIHsgLS1lbmQ7IH1cbiAgcmV0dXJuIChzdGFydCA+IDAgfHwgZW5kIDwgc3RyLmxlbmd0aClcbiAgICA/IHN0ci5zdWJzdHJpbmcoc3RhcnQsIGVuZClcbiAgICA6IHN0cjtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNhbWUgc3RyaW5nIG9yIGEgc3Vic3RyaW5nIHdpdGhcbiAqIHRoZSBnaXZlbiBjaGFyYWN0ZXIgb2NjdXJyZW5jZXMgcmVtb3ZlZCBmcm9tIHRoZSBlbmQgb25seS5cbiAqXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9IHN0ciAgQSBzdHJpbmcgdG8gdHJpbS5cbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gY2hhciBBIGNoYXJhY3RlciB0byBiZSB0cmltbWVkLlxuICogQHJldHVybnMgeyBzdHJpbmcgfVxuICovXG5mdW5jdGlvbiB0cmltQ2hhcmFjdGVyRW5kIChzdHIsIGNoYXIpIHtcbiAgbGV0IGVuZCA9IHN0ci5sZW5ndGg7XG4gIHdoaWxlIChlbmQgPiAwICYmIHN0cltlbmQgLSAxXSA9PT0gY2hhcikgeyAtLWVuZDsgfVxuICByZXR1cm4gKGVuZCA8IHN0ci5sZW5ndGgpXG4gICAgPyBzdHIuc3Vic3RyaW5nKDAsIGVuZClcbiAgICA6IHN0cjtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgc3RyaW5nIHdpbGwgYWxsIGNoYXJhY3RlcnMgcmVwbGFjZWQgd2l0aCB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZXMuXG4gKiBUaGlzIGV4dHJlbWUga2luZCBvZiBlc2NhcGluZyBjYW4gdXNlZCB0byBiZSBzYWZlbHkgY29tcG9zZSByZWd1bGFyIGV4cHJlc3Npb25zLlxuICpcbiAqIEBwYXJhbSB7IHN0cmluZyB9IHN0ciBBIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7IHN0cmluZyB9IEEgc3RyaW5nIG9mIHVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlcy5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZUVzY2FwZSAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcc1xcU10vZywgYyA9PiAnXFxcXHUnICsgYy5jaGFyQ29kZUF0KCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDQsICcwJykpO1xufVxuXG4vKipcbiAqIERlZHVwbGljYXRlIGFuIGFycmF5IGJ5IGEgZ2l2ZW4ga2V5IGNhbGxiYWNrLlxuICogSXRlbSBwcm9wZXJ0aWVzIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkgYW5kIHdpdGggdGhlIHByZWZlcmVuY2UgZm9yIGxhc3QgZGVmaW5lZCB2YWx1ZXMuXG4gKiBPZiBpdGVtcyB3aXRoIHRoZSBzYW1lIGtleSwgbWVyZ2VkIGl0ZW0gdGFrZXMgdGhlIHBsYWNlIG9mIHRoZSBsYXN0IGl0ZW0sXG4gKiBvdGhlcnMgYXJlIG9taXR0ZWQuXG4gKlxuICogQHBhcmFtIHsgYW55W10gfSBpdGVtcyBBbiBhcnJheSB0byBkZWR1cGxpY2F0ZS5cbiAqIEBwYXJhbSB7ICh4OiBhbnkpID0+IHN0cmluZyB9IGdldEtleSBDYWxsYmFjayB0byBnZXQgYSB2YWx1ZSB0aGF0IGRpc3Rpbmd1aXNoZXMgdW5pcXVlIGl0ZW1zLlxuICogQHJldHVybnMgeyBhbnlbXSB9XG4gKi9cbmZ1bmN0aW9uIG1lcmdlRHVwbGljYXRlc1ByZWZlckxhc3QgKGl0ZW1zLCBnZXRLZXkpIHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICBmb3IgKGxldCBpID0gaXRlbXMubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoaXRlbSk7XG4gICAgbWFwLnNldChcbiAgICAgIGtleSxcbiAgICAgIChtYXAuaGFzKGtleSkpXG4gICAgICAgID8gbWVyZ2VfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGl0ZW0sIG1hcC5nZXQoa2V5KSwgeyBhcnJheU1lcmdlOiBvdmVyd3JpdGVNZXJnZSQxIH0pXG4gICAgICAgIDogaXRlbVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIFsuLi5tYXAudmFsdWVzKCldLnJldmVyc2UoKTtcbn1cblxuY29uc3Qgb3ZlcndyaXRlTWVyZ2UkMSA9IChhY2MsIHNyYywgb3B0aW9ucykgPT4gWy4uLnNyY107XG5cbi8qKlxuICogR2V0IGEgbmVzdGVkIHByb3BlcnR5IGZyb20gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAgIHsgb2JqZWN0IH0gICBvYmogIFRoZSBvYmplY3QgdG8gcXVlcnkgZm9yIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSAgIHsgc3RyaW5nW10gfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHsgYW55IH1cbiAqL1xuZnVuY3Rpb24gZ2V0IChvYmosIHBhdGgpIHtcbiAgZm9yIChjb25zdCBrZXkgb2YgcGF0aCkge1xuICAgIGlmICghb2JqKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICBvYmogPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgaW50byBhbHBoYWJldGljIHNlcXVlbmNlIHJlcHJlc2VudGF0aW9uIChTZXF1ZW5jZSB3aXRob3V0IHplcm9lcykuXG4gKlxuICogRm9yIGV4YW1wbGU6IGBhLCAuLi4sIHosIGFhLCAuLi4sIHp6LCBhYWEsIC4uLmAuXG4gKlxuICogQHBhcmFtICAgeyBudW1iZXIgfSBudW0gICAgICAgICAgICAgIE51bWJlciB0byBjb252ZXJ0LiBNdXN0IGJlID49IDEuXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9IFtiYXNlQ2hhciA9ICdhJ10gQ2hhcmFjdGVyIGZvciAxIGluIHRoZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSAgIHsgbnVtYmVyIH0gW2Jhc2UgPSAyNl0gICAgICBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcmV0dXJucyB7IHN0cmluZyB9XG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvTGV0dGVyU2VxdWVuY2UgKG51bSwgYmFzZUNoYXIgPSAnYScsIGJhc2UgPSAyNikge1xuICBjb25zdCBkaWdpdHMgPSBbXTtcbiAgZG8ge1xuICAgIG51bSAtPSAxO1xuICAgIGRpZ2l0cy5wdXNoKG51bSAlIGJhc2UpO1xuICAgIG51bSA9IChudW0gLyBiYXNlKSA+PiAwOyAvLyBxdWljayBgZmxvb3JgXG4gIH0gd2hpbGUgKG51bSA+IDApO1xuICBjb25zdCBiYXNlQ29kZSA9IGJhc2VDaGFyLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBkaWdpdHNcbiAgICAucmV2ZXJzZSgpXG4gICAgLm1hcChuID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFzZUNvZGUgKyBuKSlcbiAgICAuam9pbignJyk7XG59XG5cbmNvbnN0IEkgPSBbJ0knLCAnWCcsICdDJywgJ00nXTtcbmNvbnN0IFYgPSBbJ1YnLCAnTCcsICdEJ107XG5cbi8qKlxuICogQ29udmVydCBhIG51bWJlciB0byBpdCdzIFJvbWFuIHJlcHJlc2VudGF0aW9uLiBObyBsYXJnZSBudW1iZXJzIGV4dGVuc2lvbi5cbiAqXG4gKiBAcGFyYW0gICB7IG51bWJlciB9IG51bSBOdW1iZXIgdG8gY29udmVydC4gYDAgPCBudW0gPD0gMzk5OWAuXG4gKiBAcmV0dXJucyB7IHN0cmluZyB9XG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvUm9tYW4gKG51bSkge1xuICByZXR1cm4gWy4uLihudW0pICsgJyddXG4gICAgLm1hcChuID0+ICtuKVxuICAgIC5yZXZlcnNlKClcbiAgICAubWFwKCh2LCBpKSA9PiAoKHYgJSA1IDwgNClcbiAgICAgID8gKHYgPCA1ID8gJycgOiBWW2ldKSArIElbaV0ucmVwZWF0KHYgJSA1KVxuICAgICAgOiBJW2ldICsgKHYgPCA1ID8gVltpXSA6IElbaSArIDFdKSkpXG4gICAgLnJldmVyc2UoKVxuICAgIC5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBIZWxwcyB0byBidWlsZCB0ZXh0IGZyb20gd29yZHMuXG4gKi9cbmNsYXNzIElubGluZVRleHRCdWlsZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgSW5saW5lVGV4dEJ1aWxkZXIuXG4gICAqXG4gICAqIElmIGBtYXhMaW5lTGVuZ3RoYCBpcyBub3QgcHJvdmlkZWQgdGhlbiBpdCBpcyBlaXRoZXIgYG9wdGlvbnMud29yZHdyYXBgIG9yIHVubGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHsgT3B0aW9ucyB9IG9wdGlvbnMgICAgICAgICAgIEh0bWxUb1RleHQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gIFsgbWF4TGluZUxlbmd0aCBdIFRoaXMgYnVpbGRlciB3aWxsIHRyeSB0byB3cmFwIHRleHQgdG8gZml0IHRoaXMgbGluZSBsZW5ndGguXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucywgbWF4TGluZUxlbmd0aCA9IHVuZGVmaW5lZCkge1xuICAgIC8qKiBAdHlwZSB7IHN0cmluZ1tdW10gfSAqL1xuICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAvKiogQHR5cGUgeyBzdHJpbmdbXSB9ICAgKi9cbiAgICB0aGlzLm5leHRMaW5lV29yZHMgPSBbXTtcbiAgICB0aGlzLm1heExpbmVMZW5ndGggPSBtYXhMaW5lTGVuZ3RoIHx8IG9wdGlvbnMud29yZHdyYXAgfHwgTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0aGlzLm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMgPSB0aGlzLm1heExpbmVMZW5ndGg7XG4gICAgdGhpcy53cmFwQ2hhcmFjdGVycyA9IGdldChvcHRpb25zLCBbJ2xvbmdXb3JkU3BsaXQnLCAnd3JhcENoYXJhY3RlcnMnXSkgfHwgW107XG4gICAgdGhpcy5mb3JjZVdyYXBPbkxpbWl0ID0gZ2V0KG9wdGlvbnMsIFsnbG9uZ1dvcmRTcGxpdCcsICdmb3JjZVdyYXBPbkxpbWl0J10pIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5zdGFzaGVkU3BhY2UgPSBmYWxzZTtcbiAgICB0aGlzLndvcmRCcmVha09wcG9ydHVuaXR5ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHdvcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7IHN0cmluZyB9IHdvcmQgQSB3b3JkIHRvIGFkZC5cbiAgICogQHBhcmFtIHsgYm9vbGVhbiB9IFtub1dyYXBdIERvbid0IHdyYXAgdGV4dCBldmVuIGlmIHRoZSBsaW5lIGlzIHRvbyBsb25nLlxuICAgKi9cbiAgcHVzaFdvcmQgKHdvcmQsIG5vV3JhcCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMubmV4dExpbmVBdmFpbGFibGVDaGFycyA8PSAwICYmICFub1dyYXApIHtcbiAgICAgIHRoaXMuc3RhcnROZXdMaW5lKCk7XG4gICAgfVxuICAgIGNvbnN0IGlzTGluZVN0YXJ0ID0gdGhpcy5uZXh0TGluZVdvcmRzLmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBjb3N0ID0gd29yZC5sZW5ndGggKyAoaXNMaW5lU3RhcnQgPyAwIDogMSk7XG4gICAgaWYgKChjb3N0IDw9IHRoaXMubmV4dExpbmVBdmFpbGFibGVDaGFycykgfHwgbm9XcmFwKSB7IC8vIEZpdHMgaW50byBhdmFpbGFibGUgYnVkZ2V0XG5cbiAgICAgIHRoaXMubmV4dExpbmVXb3Jkcy5wdXNoKHdvcmQpO1xuICAgICAgdGhpcy5uZXh0TGluZUF2YWlsYWJsZUNoYXJzIC09IGNvc3Q7XG5cbiAgICB9IGVsc2UgeyAvLyBEb2VzIG5vdCBmaXQgLSB0cnkgdG8gc3BsaXQgdGhlIHdvcmRcblxuICAgICAgLy8gVGhlIHdvcmQgaXMgbW92ZWQgdG8gYSBuZXcgbGluZSAtIHByZWZlciB0byB3cmFwIGJldHdlZW4gd29yZHMuXG4gICAgICBjb25zdCBbZmlyc3QsIC4uLnJlc3RdID0gdGhpcy5zcGxpdExvbmdXb3JkKHdvcmQpO1xuICAgICAgaWYgKCFpc0xpbmVTdGFydCkgeyB0aGlzLnN0YXJ0TmV3TGluZSgpOyB9XG4gICAgICB0aGlzLm5leHRMaW5lV29yZHMucHVzaChmaXJzdCk7XG4gICAgICB0aGlzLm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMgLT0gZmlyc3QubGVuZ3RoO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHJlc3QpIHtcbiAgICAgICAgdGhpcy5zdGFydE5ld0xpbmUoKTtcbiAgICAgICAgdGhpcy5uZXh0TGluZVdvcmRzLnB1c2gocGFydCk7XG4gICAgICAgIHRoaXMubmV4dExpbmVBdmFpbGFibGVDaGFycyAtPSBwYXJ0Lmxlbmd0aDtcbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQb3AgYSB3b3JkIGZyb20gdGhlIGN1cnJlbnRseSBidWlsdCBsaW5lLlxuICAgKiBUaGlzIGRvZXNuJ3QgYWZmZWN0IGNvbXBsZXRlZCBsaW5lcy5cbiAgICpcbiAgICogQHJldHVybnMgeyBzdHJpbmcgfVxuICAgKi9cbiAgcG9wV29yZCAoKSB7XG4gICAgY29uc3QgbGFzdFdvcmQgPSB0aGlzLm5leHRMaW5lV29yZHMucG9wKCk7XG4gICAgaWYgKGxhc3RXb3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGlzTGluZVN0YXJ0ID0gdGhpcy5uZXh0TGluZVdvcmRzLmxlbmd0aCA9PT0gMDtcbiAgICAgIGNvbnN0IGNvc3QgPSBsYXN0V29yZC5sZW5ndGggKyAoaXNMaW5lU3RhcnQgPyAwIDogMSk7XG4gICAgICB0aGlzLm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMgKz0gY29zdDtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RXb3JkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmNhdCBhIHdvcmQgdG8gdGhlIGxhc3Qgd29yZCBhbHJlYWR5IGluIHRoZSBidWlsZGVyLlxuICAgKiBBZGRzIGEgbmV3IHdvcmQgaW4gY2FzZSB0aGVyZSBhcmUgbm8gd29yZHMgeWV0IGluIHRoZSBsYXN0IGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7IHN0cmluZyB9IHdvcmQgQSB3b3JkIHRvIGJlIGNvbmNhdGVuYXRlZC5cbiAgICogQHBhcmFtIHsgYm9vbGVhbiB9IFtub1dyYXBdIERvbid0IHdyYXAgdGV4dCBldmVuIGlmIHRoZSBsaW5lIGlzIHRvbyBsb25nLlxuICAgKi9cbiAgY29uY2F0V29yZCAod29yZCwgbm9XcmFwID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy53b3JkQnJlYWtPcHBvcnR1bml0eSAmJiB3b3JkLmxlbmd0aCA+IHRoaXMubmV4dExpbmVBdmFpbGFibGVDaGFycykge1xuICAgICAgdGhpcy5wdXNoV29yZCh3b3JkLCBub1dyYXApO1xuICAgICAgdGhpcy53b3JkQnJlYWtPcHBvcnR1bml0eSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0V29yZCA9IHRoaXMucG9wV29yZCgpO1xuICAgICAgdGhpcy5wdXNoV29yZCgobGFzdFdvcmQpID8gbGFzdFdvcmQuY29uY2F0KHdvcmQpIDogd29yZCwgbm9XcmFwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGN1cnJlbnQgbGluZSAoYW5kIG1vcmUgZW1wdHkgbGluZXMgaWYgcHJvdmlkZWQgYXJndW1lbnQgPiAxKSB0byB0aGUgbGlzdCBvZiBjb21wbGV0ZSBsaW5lcyBhbmQgc3RhcnQgYSBuZXcgb25lLlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBuIE51bWJlciBvZiBsaW5lIGJyZWFrcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gICAqL1xuICBzdGFydE5ld0xpbmUgKG4gPSAxKSB7XG4gICAgdGhpcy5saW5lcy5wdXNoKHRoaXMubmV4dExpbmVXb3Jkcyk7XG4gICAgaWYgKG4gPiAxKSB7XG4gICAgICB0aGlzLmxpbmVzLnB1c2goLi4uQXJyYXkuZnJvbSh7IGxlbmd0aDogbiAtIDEgfSwgKCkgPT4gW10pKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0TGluZVdvcmRzID0gW107XG4gICAgdGhpcy5uZXh0TGluZUF2YWlsYWJsZUNoYXJzID0gdGhpcy5tYXhMaW5lTGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vIHdvcmRzIGluIHRoaXMgYnVpbGRlci5cbiAgICpcbiAgICogQHJldHVybnMgeyBib29sZWFuIH1cbiAgICovXG4gIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVzLmxlbmd0aCA9PT0gMFxuICAgICAgICAmJiB0aGlzLm5leHRMaW5lV29yZHMubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMubGluZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm5leHRMaW5lV29yZHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMgPSB0aGlzLm1heExpbmVMZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogSm9pbiBhbGwgbGluZXMgb2Ygd29yZHMgaW5zaWRlIHRoZSBJbmxpbmVUZXh0QnVpbGRlciBpbnRvIGEgY29tcGxldGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7IHN0cmluZyB9XG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmxpbmVzLCB0aGlzLm5leHRMaW5lV29yZHNdXG4gICAgICAubWFwKHdvcmRzID0+IHdvcmRzLmpvaW4oJyAnKSlcbiAgICAgIC5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBhIGxvbmcgd29yZCB1cCB0byBmaXQgd2l0aGluIHRoZSB3b3JkIHdyYXAgbGltaXQuXG4gICAqIFVzZSBlaXRoZXIgYSBjaGFyYWN0ZXIgdG8gc3BsaXQgbG9va2luZyBiYWNrIGZyb20gdGhlIHdvcmQgd3JhcCBsaW1pdCxcbiAgICogb3IgdHJ1bmNhdGUgdG8gdGhlIHdvcmQgd3JhcCBsaW1pdC5cbiAgICpcbiAgICogQHBhcmFtICAgeyBzdHJpbmcgfSAgIHdvcmQgSW5wdXQgd29yZC5cbiAgICogQHJldHVybnMgeyBzdHJpbmdbXSB9ICAgICAgUGFydHMgb2YgdGhlIHdvcmQuXG4gICAqL1xuICBzcGxpdExvbmdXb3JkICh3b3JkKSB7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICB3aGlsZSAod29yZC5sZW5ndGggPiB0aGlzLm1heExpbmVMZW5ndGgpIHtcblxuICAgICAgY29uc3QgZmlyc3RMaW5lID0gd29yZC5zdWJzdHJpbmcoMCwgdGhpcy5tYXhMaW5lTGVuZ3RoKTtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0NoYXJzID0gd29yZC5zdWJzdHJpbmcodGhpcy5tYXhMaW5lTGVuZ3RoKTtcblxuICAgICAgY29uc3Qgc3BsaXRJbmRleCA9IGZpcnN0TGluZS5sYXN0SW5kZXhPZih0aGlzLndyYXBDaGFyYWN0ZXJzW2lkeF0pO1xuXG4gICAgICBpZiAoc3BsaXRJbmRleCA+IC0xKSB7IC8vIEZvdW5kIGEgY2hhcmFjdGVyIHRvIHNwbGl0IG9uXG5cbiAgICAgICAgd29yZCA9IGZpcnN0TGluZS5zdWJzdHJpbmcoc3BsaXRJbmRleCArIDEpICsgcmVtYWluaW5nQ2hhcnM7XG4gICAgICAgIHBhcnRzLnB1c2goZmlyc3RMaW5lLnN1YnN0cmluZygwLCBzcGxpdEluZGV4ICsgMSkpO1xuXG4gICAgICB9IGVsc2UgeyAvLyBOb3QgZm91bmQgYSBjaGFyYWN0ZXIgdG8gc3BsaXQgb25cblxuICAgICAgICBpZHgrKztcbiAgICAgICAgaWYgKGlkeCA8IHRoaXMud3JhcENoYXJhY3RlcnMubGVuZ3RoKSB7IC8vIFRoZXJlIGlzIG5leHQgY2hhcmFjdGVyIHRvIHRyeVxuXG4gICAgICAgICAgd29yZCA9IGZpcnN0TGluZSArIHJlbWFpbmluZ0NoYXJzO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIE5vIG1vcmUgY2hhcmFjdGVycyB0byB0cnlcblxuICAgICAgICAgIGlmICh0aGlzLmZvcmNlV3JhcE9uTGltaXQpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goZmlyc3RMaW5lKTtcbiAgICAgICAgICAgIHdvcmQgPSByZW1haW5pbmdDaGFycztcbiAgICAgICAgICAgIGlmICh3b3JkLmxlbmd0aCA+IHRoaXMubWF4TGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29yZCA9IGZpcnN0TGluZSArIHJlbWFpbmluZ0NoYXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cbiAgICBwYXJ0cy5wdXNoKHdvcmQpOyAvLyBBZGQgcmVtYWluaW5nIHBhcnQgdG8gYXJyYXlcbiAgICByZXR1cm4gcGFydHM7XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cblxuXG5jbGFzcyBTdGFja0l0ZW0ge1xuICBjb25zdHJ1Y3RvciAobmV4dCA9IG51bGwpIHsgdGhpcy5uZXh0ID0gbmV4dDsgfVxuXG4gIGdldFJvb3QgKCkgeyByZXR1cm4gKHRoaXMubmV4dCkgPyB0aGlzLm5leHQgOiB0aGlzOyB9XG59XG5cbmNsYXNzIEJsb2NrU3RhY2tJdGVtIGV4dGVuZHMgU3RhY2tJdGVtIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMsIG5leHQgPSBudWxsLCBsZWFkaW5nTGluZUJyZWFrcyA9IDEsIG1heExpbmVMZW5ndGggPSB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihuZXh0KTtcbiAgICB0aGlzLmxlYWRpbmdMaW5lQnJlYWtzID0gbGVhZGluZ0xpbmVCcmVha3M7XG4gICAgdGhpcy5pbmxpbmVUZXh0QnVpbGRlciA9IG5ldyBJbmxpbmVUZXh0QnVpbGRlcihvcHRpb25zLCBtYXhMaW5lTGVuZ3RoKTtcbiAgICB0aGlzLnJhd1RleHQgPSAnJztcbiAgICB0aGlzLnN0YXNoZWRMaW5lQnJlYWtzID0gMDtcbiAgICB0aGlzLmlzUHJlID0gbmV4dCAmJiBuZXh0LmlzUHJlO1xuICAgIHRoaXMuaXNOb1dyYXAgPSBuZXh0ICYmIG5leHQuaXNOb1dyYXA7XG4gIH1cbn1cblxuY2xhc3MgTGlzdFN0YWNrSXRlbSBleHRlbmRzIEJsb2NrU3RhY2tJdGVtIHtcbiAgY29uc3RydWN0b3IgKFxuICAgIG9wdGlvbnMsXG4gICAgbmV4dCA9IG51bGwsXG4gICAge1xuICAgICAgaW50ZXJSb3dMaW5lQnJlYWtzID0gMSxcbiAgICAgIGxlYWRpbmdMaW5lQnJlYWtzID0gMixcbiAgICAgIG1heExpbmVMZW5ndGggPSB1bmRlZmluZWQsXG4gICAgICBtYXhQcmVmaXhMZW5ndGggPSAwLFxuICAgICAgcHJlZml4QWxpZ24gPSAnbGVmdCcsXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHN1cGVyKG9wdGlvbnMsIG5leHQsIGxlYWRpbmdMaW5lQnJlYWtzLCBtYXhMaW5lTGVuZ3RoKTtcbiAgICB0aGlzLm1heFByZWZpeExlbmd0aCA9IG1heFByZWZpeExlbmd0aDtcbiAgICB0aGlzLnByZWZpeEFsaWduID0gcHJlZml4QWxpZ247XG4gICAgdGhpcy5pbnRlclJvd0xpbmVCcmVha3MgPSBpbnRlclJvd0xpbmVCcmVha3M7XG4gIH1cbn1cblxuY2xhc3MgTGlzdEl0ZW1TdGFja0l0ZW0gZXh0ZW5kcyBCbG9ja1N0YWNrSXRlbSB7XG4gIGNvbnN0cnVjdG9yIChcbiAgICBvcHRpb25zLFxuICAgIG5leHQgPSBudWxsLFxuICAgIHtcbiAgICAgIGxlYWRpbmdMaW5lQnJlYWtzID0gMSxcbiAgICAgIG1heExpbmVMZW5ndGggPSB1bmRlZmluZWQsXG4gICAgICBwcmVmaXggPSAnJyxcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIob3B0aW9ucywgbmV4dCwgbGVhZGluZ0xpbmVCcmVha3MsIG1heExpbmVMZW5ndGgpO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICB9XG59XG5cbmNsYXNzIFRhYmxlU3RhY2tJdGVtIGV4dGVuZHMgU3RhY2tJdGVtIHtcbiAgY29uc3RydWN0b3IgKG5leHQgPSBudWxsKSB7XG4gICAgc3VwZXIobmV4dCk7XG4gICAgdGhpcy5yb3dzID0gW107XG4gICAgdGhpcy5pc1ByZSA9IG5leHQgJiYgbmV4dC5pc1ByZTtcbiAgICB0aGlzLmlzTm9XcmFwID0gbmV4dCAmJiBuZXh0LmlzTm9XcmFwO1xuICB9XG59XG5cbmNsYXNzIFRhYmxlUm93U3RhY2tJdGVtIGV4dGVuZHMgU3RhY2tJdGVtIHtcbiAgY29uc3RydWN0b3IgKG5leHQgPSBudWxsKSB7XG4gICAgc3VwZXIobmV4dCk7XG4gICAgdGhpcy5jZWxscyA9IFtdO1xuICAgIHRoaXMuaXNQcmUgPSBuZXh0ICYmIG5leHQuaXNQcmU7XG4gICAgdGhpcy5pc05vV3JhcCA9IG5leHQgJiYgbmV4dC5pc05vV3JhcDtcbiAgfVxufVxuXG5jbGFzcyBUYWJsZUNlbGxTdGFja0l0ZW0gZXh0ZW5kcyBTdGFja0l0ZW0ge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucywgbmV4dCA9IG51bGwsIG1heENvbHVtbldpZHRoID0gdW5kZWZpbmVkKSB7XG4gICAgc3VwZXIobmV4dCk7XG4gICAgdGhpcy5pbmxpbmVUZXh0QnVpbGRlciA9IG5ldyBJbmxpbmVUZXh0QnVpbGRlcihvcHRpb25zLCBtYXhDb2x1bW5XaWR0aCk7XG4gICAgdGhpcy5yYXdUZXh0ID0gJyc7XG4gICAgdGhpcy5zdGFzaGVkTGluZUJyZWFrcyA9IDA7XG4gICAgdGhpcy5pc1ByZSA9IG5leHQgJiYgbmV4dC5pc1ByZTtcbiAgICB0aGlzLmlzTm9XcmFwID0gbmV4dCAmJiBuZXh0LmlzTm9XcmFwO1xuICB9XG59XG5cbmNsYXNzIFRyYW5zZm9ybWVyU3RhY2tJdGVtIGV4dGVuZHMgU3RhY2tJdGVtIHtcbiAgY29uc3RydWN0b3IgKG5leHQgPSBudWxsLCB0cmFuc2Zvcm0pIHtcbiAgICBzdXBlcihuZXh0KTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGFyYWN0ZXJzVG9Db2RlcyAoc3RyKSB7XG4gIHJldHVybiBbLi4uc3RyXVxuICAgIC5tYXAoYyA9PiAnXFxcXHUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg0LCAnMCcpKVxuICAgIC5qb2luKCcnKTtcbn1cblxuLyoqXG4gKiBIZWxwcyB0byBoYW5kbGUgSFRNTCB3aGl0ZXNwYWNlcy5cbiAqXG4gKiBAY2xhc3MgV2hpdGVzcGFjZVByb2Nlc3NvclxuICovXG5jbGFzcyBXaGl0ZXNwYWNlUHJvY2Vzc29yIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBXaGl0ZXNwYWNlUHJvY2Vzc29yLlxuICAgKlxuICAgKiBAcGFyYW0geyBPcHRpb25zIH0gb3B0aW9ucyAgICBIdG1sVG9UZXh0IG9wdGlvbnMuXG4gICAqIEBtZW1iZXJvZiBXaGl0ZXNwYWNlUHJvY2Vzc29yXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMud2hpdGVzcGFjZUNoYXJzID0gKG9wdGlvbnMucHJlc2VydmVOZXdsaW5lcylcbiAgICAgID8gb3B0aW9ucy53aGl0ZXNwYWNlQ2hhcmFjdGVycy5yZXBsYWNlKC9cXG4vZywgJycpXG4gICAgICA6IG9wdGlvbnMud2hpdGVzcGFjZUNoYXJhY3RlcnM7XG4gICAgY29uc3Qgd2hpdGVzcGFjZUNvZGVzID0gY2hhcmFjdGVyc1RvQ29kZXModGhpcy53aGl0ZXNwYWNlQ2hhcnMpO1xuICAgIHRoaXMubGVhZGluZ1doaXRlc3BhY2VSZSA9IG5ldyBSZWdFeHAoYF5bJHt3aGl0ZXNwYWNlQ29kZXN9XWApO1xuICAgIHRoaXMudHJhaWxpbmdXaGl0ZXNwYWNlUmUgPSBuZXcgUmVnRXhwKGBbJHt3aGl0ZXNwYWNlQ29kZXN9XSRgKTtcbiAgICB0aGlzLmFsbFdoaXRlc3BhY2VPckVtcHR5UmUgPSBuZXcgUmVnRXhwKGBeWyR7d2hpdGVzcGFjZUNvZGVzfV0qJGApO1xuICAgIHRoaXMubmV3bGluZU9yTm9uV2hpdGVzcGFjZVJlID0gbmV3IFJlZ0V4cChgKFxcXFxufFteXFxcXG4ke3doaXRlc3BhY2VDb2Rlc31dKWAsICdnJyk7XG4gICAgdGhpcy5uZXdsaW5lT3JOb25OZXdsaW5lU3RyaW5nUmUgPSBuZXcgUmVnRXhwKGAoXFxcXG58W15cXFxcbl0rKWAsICdnJyk7XG5cbiAgICBpZiAob3B0aW9ucy5wcmVzZXJ2ZU5ld2xpbmVzKSB7XG5cbiAgICAgIGNvbnN0IHdvcmRPck5ld2xpbmVSZSA9IG5ldyBSZWdFeHAoYFxcXFxufFteXFxcXG4ke3doaXRlc3BhY2VDb2Rlc31dK2AsICdnbScpO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNocmluayB3aGl0ZXNwYWNlcyBhbmQgd3JhcCB0ZXh0LCBhZGQgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsgc3RyaW5nIH0gICAgICAgICAgICAgICAgICB0ZXh0ICAgICAgICAgICAgICBJbnB1dCB0ZXh0LlxuICAgICAgICogQHBhcmFtIHsgSW5saW5lVGV4dEJ1aWxkZXIgfSAgICAgICBpbmxpbmVUZXh0QnVpbGRlciBBIGJ1aWxkZXIgdG8gcmVjZWl2ZSBwcm9jZXNzZWQgdGV4dC5cbiAgICAgICAqIEBwYXJhbSB7IChzdHI6IHN0cmluZykgPT4gc3RyaW5nIH0gWyB0cmFuc2Zvcm0gXSAgICAgQSB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB3b3Jkcy5cbiAgICAgICAqIEBwYXJhbSB7IGJvb2xlYW4gfSAgICAgICAgICAgICAgICAgW25vV3JhcF0gRG9uJ3Qgd3JhcCB0ZXh0IGV2ZW4gaWYgdGhlIGxpbmUgaXMgdG9vIGxvbmcuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuc2hyaW5rV3JhcEFkZCA9IGZ1bmN0aW9uICh0ZXh0LCBpbmxpbmVUZXh0QnVpbGRlciwgdHJhbnNmb3JtID0gKHN0ciA9PiBzdHIpLCBub1dyYXAgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRleHQpIHsgcmV0dXJuOyB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzbHlTdGFzaGVkU3BhY2UgPSBpbmxpbmVUZXh0QnVpbGRlci5zdGFzaGVkU3BhY2U7XG4gICAgICAgIGxldCBhbnlNYXRjaCA9IGZhbHNlO1xuICAgICAgICBsZXQgbSA9IHdvcmRPck5ld2xpbmVSZS5leGVjKHRleHQpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIGFueU1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAobVswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGlubGluZVRleHRCdWlsZGVyLnN0YXJ0TmV3TGluZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNseVN0YXNoZWRTcGFjZSB8fCB0aGlzLnRlc3RMZWFkaW5nV2hpdGVzcGFjZSh0ZXh0KSkge1xuICAgICAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIucHVzaFdvcmQodHJhbnNmb3JtKG1bMF0pLCBub1dyYXApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5jb25jYXRXb3JkKHRyYW5zZm9ybShtWzBdKSwgbm9XcmFwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKChtID0gd29yZE9yTmV3bGluZVJlLmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobVswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIuc3RhcnROZXdMaW5lKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5wdXNoV29yZCh0cmFuc2Zvcm0obVswXSksIG5vV3JhcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlubGluZVRleHRCdWlsZGVyLnN0YXNoZWRTcGFjZSA9IChwcmV2aW91c2x5U3Rhc2hlZFNwYWNlICYmICFhbnlNYXRjaCkgfHwgKHRoaXMudGVzdFRyYWlsaW5nV2hpdGVzcGFjZSh0ZXh0KSk7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc3Rhc2ggYSBzcGFjZSBpbiBjYXNlIGxhc3QgYWRkZWQgaXRlbSB3YXMgYSBuZXcgbGluZSxcbiAgICAgICAgLy8gYnV0IHRoYXQgd29uJ3QgYWZmZWN0IGFueXRoaW5nIGxhdGVyIGFueXdheS5cbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBjb25zdCB3b3JkUmUgPSBuZXcgUmVnRXhwKGBbXiR7d2hpdGVzcGFjZUNvZGVzfV0rYCwgJ2cnKTtcblxuICAgICAgdGhpcy5zaHJpbmtXcmFwQWRkID0gZnVuY3Rpb24gKHRleHQsIGlubGluZVRleHRCdWlsZGVyLCB0cmFuc2Zvcm0gPSAoc3RyID0+IHN0ciksIG5vV3JhcCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGV4dCkgeyByZXR1cm47IH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNseVN0YXNoZWRTcGFjZSA9IGlubGluZVRleHRCdWlsZGVyLnN0YXNoZWRTcGFjZTtcbiAgICAgICAgbGV0IGFueU1hdGNoID0gZmFsc2U7XG4gICAgICAgIGxldCBtID0gd29yZFJlLmV4ZWModGV4dCk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgYW55TWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2aW91c2x5U3Rhc2hlZFNwYWNlIHx8IHRoaXMudGVzdExlYWRpbmdXaGl0ZXNwYWNlKHRleHQpKSB7XG4gICAgICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5wdXNoV29yZCh0cmFuc2Zvcm0obVswXSksIG5vV3JhcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlubGluZVRleHRCdWlsZGVyLmNvbmNhdFdvcmQodHJhbnNmb3JtKG1bMF0pLCBub1dyYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKG0gPSB3b3JkUmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlubGluZVRleHRCdWlsZGVyLnB1c2hXb3JkKHRyYW5zZm9ybShtWzBdKSwgbm9XcmFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIuc3Rhc2hlZFNwYWNlID0gKHByZXZpb3VzbHlTdGFzaGVkU3BhY2UgJiYgIWFueU1hdGNoKSB8fCB0aGlzLnRlc3RUcmFpbGluZ1doaXRlc3BhY2UodGV4dCk7XG4gICAgICB9O1xuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0ZXh0IHdpdGggb25seSBtaW5pbWFsIHByb2Nlc3NpbmcuXG4gICAqIEV2ZXJ5dGhpbmcgYmV0d2VlbiBuZXdsaW5lcyBjb25zaWRlcmVkIGEgc2luZ2xlIHdvcmQuXG4gICAqIE5vIHdoaXRlc3BhY2UgaXMgdHJpbW1lZC5cbiAgICogTm90IGFmZmVjdGVkIGJ5IHByZXNlcnZlTmV3bGluZXMgb3B0aW9uIC0gYFxcbmAgYWx3YXlzIHN0YXJ0cyBhIG5ldyBsaW5lLlxuICAgKlxuICAgKiBgbm9XcmFwYCBhcmd1bWVudCBpcyBgdHJ1ZWAgYnkgZGVmYXVsdCAtIHRoaXMgd29uJ3Qgc3RhcnQgYSBuZXcgbGluZVxuICAgKiBldmVuIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgbGVmdCBpbiB0aGUgY3VycmVudCBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0geyBzdHJpbmcgfSAgICAgICAgICAgIHRleHQgICAgICAgICAgICAgIElucHV0IHRleHQuXG4gICAqIEBwYXJhbSB7IElubGluZVRleHRCdWlsZGVyIH0gaW5saW5lVGV4dEJ1aWxkZXIgQSBidWlsZGVyIHRvIHJlY2VpdmUgcHJvY2Vzc2VkIHRleHQuXG4gICAqIEBwYXJhbSB7IGJvb2xlYW4gfSAgICAgICAgICAgW25vV3JhcF0gRG9uJ3Qgd3JhcCB0ZXh0IGV2ZW4gaWYgdGhlIGxpbmUgaXMgdG9vIGxvbmcuXG4gICAqL1xuICBhZGRMaXRlcmFsICh0ZXh0LCBpbmxpbmVUZXh0QnVpbGRlciwgbm9XcmFwID0gdHJ1ZSkge1xuICAgIGlmICghdGV4dCkgeyByZXR1cm47IH1cbiAgICBjb25zdCBwcmV2aW91c2x5U3Rhc2hlZFNwYWNlID0gaW5saW5lVGV4dEJ1aWxkZXIuc3Rhc2hlZFNwYWNlO1xuICAgIGxldCBhbnlNYXRjaCA9IGZhbHNlO1xuICAgIGxldCBtID0gdGhpcy5uZXdsaW5lT3JOb25OZXdsaW5lU3RyaW5nUmUuZXhlYyh0ZXh0KTtcbiAgICBpZiAobSkge1xuICAgICAgYW55TWF0Y2ggPSB0cnVlO1xuICAgICAgaWYgKG1bMF0gPT09ICdcXG4nKSB7XG4gICAgICAgIGlubGluZVRleHRCdWlsZGVyLnN0YXJ0TmV3TGluZSgpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2aW91c2x5U3Rhc2hlZFNwYWNlKSB7XG4gICAgICAgIGlubGluZVRleHRCdWlsZGVyLnB1c2hXb3JkKG1bMF0sIG5vV3JhcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5jb25jYXRXb3JkKG1bMF0sIG5vV3JhcCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKG0gPSB0aGlzLm5ld2xpbmVPck5vbk5ld2xpbmVTdHJpbmdSZS5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobVswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5zdGFydE5ld0xpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5wdXNoV29yZChtWzBdLCBub1dyYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlubGluZVRleHRCdWlsZGVyLnN0YXNoZWRTcGFjZSA9IChwcmV2aW91c2x5U3Rhc2hlZFNwYWNlICYmICFhbnlNYXRjaCk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiB0ZXh0IHN0YXJ0cyB3aXRoIEhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gIHRleHQgIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAgICogQHJldHVybnMgeyBib29sZWFuIH1cbiAgICovXG4gIHRlc3RMZWFkaW5nV2hpdGVzcGFjZSAodGV4dCkge1xuICAgIHJldHVybiB0aGlzLmxlYWRpbmdXaGl0ZXNwYWNlUmUudGVzdCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHRleHQgZW5kcyB3aXRoIEhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gIHRleHQgIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAgICogQHJldHVybnMgeyBib29sZWFuIH1cbiAgICovXG4gIHRlc3RUcmFpbGluZ1doaXRlc3BhY2UgKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy50cmFpbGluZ1doaXRlc3BhY2VSZS50ZXN0KHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gdGV4dCBjb250YWlucyBhbnkgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHBhcmFtICAgeyBzdHJpbmcgfSAgdGV4dCAgVGhlIHN0cmluZyB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICAgKi9cbiAgdGVzdENvbnRhaW5zV29yZHMgKHRleHQpIHtcbiAgICByZXR1cm4gIXRoaXMuYWxsV2hpdGVzcGFjZU9yRW1wdHlSZS50ZXN0KHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIG5ld2xpbmVzIGlmIHRoZXJlIGFyZSBubyB3b3Jkcy5cbiAgICpcbiAgICogSWYgYW55IHdvcmQgaXMgZm91bmQgdGhlbiByZXR1cm4gemVybyByZWdhcmRsZXNzIG9mIHRoZSBhY3R1YWwgbnVtYmVyIG9mIG5ld2xpbmVzLlxuICAgKlxuICAgKiBAcGFyYW0gICB7IHN0cmluZyB9ICB0ZXh0ICBJbnB1dCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHsgbnVtYmVyIH1cbiAgICovXG4gIGNvdW50TmV3bGluZXNOb1dvcmRzICh0ZXh0KSB7XG4gICAgdGhpcy5uZXdsaW5lT3JOb25XaGl0ZXNwYWNlUmUubGFzdEluZGV4ID0gMDtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgbGV0IG1hdGNoO1xuICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLm5ld2xpbmVPck5vbldoaXRlc3BhY2VSZS5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG1hdGNoWzBdID09PSAnXFxuJykge1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH1cblxufVxuXG4vKipcbiAqIEhlbHBzIHRvIGJ1aWxkIHRleHQgZnJvbSBpbmxpbmUgYW5kIGJsb2NrIGVsZW1lbnRzLlxuICpcbiAqIEBjbGFzcyBCbG9ja1RleHRCdWlsZGVyXG4gKi9cbmNsYXNzIEJsb2NrVGV4dEJ1aWxkZXIge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJsb2NrVGV4dEJ1aWxkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7IE9wdGlvbnMgfSBvcHRpb25zIEh0bWxUb1RleHQgb3B0aW9ucy5cbiAgICogQHBhcmFtIHsgaW1wb3J0KCdzZWxkZXJlZScpLlBpY2tlcjxEb21Ob2RlLCBUYWdEZWZpbml0aW9uPiB9IHBpY2tlciBTZWxlY3RvcnMgZGVjaXNpb24gdHJlZSBwaWNrZXIuXG4gICAqIEBwYXJhbSB7IGFueX0gW21ldGFkYXRhXSBPcHRpb25hbCBtZXRhZGF0YSBmb3IgSFRNTCBkb2N1bWVudCwgZm9yIHVzZSBpbiBmb3JtYXR0ZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMsIHBpY2tlciwgbWV0YWRhdGEgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucGlja2VyID0gcGlja2VyO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB0aGlzLndoaXRlc3BhY2VQcm9jZXNzb3IgPSBuZXcgV2hpdGVzcGFjZVByb2Nlc3NvcihvcHRpb25zKTtcbiAgICAvKiogQHR5cGUgeyBTdGFja0l0ZW0gfSAqL1xuICAgIHRoaXMuX3N0YWNrSXRlbSA9IG5ldyBCbG9ja1N0YWNrSXRlbShvcHRpb25zKTtcbiAgICAvKiogQHR5cGUgeyBUcmFuc2Zvcm1lclN0YWNrSXRlbSB9ICovXG4gICAgdGhpcy5fd29yZFRyYW5zZm9ybWVyID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1dCBhIHdvcmQtYnktd29yZCB0cmFuc2Zvcm0gZnVuY3Rpb24gb250byB0aGUgdHJhbnNmb3JtYXRpb25zIHN0YWNrLlxuICAgKlxuICAgKiBNYWlubHkgdXNlZCBmb3IgdXBwZXJjYXNpbmcuIENhbiBiZSBieXBhc3NlZCB0byBhZGQgdW5mb3JtYXR0ZWQgdGV4dCBzdWNoIGFzIFVSTHMuXG4gICAqXG4gICAqIFdvcmQgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgYmVmb3JlIHdyYXBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyAoc3RyOiBzdHJpbmcpID0+IHN0cmluZyB9IHdvcmRUcmFuc2Zvcm0gV29yZCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbi5cbiAgICovXG4gIHB1c2hXb3JkVHJhbnNmb3JtICh3b3JkVHJhbnNmb3JtKSB7XG4gICAgdGhpcy5fd29yZFRyYW5zZm9ybWVyID0gbmV3IFRyYW5zZm9ybWVyU3RhY2tJdGVtKHRoaXMuX3dvcmRUcmFuc2Zvcm1lciwgd29yZFRyYW5zZm9ybSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgZnVuY3Rpb24gZnJvbSB0aGUgd29yZCB0cmFuc2Zvcm1hdGlvbnMgc3RhY2suXG4gICAqXG4gICAqIEByZXR1cm5zIHsgKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcgfSBBIGZ1bmN0aW9uIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICBwb3BXb3JkVHJhbnNmb3JtICgpIHtcbiAgICBpZiAoIXRoaXMuX3dvcmRUcmFuc2Zvcm1lcikgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5fd29yZFRyYW5zZm9ybWVyLnRyYW5zZm9ybTtcbiAgICB0aGlzLl93b3JkVHJhbnNmb3JtZXIgPSB0aGlzLl93b3JkVHJhbnNmb3JtZXIubmV4dDtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9XG5cbiAgLyoqXG4gICAqIElnbm9yZSB3b3Jkd3JhcCBvcHRpb24gaW4gZm9sbG93dXAgaW5saW5lIGFkZGl0aW9ucyBhbmQgZGlzYWJsZSBhdXRvbWF0aWMgd3JhcHBpbmcuXG4gICAqL1xuICBzdGFydE5vV3JhcCAoKSB7XG4gICAgdGhpcy5fc3RhY2tJdGVtLmlzTm9XcmFwID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYXV0b21hdGljIHdyYXBwaW5nIHRvIGJlaGF2aW9yIGRlZmluZWQgYnkgb3B0aW9ucy5cbiAgICovXG4gIHN0b3BOb1dyYXAgKCkge1xuICAgIHRoaXMuX3N0YWNrSXRlbS5pc05vV3JhcCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqIEByZXR1cm5zIHsgKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcgfSAqL1xuICBfZ2V0Q29tYmluZWRXb3JkVHJhbnNmb3JtZXIgKCkge1xuICAgIGNvbnN0IHd0ID0gKHRoaXMuX3dvcmRUcmFuc2Zvcm1lcilcbiAgICAgID8gKChzdHIpID0+IGFwcGx5VHJhbnNmb3JtZXIoc3RyLCB0aGlzLl93b3JkVHJhbnNmb3JtZXIpKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgY2UgPSB0aGlzLm9wdGlvbnMuZW5jb2RlQ2hhcmFjdGVycztcbiAgICByZXR1cm4gKHd0KVxuICAgICAgPyAoKGNlKSA/IChzdHIpID0+IGNlKHd0KHN0cikpIDogd3QpXG4gICAgICA6IGNlO1xuICB9XG5cbiAgX3BvcFN0YWNrSXRlbSAoKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N0YWNrSXRlbTtcbiAgICB0aGlzLl9zdGFja0l0ZW0gPSBpdGVtLm5leHQ7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbGluZSBicmVhayBpbnRvIGN1cnJlbnRseSBidWlsdCBibG9jay5cbiAgICovXG4gIGFkZExpbmVCcmVhayAoKSB7XG4gICAgaWYgKCEoXG4gICAgICB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBCbG9ja1N0YWNrSXRlbVxuICAgICAgfHwgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgTGlzdEl0ZW1TdGFja0l0ZW1cbiAgICAgIHx8IHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIFRhYmxlQ2VsbFN0YWNrSXRlbVxuICAgICkpIHsgcmV0dXJuOyB9XG4gICAgaWYgKHRoaXMuX3N0YWNrSXRlbS5pc1ByZSkge1xuICAgICAgdGhpcy5fc3RhY2tJdGVtLnJhd1RleHQgKz0gJ1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlci5zdGFydE5ld0xpbmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgdG8gYnJlYWsgbGluZSBpbiBjYXNlIGRpcmVjdGx5IGZvbGxvd2luZyB0ZXh0IHdpbGwgbm90IGZpdC5cbiAgICovXG4gIGFkZFdvcmRCcmVha09wcG9ydHVuaXR5ICgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBCbG9ja1N0YWNrSXRlbVxuICAgICAgfHwgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgTGlzdEl0ZW1TdGFja0l0ZW1cbiAgICAgIHx8IHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIFRhYmxlQ2VsbFN0YWNrSXRlbVxuICAgICkge1xuICAgICAgdGhpcy5fc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLndvcmRCcmVha09wcG9ydHVuaXR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbm9kZSBpbmxpbmUgaW50byB0aGUgY3VycmVudGx5IGJ1aWx0IGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0geyBzdHJpbmcgfSBzdHJcbiAgICogVGV4dCBjb250ZW50IG9mIGEgbm9kZSB0byBhZGQuXG4gICAqXG4gICAqIEBwYXJhbSB7IG9iamVjdCB9IFtwYXJhbTFdXG4gICAqIE9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7IGJvb2xlYW4gfSBbcGFyYW0xLm5vV29yZFRyYW5zZm9ybV1cbiAgICogSWdub3JlIHdvcmQgdHJhbnNmb3JtZXJzIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAqIERvbid0IGVuY29kZSBjaGFyYWN0ZXJzIGFzIHdlbGwuXG4gICAqIChVc2UgdGhpcyBmb3IgdGhpbmdzIGxpa2UgVVJMIGFkZHJlc3NlcykuXG4gICAqL1xuICBhZGRJbmxpbmUgKHN0ciwgeyBub1dvcmRUcmFuc2Zvcm0gPSBmYWxzZSB9ID0ge30pIHtcbiAgICBpZiAoIShcbiAgICAgIHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIEJsb2NrU3RhY2tJdGVtXG4gICAgICB8fCB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBMaXN0SXRlbVN0YWNrSXRlbVxuICAgICAgfHwgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgVGFibGVDZWxsU3RhY2tJdGVtXG4gICAgKSkgeyByZXR1cm47IH1cblxuICAgIGlmICh0aGlzLl9zdGFja0l0ZW0uaXNQcmUpIHtcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5yYXdUZXh0ICs9IHN0cjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBzdHIubGVuZ3RoID09PSAwIHx8IC8vIGVtcHR5IHN0cmluZ1xuICAgICAgKFxuICAgICAgICB0aGlzLl9zdGFja0l0ZW0uc3Rhc2hlZExpbmVCcmVha3MgJiYgLy8gc3Rhc2hlZCBsaW5lYnJlYWtzIG1ha2Ugd2hpdGVzcGFjZSBpcnJlbGV2YW50XG4gICAgICAgICF0aGlzLndoaXRlc3BhY2VQcm9jZXNzb3IudGVzdENvbnRhaW5zV29yZHMoc3RyKSAvLyBubyB3b3JkcyB0byBhZGRcbiAgICAgIClcbiAgICApIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlTmV3bGluZXMpIHtcbiAgICAgIGNvbnN0IG5ld2xpbmVzTnVtYmVyID0gdGhpcy53aGl0ZXNwYWNlUHJvY2Vzc29yLmNvdW50TmV3bGluZXNOb1dvcmRzKHN0cik7XG4gICAgICBpZiAobmV3bGluZXNOdW1iZXIgPiAwKSB7XG4gICAgICAgIHRoaXMuX3N0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlci5zdGFydE5ld0xpbmUobmV3bGluZXNOdW1iZXIpO1xuICAgICAgICAvLyBrZWVwIHN0YXNoZWRMaW5lQnJlYWtzIHVuY2hhbmdlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YWNrSXRlbS5zdGFzaGVkTGluZUJyZWFrcykge1xuICAgICAgdGhpcy5fc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLnN0YXJ0TmV3TGluZSh0aGlzLl9zdGFja0l0ZW0uc3Rhc2hlZExpbmVCcmVha3MpO1xuICAgIH1cbiAgICB0aGlzLndoaXRlc3BhY2VQcm9jZXNzb3Iuc2hyaW5rV3JhcEFkZChcbiAgICAgIHN0cixcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlcixcbiAgICAgIChub1dvcmRUcmFuc2Zvcm0pID8gdW5kZWZpbmVkIDogdGhpcy5fZ2V0Q29tYmluZWRXb3JkVHJhbnNmb3JtZXIoKSxcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5pc05vV3JhcFxuICAgICk7XG4gICAgdGhpcy5fc3RhY2tJdGVtLnN0YXNoZWRMaW5lQnJlYWtzID0gMDsgLy8gaW5saW5lIHRleHQgZG9lc24ndCBpbnRyb2R1Y2UgbGluZSBicmVha3NcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBzdHJpbmcgaW5saW5lIGludG8gdGhlIGN1cnJlbnRseSBidWlsdCBibG9jay5cbiAgICpcbiAgICogVXNlIHRoaXMgZm9yIG1hcmt1cCBlbGVtZW50cyB0aGF0IGRvbid0IGhhdmUgdG8gYWRoZXJlXG4gICAqIHRvIHRleHQgbGF5b3V0IHJ1bGVzLlxuICAgKlxuICAgKiBAcGFyYW0geyBzdHJpbmcgfSBzdHIgVGV4dCB0byBhZGQuXG4gICAqL1xuICBhZGRMaXRlcmFsIChzdHIpIHtcbiAgICBpZiAoIShcbiAgICAgIHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIEJsb2NrU3RhY2tJdGVtXG4gICAgICB8fCB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBMaXN0SXRlbVN0YWNrSXRlbVxuICAgICAgfHwgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgVGFibGVDZWxsU3RhY2tJdGVtXG4gICAgKSkgeyByZXR1cm47IH1cblxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHRoaXMuX3N0YWNrSXRlbS5pc1ByZSkge1xuICAgICAgdGhpcy5fc3RhY2tJdGVtLnJhd1RleHQgKz0gc3RyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGFja0l0ZW0uc3Rhc2hlZExpbmVCcmVha3MpIHtcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlci5zdGFydE5ld0xpbmUodGhpcy5fc3RhY2tJdGVtLnN0YXNoZWRMaW5lQnJlYWtzKTtcbiAgICB9XG4gICAgdGhpcy53aGl0ZXNwYWNlUHJvY2Vzc29yLmFkZExpdGVyYWwoXG4gICAgICBzdHIsXG4gICAgICB0aGlzLl9zdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIsXG4gICAgICB0aGlzLl9zdGFja0l0ZW0uaXNOb1dyYXBcbiAgICApO1xuICAgIHRoaXMuX3N0YWNrSXRlbS5zdGFzaGVkTGluZUJyZWFrcyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYnVpbGRpbmcgYSBuZXcgYmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IG9iamVjdCB9IFtwYXJhbTBdXG4gICAqIE9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBibG9jay5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC5sZWFkaW5nTGluZUJyZWFrc11cbiAgICogVGhpcyBibG9jayBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0aGlzIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBzZXBhcmF0ZSBpdCBmcm9tIGFueSBwcmVjZWRpbmcgYmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9ICBbcGFyYW0wLnJlc2VydmVkTGluZUxlbmd0aF1cbiAgICogUmVzZXJ2ZSB0aGlzIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9uIGVhY2ggbGluZSBmb3IgYmxvY2sgbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0geyBib29sZWFuIH0gW3BhcmFtMC5pc1ByZV1cbiAgICogU2hvdWxkIEhUTUwgd2hpdGVzcGFjZSBiZSBwcmVzZXJ2ZWQgaW5zaWRlIHRoaXMgYmxvY2suXG4gICAqL1xuICBvcGVuQmxvY2sgKHsgbGVhZGluZ0xpbmVCcmVha3MgPSAxLCByZXNlcnZlZExpbmVMZW5ndGggPSAwLCBpc1ByZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGNvbnN0IG1heExpbmVMZW5ndGggPSBNYXRoLm1heCgyMCwgdGhpcy5fc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLm1heExpbmVMZW5ndGggLSByZXNlcnZlZExpbmVMZW5ndGgpO1xuICAgIHRoaXMuX3N0YWNrSXRlbSA9IG5ldyBCbG9ja1N0YWNrSXRlbShcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgIHRoaXMuX3N0YWNrSXRlbSxcbiAgICAgIGxlYWRpbmdMaW5lQnJlYWtzLFxuICAgICAgbWF4TGluZUxlbmd0aFxuICAgICk7XG4gICAgaWYgKGlzUHJlKSB7IHRoaXMuX3N0YWNrSXRlbS5pc1ByZSA9IHRydWU7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZSBjdXJyZW50bHkgYnVpbHQgYmxvY2ssIGFkZCBpdCdzIGNvbnRlbnQgdG8gdGhlIHBhcmVudCBibG9jay5cbiAgICpcbiAgICogQHBhcmFtIHsgb2JqZWN0IH0gW3BhcmFtMF1cbiAgICogT2JqZWN0IGhvbGRpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLnRyYWlsaW5nTGluZUJyZWFrc11cbiAgICogVGhpcyBibG9jayBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0aGlzIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBzZXBhcmF0ZSBpdCBmcm9tIGFueSBmb2xsb3dpbmcgYmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IChzdHI6IHN0cmluZykgPT4gc3RyaW5nIH0gW3BhcmFtMC5ibG9ja1RyYW5zZm9ybV1cbiAgICogQSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gdGhlIGJsb2NrIHRleHQgYmVmb3JlIGFkZGluZyB0byB0aGUgcGFyZW50IGJsb2NrLlxuICAgKiBUaGlzIGhhcHBlbnMgYWZ0ZXIgd29yZCB3cmFwIGFuZCBzaG91bGQgYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIHJlc2VydmVkIGxpbmUgbGVuZ3RoXG4gICAqIGluIG9yZGVyIHRvIGtlZXAgbGluZSBsZW5ndGhzIGNvcnJlY3QuXG4gICAqIFVzZWQgZm9yIHdob2xlIGJsb2NrIG1hcmt1cC5cbiAgICovXG4gIGNsb3NlQmxvY2sgKHsgdHJhaWxpbmdMaW5lQnJlYWtzID0gMSwgYmxvY2tUcmFuc2Zvcm0gPSB1bmRlZmluZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgYmxvY2sgPSB0aGlzLl9wb3BTdGFja0l0ZW0oKTtcbiAgICBjb25zdCBibG9ja1RleHQgPSAoYmxvY2tUcmFuc2Zvcm0pID8gYmxvY2tUcmFuc2Zvcm0oZ2V0VGV4dChibG9jaykpIDogZ2V0VGV4dChibG9jayk7XG4gICAgYWRkVGV4dCh0aGlzLl9zdGFja0l0ZW0sIGJsb2NrVGV4dCwgYmxvY2subGVhZGluZ0xpbmVCcmVha3MsIE1hdGgubWF4KGJsb2NrLnN0YXNoZWRMaW5lQnJlYWtzLCB0cmFpbGluZ0xpbmVCcmVha3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBidWlsZGluZyBhIG5ldyBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0geyBvYmplY3QgfSBbcGFyYW0wXVxuICAgKiBPYmplY3QgaG9sZGluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC5tYXhQcmVmaXhMZW5ndGhdXG4gICAqIExlbmd0aCBvZiB0aGUgbG9uZ2VzdCBsaXN0IGl0ZW0gcHJlZml4LlxuICAgKiBJZiBub3Qgc3VwcGxpZWQgb3IgdG9vIHNtYWxsIHRoZW4gbGlzdCBpdGVtcyB3b24ndCBiZSBhbGlnbmVkIHByb3Blcmx5LlxuICAgKlxuICAgKiBAcGFyYW0geyAnbGVmdCcgfCAncmlnaHQnIH0gW3BhcmFtMC5wcmVmaXhBbGlnbl1cbiAgICogU3BlY2lmeSBob3cgcHJlZml4ZXMgb2YgZGlmZmVyZW50IGxlbmd0aHMgaGF2ZSB0byBiZSBhbGlnbmVkXG4gICAqIHdpdGhpbiBhIGNvbHVtbi5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC5pbnRlclJvd0xpbmVCcmVha3NdXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIGxpbmUgYnJlYWtzIGJldHdlZW4gbGlzdCBpdGVtcy5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC5sZWFkaW5nTGluZUJyZWFrc11cbiAgICogVGhpcyBsaXN0IHNob3VsZCBoYXZlIGF0IGxlYXN0IHRoaXMgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIHNlcGFyYXRlIGl0IGZyb20gYW55IHByZWNlZGluZyBibG9jay5cbiAgICovXG4gIG9wZW5MaXN0ICh7IG1heFByZWZpeExlbmd0aCA9IDAsIHByZWZpeEFsaWduID0gJ2xlZnQnLCBpbnRlclJvd0xpbmVCcmVha3MgPSAxLCBsZWFkaW5nTGluZUJyZWFrcyA9IDIgfSA9IHt9KSB7XG4gICAgdGhpcy5fc3RhY2tJdGVtID0gbmV3IExpc3RTdGFja0l0ZW0odGhpcy5vcHRpb25zLCB0aGlzLl9zdGFja0l0ZW0sIHtcbiAgICAgIGludGVyUm93TGluZUJyZWFrczogaW50ZXJSb3dMaW5lQnJlYWtzLFxuICAgICAgbGVhZGluZ0xpbmVCcmVha3M6IGxlYWRpbmdMaW5lQnJlYWtzLFxuICAgICAgbWF4TGluZUxlbmd0aDogdGhpcy5fc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLm1heExpbmVMZW5ndGgsXG4gICAgICBtYXhQcmVmaXhMZW5ndGg6IG1heFByZWZpeExlbmd0aCxcbiAgICAgIHByZWZpeEFsaWduOiBwcmVmaXhBbGlnblxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGJ1aWxkaW5nIGEgbmV3IGxpc3QgaXRlbS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMFxuICAgKiBPYmplY3QgaG9sZGluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGlzdCBpdGVtLlxuICAgKlxuICAgKiBAcGFyYW0geyBzdHJpbmcgfSBbcGFyYW0wLnByZWZpeF1cbiAgICogUHJlZml4IGZvciB0aGlzIGxpc3QgaXRlbSAoaXRlbSBudW1iZXIsIGJ1bGxldCBwb2ludCwgZXRjKS5cbiAgICovXG4gIG9wZW5MaXN0SXRlbSAoeyBwcmVmaXggPSAnJyB9ID0ge30pIHtcbiAgICBpZiAoISh0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBMaXN0U3RhY2tJdGVtKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGFkZCBhIGxpc3QgaXRlbSB0byBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBsaXN0ISBDaGVjayB0aGUgZm9ybWF0dGVyLicpO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ID0gdGhpcy5fc3RhY2tJdGVtO1xuICAgIGNvbnN0IHByZWZpeExlbmd0aCA9IE1hdGgubWF4KHByZWZpeC5sZW5ndGgsIGxpc3QubWF4UHJlZml4TGVuZ3RoKTtcbiAgICBjb25zdCBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgoMjAsIGxpc3QuaW5saW5lVGV4dEJ1aWxkZXIubWF4TGluZUxlbmd0aCAtIHByZWZpeExlbmd0aCk7XG4gICAgdGhpcy5fc3RhY2tJdGVtID0gbmV3IExpc3RJdGVtU3RhY2tJdGVtKHRoaXMub3B0aW9ucywgbGlzdCwge1xuICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICBtYXhMaW5lTGVuZ3RoOiBtYXhMaW5lTGVuZ3RoLFxuICAgICAgbGVhZGluZ0xpbmVCcmVha3M6IGxpc3QuaW50ZXJSb3dMaW5lQnJlYWtzXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmluYWxpemUgY3VycmVudGx5IGJ1aWx0IGxpc3QgaXRlbSwgYWRkIGl0J3MgY29udGVudCB0byB0aGUgcGFyZW50IGxpc3QuXG4gICAqL1xuICBjbG9zZUxpc3RJdGVtICgpIHtcbiAgICBjb25zdCBsaXN0SXRlbSA9IHRoaXMuX3BvcFN0YWNrSXRlbSgpO1xuICAgIGNvbnN0IGxpc3QgPSBsaXN0SXRlbS5uZXh0O1xuXG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gTWF0aC5tYXgobGlzdEl0ZW0ucHJlZml4Lmxlbmd0aCwgbGlzdC5tYXhQcmVmaXhMZW5ndGgpO1xuICAgIGNvbnN0IHNwYWNpbmcgPSAnXFxuJyArICcgJy5yZXBlYXQocHJlZml4TGVuZ3RoKTtcbiAgICBjb25zdCBwcmVmaXggPSAobGlzdC5wcmVmaXhBbGlnbiA9PT0gJ3JpZ2h0JylcbiAgICAgID8gbGlzdEl0ZW0ucHJlZml4LnBhZFN0YXJ0KHByZWZpeExlbmd0aClcbiAgICAgIDogbGlzdEl0ZW0ucHJlZml4LnBhZEVuZChwcmVmaXhMZW5ndGgpO1xuICAgIGNvbnN0IHRleHQgPSBwcmVmaXggKyBnZXRUZXh0KGxpc3RJdGVtKS5yZXBsYWNlKC9cXG4vZywgc3BhY2luZyk7XG5cbiAgICBhZGRUZXh0KFxuICAgICAgbGlzdCxcbiAgICAgIHRleHQsXG4gICAgICBsaXN0SXRlbS5sZWFkaW5nTGluZUJyZWFrcyxcbiAgICAgIE1hdGgubWF4KGxpc3RJdGVtLnN0YXNoZWRMaW5lQnJlYWtzLCBsaXN0LmludGVyUm93TGluZUJyZWFrcylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmFsaXplIGN1cnJlbnRseSBidWlsdCBsaXN0LCBhZGQgaXQncyBjb250ZW50IHRvIHRoZSBwYXJlbnQgYmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IG9iamVjdCB9IHBhcmFtMFxuICAgKiBPYmplY3QgaG9sZGluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC50cmFpbGluZ0xpbmVCcmVha3NdXG4gICAqIFRoaXMgbGlzdCBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0aGlzIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBzZXBhcmF0ZSBpdCBmcm9tIGFueSBmb2xsb3dpbmcgYmxvY2suXG4gICAqL1xuICBjbG9zZUxpc3QgKHsgdHJhaWxpbmdMaW5lQnJlYWtzID0gMiB9ID0ge30pIHtcbiAgICBjb25zdCBsaXN0ID0gdGhpcy5fcG9wU3RhY2tJdGVtKCk7XG4gICAgY29uc3QgdGV4dCA9IGdldFRleHQobGlzdCk7XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIGFkZFRleHQodGhpcy5fc3RhY2tJdGVtLCB0ZXh0LCBsaXN0LmxlYWRpbmdMaW5lQnJlYWtzLCB0cmFpbGluZ0xpbmVCcmVha3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBidWlsZGluZyBhIHRhYmxlLlxuICAgKi9cbiAgb3BlblRhYmxlICgpIHtcbiAgICB0aGlzLl9zdGFja0l0ZW0gPSBuZXcgVGFibGVTdGFja0l0ZW0odGhpcy5fc3RhY2tJdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBidWlsZGluZyBhIHRhYmxlIHJvdy5cbiAgICovXG4gIG9wZW5UYWJsZVJvdyAoKSB7XG4gICAgaWYgKCEodGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgVGFibGVTdGFja0l0ZW0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgYWRkIGEgdGFibGUgcm93IHRvIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIHRhYmxlISBDaGVjayB0aGUgZm9ybWF0dGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9zdGFja0l0ZW0gPSBuZXcgVGFibGVSb3dTdGFja0l0ZW0odGhpcy5fc3RhY2tJdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBidWlsZGluZyBhIHRhYmxlIGNlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7IG9iamVjdCB9IFtwYXJhbTBdXG4gICAqIE9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBjZWxsLlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLm1heENvbHVtbldpZHRoXVxuICAgKiBXcmFwIGNlbGwgY29udGVudCB0byB0aGlzIHdpZHRoLiBGYWxsIGJhY2sgdG8gZ2xvYmFsIHdvcmR3cmFwIHZhbHVlIGlmIHVuZGVmaW5lZC5cbiAgICovXG4gIG9wZW5UYWJsZUNlbGwgKHsgbWF4Q29sdW1uV2lkdGggPSB1bmRlZmluZWQgfSA9IHt9KSB7XG4gICAgaWYgKCEodGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgVGFibGVSb3dTdGFja0l0ZW0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgYWRkIGEgdGFibGUgY2VsbCB0byBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSB0YWJsZSByb3chIENoZWNrIHRoZSBmb3JtYXR0ZXIuJyk7XG4gICAgfVxuICAgIHRoaXMuX3N0YWNrSXRlbSA9IG5ldyBUYWJsZUNlbGxTdGFja0l0ZW0odGhpcy5vcHRpb25zLCB0aGlzLl9zdGFja0l0ZW0sIG1heENvbHVtbldpZHRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZSBjdXJyZW50bHkgYnVpbHQgdGFibGUgY2VsbCBhbmQgYWRkIGl0IHRvIHBhcmVudCB0YWJsZSByb3cncyBjZWxscy5cbiAgICpcbiAgICogQHBhcmFtIHsgb2JqZWN0IH0gW3BhcmFtMF1cbiAgICogT2JqZWN0IGhvbGRpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGNlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAuY29sc3Bhbl0gSG93IG1hbnkgY29sdW1ucyB0aGlzIGNlbGwgc2hvdWxkIG9jY3VweS5cbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC5yb3dzcGFuXSBIb3cgbWFueSByb3dzIHRoaXMgY2VsbCBzaG91bGQgb2NjdXB5LlxuICAgKi9cbiAgY2xvc2VUYWJsZUNlbGwgKHsgY29sc3BhbiA9IDEsIHJvd3NwYW4gPSAxIH0gPSB7fSkge1xuICAgIGNvbnN0IGNlbGwgPSB0aGlzLl9wb3BTdGFja0l0ZW0oKTtcbiAgICBjb25zdCB0ZXh0ID0gdHJpbUNoYXJhY3RlcihnZXRUZXh0KGNlbGwpLCAnXFxuJyk7XG4gICAgY2VsbC5uZXh0LmNlbGxzLnB1c2goeyBjb2xzcGFuOiBjb2xzcGFuLCByb3dzcGFuOiByb3dzcGFuLCB0ZXh0OiB0ZXh0IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmFsaXplIGN1cnJlbnRseSBidWlsdCB0YWJsZSByb3cgYW5kIGFkZCBpdCB0byBwYXJlbnQgdGFibGUncyByb3dzLlxuICAgKi9cbiAgY2xvc2VUYWJsZVJvdyAoKSB7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5fcG9wU3RhY2tJdGVtKCk7XG4gICAgcm93Lm5leHQucm93cy5wdXNoKHJvdy5jZWxscyk7XG4gIH1cblxuICAvKipcbiAgICogRmluYWxpemUgY3VycmVudGx5IGJ1aWx0IHRhYmxlIGFuZCBhZGQgdGhlIHJlbmRlcmVkIHRleHQgdG8gdGhlIHBhcmVudCBibG9jay5cbiAgICpcbiAgICogQHBhcmFtIHsgb2JqZWN0IH0gcGFyYW0wXG4gICAqIE9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSB0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHsgVGFibGVQcmludGVyIH0gcGFyYW0wLnRhYmxlVG9TdHJpbmdcbiAgICogQSBmdW5jdGlvbiB0byBjb252ZXJ0IGEgdGFibGUgb2Ygc3RyaW5naWZpZWQgY2VsbHMgaW50byBhIGNvbXBsZXRlIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLmxlYWRpbmdMaW5lQnJlYWtzXVxuICAgKiBUaGlzIHRhYmxlIHNob3VsZCBoYXZlIGF0IGxlYXN0IHRoaXMgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIHNlcGFyYXRlIGlmIGZyb20gYW55IHByZWNlZGluZyBibG9jay5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC50cmFpbGluZ0xpbmVCcmVha3NdXG4gICAqIFRoaXMgdGFibGUgc2hvdWxkIGhhdmUgYXQgbGVhc3QgdGhpcyBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gc2VwYXJhdGUgaXQgZnJvbSBhbnkgZm9sbG93aW5nIGJsb2NrLlxuICAgKi9cbiAgY2xvc2VUYWJsZSAoeyB0YWJsZVRvU3RyaW5nLCBsZWFkaW5nTGluZUJyZWFrcyA9IDIsIHRyYWlsaW5nTGluZUJyZWFrcyA9IDIgfSkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fcG9wU3RhY2tJdGVtKCk7XG4gICAgY29uc3Qgb3V0cHV0ID0gdGFibGVUb1N0cmluZyh0YWJsZS5yb3dzKTtcbiAgICBpZiAob3V0cHV0KSB7XG4gICAgICBhZGRUZXh0KHRoaXMuX3N0YWNrSXRlbSwgb3V0cHV0LCBsZWFkaW5nTGluZUJyZWFrcywgdHJhaWxpbmdMaW5lQnJlYWtzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSByZW5kZXJlZCB0ZXh0IGNvbnRlbnQgb2YgdGhpcyBidWlsZGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7IHN0cmluZyB9XG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIGdldFRleHQodGhpcy5fc3RhY2tJdGVtLmdldFJvb3QoKSk7XG4gICAgLy8gVGhlcmUgc2hvdWxkIG9ubHkgYmUgdGhlIHJvb3QgaXRlbSBpZiBldmVyeXRoaW5nIGlzIGNsb3NlZCBwcm9wZXJseS5cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGdldFRleHQgKHN0YWNrSXRlbSkge1xuICBpZiAoIShcbiAgICBzdGFja0l0ZW0gaW5zdGFuY2VvZiBCbG9ja1N0YWNrSXRlbVxuICAgIHx8IHN0YWNrSXRlbSBpbnN0YW5jZW9mIExpc3RJdGVtU3RhY2tJdGVtXG4gICAgfHwgc3RhY2tJdGVtIGluc3RhbmNlb2YgVGFibGVDZWxsU3RhY2tJdGVtXG4gICkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgYmxvY2tzLCBsaXN0IGl0ZW1zIGFuZCB0YWJsZSBjZWxscyBjYW4gYmUgcmVxdWVzdGVkIGZvciB0ZXh0IGNvbnRlbnRzLicpO1xuICB9XG4gIHJldHVybiAoc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLmlzRW1wdHkoKSlcbiAgICA/IHN0YWNrSXRlbS5yYXdUZXh0XG4gICAgOiBzdGFja0l0ZW0ucmF3VGV4dCArIHN0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlci50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBhZGRUZXh0IChzdGFja0l0ZW0sIHRleHQsIGxlYWRpbmdMaW5lQnJlYWtzLCB0cmFpbGluZ0xpbmVCcmVha3MpIHtcbiAgaWYgKCEoXG4gICAgc3RhY2tJdGVtIGluc3RhbmNlb2YgQmxvY2tTdGFja0l0ZW1cbiAgICB8fCBzdGFja0l0ZW0gaW5zdGFuY2VvZiBMaXN0SXRlbVN0YWNrSXRlbVxuICAgIHx8IHN0YWNrSXRlbSBpbnN0YW5jZW9mIFRhYmxlQ2VsbFN0YWNrSXRlbVxuICApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGJsb2NrcywgbGlzdCBpdGVtcyBhbmQgdGFibGUgY2VsbHMgY2FuIGNvbnRhaW4gdGV4dC4nKTtcbiAgfVxuICBjb25zdCBwYXJlbnRUZXh0ID0gZ2V0VGV4dChzdGFja0l0ZW0pO1xuICBjb25zdCBsaW5lQnJlYWtzID0gTWF0aC5tYXgoc3RhY2tJdGVtLnN0YXNoZWRMaW5lQnJlYWtzLCBsZWFkaW5nTGluZUJyZWFrcyk7XG4gIHN0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlci5jbGVhcigpO1xuICBpZiAocGFyZW50VGV4dCkge1xuICAgIHN0YWNrSXRlbS5yYXdUZXh0ID0gcGFyZW50VGV4dCArICdcXG4nLnJlcGVhdChsaW5lQnJlYWtzKSArIHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhY2tJdGVtLnJhd1RleHQgPSB0ZXh0O1xuICAgIHN0YWNrSXRlbS5sZWFkaW5nTGluZUJyZWFrcyA9IGxpbmVCcmVha3M7XG4gIH1cbiAgc3RhY2tJdGVtLnN0YXNoZWRMaW5lQnJlYWtzID0gdHJhaWxpbmdMaW5lQnJlYWtzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IHN0cmluZyB9IHN0ciBBIHN0cmluZyB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyBUcmFuc2Zvcm1lclN0YWNrSXRlbSB9IHRyYW5zZm9ybWVyIEEgdHJhbnNmb3JtZXIgaXRlbSAod2l0aCBwb3NzaWJsZSBjb250aW51YXRpb24pLlxuICogQHJldHVybnMgeyBzdHJpbmcgfVxuICovXG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybWVyIChzdHIsIHRyYW5zZm9ybWVyKSB7XG4gIHJldHVybiAoKHRyYW5zZm9ybWVyKSA/IGFwcGx5VHJhbnNmb3JtZXIodHJhbnNmb3JtZXIudHJhbnNmb3JtKHN0ciksIHRyYW5zZm9ybWVyLm5leHQpIDogc3RyKTtcbn1cblxuLyoqXG4gKiBDb21waWxlIHNlbGVjdG9ycyBpbnRvIGEgZGVjaXNpb24gdHJlZSxcbiAqIHJldHVybiBhIGZ1bmN0aW9uIGludGVuZGVkIGZvciBiYXRjaCBwcm9jZXNzaW5nLlxuICpcbiAqIEBwYXJhbSAgIHsgT3B0aW9ucyB9IFtvcHRpb25zID0ge31dICAgSHRtbFRvVGV4dCBvcHRpb25zIChkZWZhdWx0cywgZm9ybWF0dGVycywgdXNlciBvcHRpb25zIG1lcmdlZCwgZGVkdXBsaWNhdGVkKS5cbiAqIEByZXR1cm5zIHsgKGh0bWw6IHN0cmluZywgbWV0YWRhdGE/OiBhbnkpID0+IHN0cmluZyB9IFByZS1jb25maWd1cmVkIGNvbnZlcnRlciBmdW5jdGlvbi5cbiAqIEBzdGF0aWNcbiAqL1xuZnVuY3Rpb24gY29tcGlsZSQxIChvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc2VsZWN0b3JzV2l0aG91dEZvcm1hdCA9IG9wdGlvbnMuc2VsZWN0b3JzLmZpbHRlcihzID0+ICFzLmZvcm1hdCk7XG4gIGlmIChzZWxlY3RvcnNXaXRob3V0Rm9ybWF0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdGb2xsb3dpbmcgc2VsZWN0b3JzIGhhdmUgbm8gc3BlY2lmaWVkIGZvcm1hdDogJyArXG4gICAgICBzZWxlY3RvcnNXaXRob3V0Rm9ybWF0Lm1hcChzID0+IGBcXGAke3Muc2VsZWN0b3J9XFxgYCkuam9pbignLCAnKVxuICAgICk7XG4gIH1cbiAgY29uc3QgcGlja2VyID0gbmV3IHNlbGRlcmVlLkRlY2lzaW9uVHJlZShcbiAgICBvcHRpb25zLnNlbGVjdG9ycy5tYXAocyA9PiBbcy5zZWxlY3Rvciwgc10pXG4gICkuYnVpbGQocGx1Z2luSHRtbHBhcnNlcjIuaHAyQnVpbGRlcik7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmVuY29kZUNoYXJhY3RlcnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmVuY29kZUNoYXJhY3RlcnMgPSBtYWtlUmVwbGFjZXJGcm9tRGljdChvcHRpb25zLmVuY29kZUNoYXJhY3RlcnMpO1xuICB9XG5cbiAgY29uc3QgYmFzZVNlbGVjdG9yc1BpY2tlciA9IG5ldyBzZWxkZXJlZS5EZWNpc2lvblRyZWUoXG4gICAgb3B0aW9ucy5iYXNlRWxlbWVudHMuc2VsZWN0b3JzLm1hcCgocywgaSkgPT4gW3MsIGkgKyAxXSlcbiAgKS5idWlsZChwbHVnaW5IdG1scGFyc2VyMi5ocDJCdWlsZGVyKTtcbiAgZnVuY3Rpb24gZmluZEJhc2VFbGVtZW50cyAoZG9tKSB7XG4gICAgcmV0dXJuIGZpbmRCYXNlcyhkb20sIG9wdGlvbnMsIGJhc2VTZWxlY3RvcnNQaWNrZXIpO1xuICB9XG5cbiAgY29uc3QgbGltaXRlZFdhbGsgPSBsaW1pdGVkRGVwdGhSZWN1cnNpdmUoXG4gICAgb3B0aW9ucy5saW1pdHMubWF4RGVwdGgsXG4gICAgcmVjdXJzaXZlV2FsayxcbiAgICBmdW5jdGlvbiAoZG9tLCBidWlsZGVyKSB7XG4gICAgICBidWlsZGVyLmFkZElubGluZShvcHRpb25zLmxpbWl0cy5lbGxpcHNpcyB8fCAnJyk7XG4gICAgfVxuICApO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoaHRtbCwgbWV0YWRhdGEgPSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvY2VzcyhodG1sLCBtZXRhZGF0YSwgb3B0aW9ucywgcGlja2VyLCBmaW5kQmFzZUVsZW1lbnRzLCBsaW1pdGVkV2Fsayk7XG4gIH07XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IGdpdmVuIEhUTUwgYWNjb3JkaW5nIHRvIHByZXByb2Nlc3NlZCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7IHN0cmluZyB9IGh0bWwgSFRNTCBjb250ZW50IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0geyBhbnkgfSBtZXRhZGF0YSBPcHRpb25hbCBtZXRhZGF0YSBmb3IgSFRNTCBkb2N1bWVudCwgZm9yIHVzZSBpbiBmb3JtYXR0ZXJzLlxuICogQHBhcmFtIHsgT3B0aW9ucyB9IG9wdGlvbnMgSHRtbFRvVGV4dCBvcHRpb25zIChwcmVwcm9jZXNzZWQpLlxuICogQHBhcmFtIHsgaW1wb3J0KCdzZWxkZXJlZScpLlBpY2tlcjxEb21Ob2RlLCBUYWdEZWZpbml0aW9uPiB9IHBpY2tlclxuICogVGFnIGRlZmluaXRpb24gcGlja2VyIGZvciBET00gbm9kZXMgcHJvY2Vzc2luZy5cbiAqIEBwYXJhbSB7IChkb206IERvbU5vZGVbXSkgPT4gRG9tTm9kZVtdIH0gZmluZEJhc2VFbGVtZW50c1xuICogRnVuY3Rpb24gdG8gZXh0cmFjdCBlbGVtZW50cyBmcm9tIEhUTUwgRE9NXG4gKiB0aGF0IHdpbGwgb25seSBiZSBwcmVzZW50IGluIHRoZSBvdXRwdXQgdGV4dC5cbiAqIEBwYXJhbSB7IFJlY3Vyc2l2ZUNhbGxiYWNrIH0gd2FsayBSZWN1cnNpdmUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7IHN0cmluZyB9XG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3MgKGh0bWwsIG1ldGFkYXRhLCBvcHRpb25zLCBwaWNrZXIsIGZpbmRCYXNlRWxlbWVudHMsIHdhbGspIHtcbiAgY29uc3QgbWF4SW5wdXRMZW5ndGggPSBvcHRpb25zLmxpbWl0cy5tYXhJbnB1dExlbmd0aDtcbiAgaWYgKG1heElucHV0TGVuZ3RoICYmIGh0bWwgJiYgaHRtbC5sZW5ndGggPiBtYXhJbnB1dExlbmd0aCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBJbnB1dCBsZW5ndGggJHtodG1sLmxlbmd0aH0gaXMgYWJvdmUgYWxsb3dlZCBsaW1pdCBvZiAke21heElucHV0TGVuZ3RofS4gVHJ1bmNhdGluZyB3aXRob3V0IGVsbGlwc2lzLmBcbiAgICApO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZygwLCBtYXhJbnB1dExlbmd0aCk7XG4gIH1cblxuICBjb25zdCBkb2N1bWVudCA9IGh0bWxwYXJzZXIyLnBhcnNlRG9jdW1lbnQoaHRtbCwgeyBkZWNvZGVFbnRpdGllczogb3B0aW9ucy5kZWNvZGVFbnRpdGllcyB9KTtcbiAgY29uc3QgYmFzZXMgPSBmaW5kQmFzZUVsZW1lbnRzKGRvY3VtZW50LmNoaWxkcmVuKTtcbiAgY29uc3QgYnVpbGRlciA9IG5ldyBCbG9ja1RleHRCdWlsZGVyKG9wdGlvbnMsIHBpY2tlciwgbWV0YWRhdGEpO1xuICB3YWxrKGJhc2VzLCBidWlsZGVyKTtcbiAgcmV0dXJuIGJ1aWxkZXIudG9TdHJpbmcoKTtcbn1cblxuXG5mdW5jdGlvbiBmaW5kQmFzZXMgKGRvbSwgb3B0aW9ucywgYmFzZVNlbGVjdG9yc1BpY2tlcikge1xuICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgZnVuY3Rpb24gcmVjdXJzaXZlV2FsayAod2FsaywgLyoqIEB0eXBlIHsgRG9tTm9kZVtdIH0gKi8gZG9tKSB7XG4gICAgZG9tID0gZG9tLnNsaWNlKDAsIG9wdGlvbnMubGltaXRzLm1heENoaWxkTm9kZXMpO1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiBkb20pIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09ICd0YWcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGlja2VkU2VsZWN0b3JJbmRleCA9IGJhc2VTZWxlY3RvcnNQaWNrZXIucGljazEoZWxlbSk7XG4gICAgICBpZiAocGlja2VkU2VsZWN0b3JJbmRleCA+IDApIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHsgc2VsZWN0b3JJbmRleDogcGlja2VkU2VsZWN0b3JJbmRleCwgZWxlbWVudDogZWxlbSB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbS5jaGlsZHJlbikge1xuICAgICAgICB3YWxrKGVsZW0uY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID49IG9wdGlvbnMubGltaXRzLm1heEJhc2VFbGVtZW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbGltaXRlZFdhbGsgPSBsaW1pdGVkRGVwdGhSZWN1cnNpdmUoXG4gICAgb3B0aW9ucy5saW1pdHMubWF4RGVwdGgsXG4gICAgcmVjdXJzaXZlV2Fsa1xuICApO1xuICBsaW1pdGVkV2Fsayhkb20pO1xuXG4gIGlmIChvcHRpb25zLmJhc2VFbGVtZW50cy5vcmRlckJ5ICE9PSAnb2NjdXJyZW5jZScpIHsgLy8gJ3NlbGVjdG9ycydcbiAgICByZXN1bHRzLnNvcnQoKGEsIGIpID0+IGEuc2VsZWN0b3JJbmRleCAtIGIuc2VsZWN0b3JJbmRleCk7XG4gIH1cbiAgcmV0dXJuIChvcHRpb25zLmJhc2VFbGVtZW50cy5yZXR1cm5Eb21CeURlZmF1bHQgJiYgcmVzdWx0cy5sZW5ndGggPT09IDApXG4gICAgPyBkb21cbiAgICA6IHJlc3VsdHMubWFwKHggPT4geC5lbGVtZW50KTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0byB3YWxrIHRocm91Z2ggRE9NIG5vZGVzIGFuZCBhY2N1bXVsYXRlIHRoZWlyIHN0cmluZyByZXByZXNlbnRhdGlvbnMuXG4gKlxuICogQHBhcmFtICAgeyBSZWN1cnNpdmVDYWxsYmFjayB9IHdhbGsgICAgUmVjdXJzaXZlIGNhbGxiYWNrLlxuICogQHBhcmFtICAgeyBEb21Ob2RlW10gfSAgICAgICAgIFtkb21dICAgTm9kZXMgYXJyYXkgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSAgIHsgQmxvY2tUZXh0QnVpbGRlciB9ICBidWlsZGVyIFBhc3NlZCBhcm91bmQgdG8gYWNjdW11bGF0ZSBvdXRwdXQgdGV4dC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVdhbGsgKHdhbGssIGRvbSwgYnVpbGRlcikge1xuICBpZiAoIWRvbSkgeyByZXR1cm47IH1cblxuICBjb25zdCBvcHRpb25zID0gYnVpbGRlci5vcHRpb25zO1xuXG4gIGNvbnN0IHRvb01hbnlDaGlsZE5vZGVzID0gZG9tLmxlbmd0aCA+IG9wdGlvbnMubGltaXRzLm1heENoaWxkTm9kZXM7XG4gIGlmICh0b29NYW55Q2hpbGROb2Rlcykge1xuICAgIGRvbSA9IGRvbS5zbGljZSgwLCBvcHRpb25zLmxpbWl0cy5tYXhDaGlsZE5vZGVzKTtcbiAgICBkb20ucHVzaCh7XG4gICAgICBkYXRhOiBvcHRpb25zLmxpbWl0cy5lbGxpcHNpcyxcbiAgICAgIHR5cGU6ICd0ZXh0J1xuICAgIH0pO1xuICB9XG5cbiAgZm9yIChjb25zdCBlbGVtIG9mIGRvbSkge1xuICAgIHN3aXRjaCAoZWxlbS50eXBlKSB7XG4gICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICBidWlsZGVyLmFkZElubGluZShlbGVtLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3RhZyc6IHtcbiAgICAgICAgY29uc3QgdGFnRGVmaW5pdGlvbiA9IGJ1aWxkZXIucGlja2VyLnBpY2sxKGVsZW0pO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdHRlcnNbdGFnRGVmaW5pdGlvbi5mb3JtYXRdO1xuICAgICAgICBmb3JtYXQoZWxlbSwgd2FsaywgYnVpbGRlciwgdGFnRGVmaW5pdGlvbi5vcHRpb25zIHx8IHt9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IE9iamVjdDxzdHJpbmcsc3RyaW5nIHwgZmFsc2U+IH0gZGljdFxuICogQSBkaWN0aW9uYXJ5IHdoZXJlIGtleXMgYXJlIGNoYXJhY3RlcnMgdG8gcmVwbGFjZVxuICogYW5kIHZhbHVlcyBhcmUgcmVwbGFjZW1lbnQgc3RyaW5ncy5cbiAqXG4gKiBGaXJzdCBjb2RlIHBvaW50IGZyb20gZGljdCBrZXlzIGlzIHVzZWQuXG4gKiBDb21wb3VuZCBlbW9qaXMgd2l0aCBaV0ogYXJlIG5vdCBzdXBwb3J0ZWQgKG5vdCB1bnRpbCBOb2RlIDE2KS5cbiAqXG4gKiBAcmV0dXJucyB7ICgoc3RyOiBzdHJpbmcpID0+IHN0cmluZykgfCB1bmRlZmluZWQgfVxuICovXG5mdW5jdGlvbiBtYWtlUmVwbGFjZXJGcm9tRGljdCAoZGljdCkge1xuICBpZiAoIWRpY3QgfHwgT2JqZWN0LmtleXMoZGljdCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvKiogQHR5cGUgeyBbc3RyaW5nLCBzdHJpbmddW10gfSAqL1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZGljdCkuZmlsdGVyKChbLCB2XSkgPT4gdiAhPT0gZmFsc2UpO1xuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgZW50cmllc1xuICAgICAgLm1hcCgoW2NdKSA9PiBgKCR7dW5pY29kZUVzY2FwZShbLi4uY11bMF0pfSlgKVxuICAgICAgLmpvaW4oJ3wnKSxcbiAgICAnZydcbiAgKTtcbiAgY29uc3QgdmFsdWVzID0gZW50cmllcy5tYXAoKFssIHZdKSA9PiB2KTtcbiAgY29uc3QgcmVwbGFjZXIgPSAobSwgLi4uY2dzKSA9PiB2YWx1ZXNbY2dzLmZpbmRJbmRleChjZyA9PiBjZyldO1xuICByZXR1cm4gKHN0cikgPT4gc3RyLnJlcGxhY2UocmVnZXgsIHJlcGxhY2VyKTtcbn1cblxuLyoqXG4gKiBEdW1teSBmb3JtYXR0ZXIgdGhhdCBkaXNjYXJkcyB0aGUgaW5wdXQgYW5kIGRvZXMgbm90aGluZy5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0U2tpcCAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICAvKiBkbyBub3RoaW5nICovXG59XG5cbi8qKlxuICogSW5zZXJ0IHRoZSBnaXZlbiBzdHJpbmcgbGl0ZXJhbCBpbmxpbmUgaW5zdGVhZCBvZiBhIHRhZy5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0SW5saW5lU3RyaW5nIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIuYWRkTGl0ZXJhbChmb3JtYXRPcHRpb25zLnN0cmluZyB8fCAnJyk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGEgYmxvY2sgd2l0aCB0aGUgZ2l2ZW4gc3RyaW5nIGxpdGVyYWwgaW5zdGVhZCBvZiBhIHRhZy5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0QmxvY2tTdHJpbmcgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuQmxvY2soeyBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xuICBidWlsZGVyLmFkZExpdGVyYWwoZm9ybWF0T3B0aW9ucy5zdHJpbmcgfHwgJycpO1xuICBidWlsZGVyLmNsb3NlQmxvY2soeyB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhbiBpbmxpbmUtbGV2ZWwgZWxlbWVudC5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0SW5saW5lIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIGJsb2NrLWxldmVsIGNvbnRhaW5lci5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0QmxvY2skMSAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5CbG9jayh7IGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG4gIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gIGJ1aWxkZXIuY2xvc2VCbG9jayh7IHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyT3BlblRhZyAoZWxlbSkge1xuICBjb25zdCBhdHRycyA9IChlbGVtLmF0dHJpYnMgJiYgZWxlbS5hdHRyaWJzLmxlbmd0aClcbiAgICA/ICcgJyArIE9iamVjdC5lbnRyaWVzKGVsZW0uYXR0cmlicylcbiAgICAgIC5tYXAoKFtrLCB2XSkgPT4gKCh2ID09PSAnJykgPyBrIDogYCR7a309JHt2LnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKX1gKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICA6ICcnO1xuICByZXR1cm4gYDwke2VsZW0ubmFtZX0ke2F0dHJzfT5gO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDbG9zZVRhZyAoZWxlbSkge1xuICByZXR1cm4gYDwvJHtlbGVtLm5hbWV9PmA7XG59XG5cbi8qKlxuICogUmVuZGVyIGFuIGVsZW1lbnQgYXMgaW5saW5lIEhUTUwgdGFnLCB3YWxrIHRocm91Z2ggaXQncyBjaGlsZHJlbi5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0SW5saW5lVGFnIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIuc3RhcnROb1dyYXAoKTtcbiAgYnVpbGRlci5hZGRMaXRlcmFsKHJlbmRlck9wZW5UYWcoZWxlbSkpO1xuICBidWlsZGVyLnN0b3BOb1dyYXAoKTtcbiAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgYnVpbGRlci5zdGFydE5vV3JhcCgpO1xuICBidWlsZGVyLmFkZExpdGVyYWwocmVuZGVyQ2xvc2VUYWcoZWxlbSkpO1xuICBidWlsZGVyLnN0b3BOb1dyYXAoKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYW4gZWxlbWVudCBhcyBIVE1MIGJsb2NrIGJhZywgd2FsayB0aHJvdWdoIGl0J3MgY2hpbGRyZW4uXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEJsb2NrVGFnIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlbkJsb2NrKHsgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbiAgYnVpbGRlci5zdGFydE5vV3JhcCgpO1xuICBidWlsZGVyLmFkZExpdGVyYWwocmVuZGVyT3BlblRhZyhlbGVtKSk7XG4gIGJ1aWxkZXIuc3RvcE5vV3JhcCgpO1xuICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICBidWlsZGVyLnN0YXJ0Tm9XcmFwKCk7XG4gIGJ1aWxkZXIuYWRkTGl0ZXJhbChyZW5kZXJDbG9zZVRhZyhlbGVtKSk7XG4gIGJ1aWxkZXIuc3RvcE5vV3JhcCgpO1xuICBidWlsZGVyLmNsb3NlQmxvY2soeyB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG59XG5cbi8qKlxuICogUmVuZGVyIGFuIGVsZW1lbnQgd2l0aCBhbGwgaXQncyBjaGlsZHJlbiBhcyBpbmxpbmUgSFRNTC5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0SW5saW5lSHRtbCAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLnN0YXJ0Tm9XcmFwKCk7XG4gIGJ1aWxkZXIuYWRkTGl0ZXJhbChcbiAgICBkb21TZXJpYWxpemVyLnJlbmRlcihlbGVtLCB7IGRlY29kZUVudGl0aWVzOiBidWlsZGVyLm9wdGlvbnMuZGVjb2RlRW50aXRpZXMgfSlcbiAgKTtcbiAgYnVpbGRlci5zdG9wTm9XcmFwKCk7XG59XG5cbi8qKlxuICogUmVuZGVyIGFuIGVsZW1lbnQgd2l0aCBhbGwgaXQncyBjaGlsZHJlbiBhcyBIVE1MIGJsb2NrLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRCbG9ja0h0bWwgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuQmxvY2soeyBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xuICBidWlsZGVyLnN0YXJ0Tm9XcmFwKCk7XG4gIGJ1aWxkZXIuYWRkTGl0ZXJhbChcbiAgICBkb21TZXJpYWxpemVyLnJlbmRlcihlbGVtLCB7IGRlY29kZUVudGl0aWVzOiBidWlsZGVyLm9wdGlvbnMuZGVjb2RlRW50aXRpZXMgfSlcbiAgKTtcbiAgYnVpbGRlci5zdG9wTm9XcmFwKCk7XG4gIGJ1aWxkZXIuY2xvc2VCbG9jayh7IHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgaW5saW5lIGVsZW1lbnQgd3JhcHBlZCB3aXRoIGdpdmVuIHN0cmluZ3MuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdElubGluZVN1cnJvdW5kIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIuYWRkTGl0ZXJhbChmb3JtYXRPcHRpb25zLnByZWZpeCB8fCAnJyk7XG4gIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gIGJ1aWxkZXIuYWRkTGl0ZXJhbChmb3JtYXRPcHRpb25zLnN1ZmZpeCB8fCAnJyk7XG59XG5cbnZhciBnZW5lcmljRm9ybWF0dGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBibG9jazogZm9ybWF0QmxvY2skMSxcbiAgYmxvY2tIdG1sOiBmb3JtYXRCbG9ja0h0bWwsXG4gIGJsb2NrU3RyaW5nOiBmb3JtYXRCbG9ja1N0cmluZyxcbiAgYmxvY2tUYWc6IGZvcm1hdEJsb2NrVGFnLFxuICBpbmxpbmU6IGZvcm1hdElubGluZSxcbiAgaW5saW5lSHRtbDogZm9ybWF0SW5saW5lSHRtbCxcbiAgaW5saW5lU3RyaW5nOiBmb3JtYXRJbmxpbmVTdHJpbmcsXG4gIGlubGluZVN1cnJvdW5kOiBmb3JtYXRJbmxpbmVTdXJyb3VuZCxcbiAgaW5saW5lVGFnOiBmb3JtYXRJbmxpbmVUYWcsXG4gIHNraXA6IGZvcm1hdFNraXBcbn0pO1xuXG5mdW5jdGlvbiBnZXRSb3cgKG1hdHJpeCwgaikge1xuICBpZiAoIW1hdHJpeFtqXSkgeyBtYXRyaXhbal0gPSBbXTsgfVxuICByZXR1cm4gbWF0cml4W2pdO1xufVxuXG5mdW5jdGlvbiBmaW5kRmlyc3RWYWNhbnRJbmRleCAocm93LCB4ID0gMCkge1xuICB3aGlsZSAocm93W3hdKSB7IHgrKzsgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gdHJhbnNwb3NlSW5QbGFjZSAobWF0cml4LCBtYXhTaXplKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4U2l6ZTsgaSsrKSB7XG4gICAgY29uc3Qgcm93SSA9IGdldFJvdyhtYXRyaXgsIGkpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICBjb25zdCByb3dKID0gZ2V0Um93KG1hdHJpeCwgaik7XG4gICAgICBjb25zdCB0ZW1wID0gcm93SVtqXTtcbiAgICAgIHJvd0lbal0gPSByb3dKW2ldO1xuICAgICAgcm93SltpXSA9IHRlbXA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1dENlbGxJbnRvTGF5b3V0IChjZWxsLCBsYXlvdXQsIGJhc2VSb3csIGJhc2VDb2wpIHtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCBjZWxsLnJvd3NwYW47IHIrKykge1xuICAgIGNvbnN0IGxheW91dFJvdyA9IGdldFJvdyhsYXlvdXQsIGJhc2VSb3cgKyByKTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNlbGwuY29sc3BhbjsgYysrKSB7XG4gICAgICBsYXlvdXRSb3dbYmFzZUNvbCArIGNdID0gY2VsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlT2Zmc2V0IChvZmZzZXRzLCBiYXNlLCBzcGFuLCB2YWx1ZSkge1xuICBvZmZzZXRzW2Jhc2UgKyBzcGFuXSA9IE1hdGgubWF4KFxuICAgIG9mZnNldHNbYmFzZSArIHNwYW5dIHx8IDAsXG4gICAgb2Zmc2V0c1tiYXNlXSArIHZhbHVlXG4gICk7XG59XG5cbi8qKlxuICogUmVuZGVyIGEgdGFibGUgaW50byBhIHN0cmluZy5cbiAqIENlbGxzIGNhbiBjb250YWluIG11bHRpbGluZSB0ZXh0IGFuZCBzcGFuIGFjcm9zcyBtdWx0aXBsZSByb3dzIGFuZCBjb2x1bW5zLlxuICpcbiAqIE1vZGlmaWVzIGNlbGxzIHRvIGFkZCBsaW5lcyBhcnJheS5cbiAqXG4gKiBAcGFyYW0geyBUYWJsZVByaW50ZXJDZWxsW11bXSB9IHRhYmxlUm93cyBUYWJsZSB0byByZW5kZXIuXG4gKiBAcGFyYW0geyBudW1iZXIgfSByb3dTcGFjaW5nIE51bWJlciBvZiBzcGFjZXMgYmV0d2VlbiBjb2x1bW5zLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gY29sU3BhY2luZyBOdW1iZXIgb2YgZW1wdHkgbGluZXMgYmV0d2VlbiByb3dzLlxuICogQHJldHVybnMgeyBzdHJpbmcgfVxuICovXG5mdW5jdGlvbiB0YWJsZVRvU3RyaW5nICh0YWJsZVJvd3MsIHJvd1NwYWNpbmcsIGNvbFNwYWNpbmcpIHtcbiAgY29uc3QgbGF5b3V0ID0gW107XG4gIGxldCBjb2xOdW1iZXIgPSAwO1xuICBjb25zdCByb3dOdW1iZXIgPSB0YWJsZVJvd3MubGVuZ3RoO1xuICBjb25zdCByb3dPZmZzZXRzID0gWzBdO1xuICAvLyBGaWxsIHRoZSBsYXlvdXQgdGFibGUgYW5kIHJvdyBvZmZzZXRzIHJvdy1ieS1yb3cuXG4gIGZvciAobGV0IGogPSAwOyBqIDwgcm93TnVtYmVyOyBqKyspIHtcbiAgICBjb25zdCBsYXlvdXRSb3cgPSBnZXRSb3cobGF5b3V0LCBqKTtcbiAgICBjb25zdCBjZWxscyA9IHRhYmxlUm93c1tqXTtcbiAgICBsZXQgeCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2VsbCA9IGNlbGxzW2ldO1xuICAgICAgeCA9IGZpbmRGaXJzdFZhY2FudEluZGV4KGxheW91dFJvdywgeCk7XG4gICAgICBwdXRDZWxsSW50b0xheW91dChjZWxsLCBsYXlvdXQsIGosIHgpO1xuICAgICAgeCArPSBjZWxsLmNvbHNwYW47XG4gICAgICBjZWxsLmxpbmVzID0gY2VsbC50ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgIGNvbnN0IGNlbGxIZWlnaHQgPSBjZWxsLmxpbmVzLmxlbmd0aDtcbiAgICAgIHVwZGF0ZU9mZnNldChyb3dPZmZzZXRzLCBqLCBjZWxsLnJvd3NwYW4sIGNlbGxIZWlnaHQgKyByb3dTcGFjaW5nKTtcbiAgICB9XG4gICAgY29sTnVtYmVyID0gKGxheW91dFJvdy5sZW5ndGggPiBjb2xOdW1iZXIpID8gbGF5b3V0Um93Lmxlbmd0aCA6IGNvbE51bWJlcjtcbiAgfVxuXG4gIHRyYW5zcG9zZUluUGxhY2UobGF5b3V0LCAocm93TnVtYmVyID4gY29sTnVtYmVyKSA/IHJvd051bWJlciA6IGNvbE51bWJlcik7XG5cbiAgY29uc3Qgb3V0cHV0TGluZXMgPSBbXTtcbiAgY29uc3QgY29sT2Zmc2V0cyA9IFswXTtcbiAgLy8gRmlsbCBjb2x1bW4gb2Zmc2V0cyBhbmQgb3V0cHV0IGxpbmVzIGNvbHVtbi1ieS1jb2x1bW4uXG4gIGZvciAobGV0IHggPSAwOyB4IDwgY29sTnVtYmVyOyB4KyspIHtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNlbGw7XG4gICAgd2hpbGUgKHkgPCByb3dOdW1iZXIgJiYgKGNlbGwgPSBsYXlvdXRbeF1beV0pKSB7XG4gICAgICBpZiAoIWNlbGwucmVuZGVyZWQpIHtcbiAgICAgICAgbGV0IGNlbGxXaWR0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2VsbC5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGxpbmUgPSBjZWxsLmxpbmVzW2pdO1xuICAgICAgICAgIGNvbnN0IGxpbmVPZmZzZXQgPSByb3dPZmZzZXRzW3ldICsgajtcbiAgICAgICAgICBvdXRwdXRMaW5lc1tsaW5lT2Zmc2V0XSA9IChvdXRwdXRMaW5lc1tsaW5lT2Zmc2V0XSB8fCAnJykucGFkRW5kKGNvbE9mZnNldHNbeF0pICsgbGluZTtcbiAgICAgICAgICBjZWxsV2lkdGggPSAobGluZS5sZW5ndGggPiBjZWxsV2lkdGgpID8gbGluZS5sZW5ndGggOiBjZWxsV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlT2Zmc2V0KGNvbE9mZnNldHMsIHgsIGNlbGwuY29sc3BhbiwgY2VsbFdpZHRoICsgY29sU3BhY2luZyk7XG4gICAgICAgIGNlbGwucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgeSArPSBjZWxsLnJvd3NwYW47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dExpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBsaW5lLWJyZWFrLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRMaW5lQnJlYWsgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5hZGRMaW5lQnJlYWsoKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgYHdicmAgdGFnICh3b3JkIGJyZWFrIG9wcG9ydHVuaXR5KS5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0V2JyIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIuYWRkV29yZEJyZWFrT3Bwb3J0dW5pdHkoKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgaG9yaXpvbnRhbCBsaW5lLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRIb3Jpem9udGFsTGluZSAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5CbG9jayh7IGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG4gIGJ1aWxkZXIuYWRkSW5saW5lKCctJy5yZXBlYXQoZm9ybWF0T3B0aW9ucy5sZW5ndGggfHwgYnVpbGRlci5vcHRpb25zLndvcmR3cmFwIHx8IDQwKSk7XG4gIGJ1aWxkZXIuY2xvc2VCbG9jayh7IHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgcGFyYWdyYXBoLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRQYXJhZ3JhcGggKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuQmxvY2soeyBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xuICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICBidWlsZGVyLmNsb3NlQmxvY2soeyB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIHByZWZvcm1hdHRlZCBjb250ZW50LlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRQcmUgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuQmxvY2soe1xuICAgIGlzUHJlOiB0cnVlLFxuICAgIGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIHx8IDJcbiAgfSk7XG4gIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gIGJ1aWxkZXIuY2xvc2VCbG9jayh7IHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgaGVhZGluZy5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0SGVhZGluZyAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5CbG9jayh7IGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG4gIGlmIChmb3JtYXRPcHRpb25zLnVwcGVyY2FzZSAhPT0gZmFsc2UpIHtcbiAgICBidWlsZGVyLnB1c2hXb3JkVHJhbnNmb3JtKHN0ciA9PiBzdHIudG9VcHBlckNhc2UoKSk7XG4gICAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgICBidWlsZGVyLnBvcFdvcmRUcmFuc2Zvcm0oKTtcbiAgfSBlbHNlIHtcbiAgICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICB9XG4gIGJ1aWxkZXIuY2xvc2VCbG9jayh7IHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgYmxvY2txdW90ZS5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0QmxvY2txdW90ZSAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5CbG9jayh7XG4gICAgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfHwgMixcbiAgICByZXNlcnZlZExpbmVMZW5ndGg6IDJcbiAgfSk7XG4gIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gIGJ1aWxkZXIuY2xvc2VCbG9jayh7XG4gICAgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB8fCAyLFxuICAgIGJsb2NrVHJhbnNmb3JtOiBzdHIgPT4gKChmb3JtYXRPcHRpb25zLnRyaW1FbXB0eUxpbmVzICE9PSBmYWxzZSkgPyB0cmltQ2hhcmFjdGVyKHN0ciwgJ1xcbicpIDogc3RyKVxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLm1hcChsaW5lID0+ICc+ICcgKyBsaW5lKVxuICAgICAgLmpvaW4oJ1xcbicpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3aXRoQnJhY2tldHMgKHN0ciwgYnJhY2tldHMpIHtcbiAgaWYgKCFicmFja2V0cykgeyByZXR1cm4gc3RyOyB9XG5cbiAgY29uc3QgbGJyID0gKHR5cGVvZiBicmFja2V0c1swXSA9PT0gJ3N0cmluZycpXG4gICAgPyBicmFja2V0c1swXVxuICAgIDogJ1snO1xuICBjb25zdCByYnIgPSAodHlwZW9mIGJyYWNrZXRzWzFdID09PSAnc3RyaW5nJylcbiAgICA/IGJyYWNrZXRzWzFdXG4gICAgOiAnXSc7XG4gIHJldHVybiBsYnIgKyBzdHIgKyByYnI7XG59XG5cbmZ1bmN0aW9uIHBhdGhSZXdyaXRlIChwYXRoLCByZXdyaXRlciwgYmFzZVVybCwgbWV0YWRhdGEsIGVsZW0pIHtcbiAgY29uc3QgbW9kaWZpZWRQYXRoID0gKHR5cGVvZiByZXdyaXRlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICA/IHJld3JpdGVyKHBhdGgsIG1ldGFkYXRhLCBlbGVtKVxuICAgIDogcGF0aDtcbiAgcmV0dXJuIChtb2RpZmllZFBhdGhbMF0gPT09ICcvJyAmJiBiYXNlVXJsKVxuICAgID8gdHJpbUNoYXJhY3RlckVuZChiYXNlVXJsLCAnLycpICsgbW9kaWZpZWRQYXRoXG4gICAgOiBtb2RpZmllZFBhdGg7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhbiBpbWFnZS5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0SW1hZ2UgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgY29uc3QgYXR0cmlicyA9IGVsZW0uYXR0cmlicyB8fCB7fTtcbiAgY29uc3QgYWx0ID0gKGF0dHJpYnMuYWx0KVxuICAgID8gYXR0cmlicy5hbHRcbiAgICA6ICcnO1xuICBjb25zdCBzcmMgPSAoIWF0dHJpYnMuc3JjKVxuICAgID8gJydcbiAgICA6IHBhdGhSZXdyaXRlKGF0dHJpYnMuc3JjLCBmb3JtYXRPcHRpb25zLnBhdGhSZXdyaXRlLCBmb3JtYXRPcHRpb25zLmJhc2VVcmwsIGJ1aWxkZXIubWV0YWRhdGEsIGVsZW0pO1xuICBjb25zdCB0ZXh0ID0gKCFzcmMpXG4gICAgPyBhbHRcbiAgICA6ICghYWx0KVxuICAgICAgPyB3aXRoQnJhY2tldHMoc3JjLCBmb3JtYXRPcHRpb25zLmxpbmtCcmFja2V0cylcbiAgICAgIDogYWx0ICsgJyAnICsgd2l0aEJyYWNrZXRzKHNyYywgZm9ybWF0T3B0aW9ucy5saW5rQnJhY2tldHMpO1xuXG4gIGJ1aWxkZXIuYWRkSW5saW5lKHRleHQsIHsgbm9Xb3JkVHJhbnNmb3JtOiB0cnVlIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYW4gYW5jaG9yLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRBbmNob3IgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgZnVuY3Rpb24gZ2V0SHJlZiAoKSB7XG4gICAgaWYgKGZvcm1hdE9wdGlvbnMuaWdub3JlSHJlZikgeyByZXR1cm4gJyc7IH1cbiAgICBpZiAoIWVsZW0uYXR0cmlicyB8fCAhZWxlbS5hdHRyaWJzLmhyZWYpIHsgcmV0dXJuICcnOyB9XG4gICAgbGV0IGhyZWYgPSBlbGVtLmF0dHJpYnMuaHJlZi5yZXBsYWNlKC9ebWFpbHRvOi8sICcnKTtcbiAgICBpZiAoZm9ybWF0T3B0aW9ucy5ub0FuY2hvclVybCAmJiBocmVmWzBdID09PSAnIycpIHsgcmV0dXJuICcnOyB9XG4gICAgaHJlZiA9IHBhdGhSZXdyaXRlKGhyZWYsIGZvcm1hdE9wdGlvbnMucGF0aFJld3JpdGUsIGZvcm1hdE9wdGlvbnMuYmFzZVVybCwgYnVpbGRlci5tZXRhZGF0YSwgZWxlbSk7XG4gICAgcmV0dXJuIGhyZWY7XG4gIH1cbiAgY29uc3QgaHJlZiA9IGdldEhyZWYoKTtcbiAgaWYgKCFocmVmKSB7XG4gICAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgdGV4dCA9ICcnO1xuICAgIGJ1aWxkZXIucHVzaFdvcmRUcmFuc2Zvcm0oXG4gICAgICBzdHIgPT4ge1xuICAgICAgICBpZiAoc3RyKSB7IHRleHQgKz0gc3RyOyB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgKTtcbiAgICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICAgIGJ1aWxkZXIucG9wV29yZFRyYW5zZm9ybSgpO1xuXG4gICAgY29uc3QgaGlkZVNhbWVMaW5rID0gZm9ybWF0T3B0aW9ucy5oaWRlTGlua0hyZWZJZlNhbWVBc1RleHQgJiYgaHJlZiA9PT0gdGV4dDtcbiAgICBpZiAoIWhpZGVTYW1lTGluaykge1xuICAgICAgYnVpbGRlci5hZGRJbmxpbmUoXG4gICAgICAgICghdGV4dClcbiAgICAgICAgICA/IGhyZWZcbiAgICAgICAgICA6ICcgJyArIHdpdGhCcmFja2V0cyhocmVmLCBmb3JtYXRPcHRpb25zLmxpbmtCcmFja2V0cyksXG4gICAgICAgIHsgbm9Xb3JkVHJhbnNmb3JtOiB0cnVlIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHsgRG9tTm9kZSB9ICAgICAgICAgICBlbGVtICAgICAgICAgICAgICAgTGlzdCBpdGVtcyB3aXRoIHRoZWlyIHByZWZpeGVzLlxuICogQHBhcmFtIHsgUmVjdXJzaXZlQ2FsbGJhY2sgfSB3YWxrICAgICAgICAgICAgICAgUmVjdXJzaXZlIGNhbGxiYWNrIHRvIHByb2Nlc3MgY2hpbGQgbm9kZXMuXG4gKiBAcGFyYW0geyBCbG9ja1RleHRCdWlsZGVyIH0gIGJ1aWxkZXIgICAgICAgICAgICBQYXNzZWQgYXJvdW5kIHRvIGFjY3VtdWxhdGUgb3V0cHV0IHRleHQuXG4gKiBAcGFyYW0geyBGb3JtYXRPcHRpb25zIH0gICAgIGZvcm1hdE9wdGlvbnMgICAgICBPcHRpb25zIHNwZWNpZmljIHRvIGEgZm9ybWF0dGVyLlxuICogQHBhcmFtIHsgKCkgPT4gc3RyaW5nIH0gICAgICBuZXh0UHJlZml4Q2FsbGJhY2sgRnVuY3Rpb24gdGhhdCByZXR1cm5zIGluY3JlYXNpbmcgaW5kZXggZWFjaCB0aW1lIGl0IGlzIGNhbGxlZC5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0TGlzdCAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucywgbmV4dFByZWZpeENhbGxiYWNrKSB7XG4gIGNvbnN0IGlzTmVzdGVkTGlzdCA9IGdldChlbGVtLCBbJ3BhcmVudCcsICduYW1lJ10pID09PSAnbGknO1xuXG4gIC8vIFdpdGggUm9tYW4gbnVtYmVycywgaW5kZXggbGVuZ3RoIGlzIG5vdCBhcyBzdHJhaWdodGZvcndhcmQgYXMgd2l0aCBBcmFiaWMgbnVtYmVycyBvciBsZXR0ZXJzLFxuICAvLyBzbyB0aGUgZHVtYiBsZW5ndGggY29tcGFyaXNvbiBpcyB0aGUgbW9zdCByb2J1c3Qgd2F5IHRvIGdldCB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgbGV0IG1heFByZWZpeExlbmd0aCA9IDA7XG4gIGNvbnN0IGxpc3RJdGVtcyA9IChlbGVtLmNoaWxkcmVuIHx8IFtdKVxuICAgIC8vIGl0IG1pZ2h0IGJlIG1vcmUgYWNjdXJhdGUgdG8gY2hlY2sgb25seSBmb3IgaHRtbCBzcGFjZXMgaGVyZSwgYnV0IG5vIHNpZ25pZmljYW50IGJlbmVmaXRcbiAgICAuZmlsdGVyKGNoaWxkID0+IGNoaWxkLnR5cGUgIT09ICd0ZXh0JyB8fCAhL15cXHMqJC8udGVzdChjaGlsZC5kYXRhKSlcbiAgICAubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLm5hbWUgIT09ICdsaScpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogY2hpbGQsIHByZWZpeDogJycgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZWZpeCA9IChpc05lc3RlZExpc3QpXG4gICAgICAgID8gbmV4dFByZWZpeENhbGxiYWNrKCkudHJpbVN0YXJ0KClcbiAgICAgICAgOiBuZXh0UHJlZml4Q2FsbGJhY2soKTtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoID4gbWF4UHJlZml4TGVuZ3RoKSB7IG1heFByZWZpeExlbmd0aCA9IHByZWZpeC5sZW5ndGg7IH1cbiAgICAgIHJldHVybiB7IG5vZGU6IGNoaWxkLCBwcmVmaXg6IHByZWZpeCB9O1xuICAgIH0pO1xuICBpZiAoIWxpc3RJdGVtcy5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cbiAgYnVpbGRlci5vcGVuTGlzdCh7XG4gICAgaW50ZXJSb3dMaW5lQnJlYWtzOiAxLFxuICAgIGxlYWRpbmdMaW5lQnJlYWtzOiBpc05lc3RlZExpc3QgPyAxIDogKGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfHwgMiksXG4gICAgbWF4UHJlZml4TGVuZ3RoOiBtYXhQcmVmaXhMZW5ndGgsXG4gICAgcHJlZml4QWxpZ246ICdsZWZ0J1xuICB9KTtcblxuICBmb3IgKGNvbnN0IHsgbm9kZSwgcHJlZml4IH0gb2YgbGlzdEl0ZW1zKSB7XG4gICAgYnVpbGRlci5vcGVuTGlzdEl0ZW0oeyBwcmVmaXg6IHByZWZpeCB9KTtcbiAgICB3YWxrKFtub2RlXSwgYnVpbGRlcik7XG4gICAgYnVpbGRlci5jbG9zZUxpc3RJdGVtKCk7XG4gIH1cblxuICBidWlsZGVyLmNsb3NlTGlzdCh7IHRyYWlsaW5nTGluZUJyZWFrczogaXNOZXN0ZWRMaXN0ID8gMSA6IChmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB8fCAyKSB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGFuIHVub3JkZXJlZCBsaXN0LlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRVbm9yZGVyZWRMaXN0IChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGNvbnN0IHByZWZpeCA9IGZvcm1hdE9wdGlvbnMuaXRlbVByZWZpeCB8fCAnICogJztcbiAgcmV0dXJuIGZvcm1hdExpc3QoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucywgKCkgPT4gcHJlZml4KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGFuIG9yZGVyZWQgbGlzdC5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0T3JkZXJlZExpc3QgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgbGV0IG5leHRJbmRleCA9IE51bWJlcihlbGVtLmF0dHJpYnMuc3RhcnQgfHwgJzEnKTtcbiAgY29uc3QgaW5kZXhGdW5jdGlvbiA9IGdldE9yZGVyZWRMaXN0SW5kZXhGdW5jdGlvbihlbGVtLmF0dHJpYnMudHlwZSk7XG4gIGNvbnN0IG5leHRQcmVmaXhDYWxsYmFjayA9ICgpID0+ICcgJyArIGluZGV4RnVuY3Rpb24obmV4dEluZGV4KyspICsgJy4gJztcbiAgcmV0dXJuIGZvcm1hdExpc3QoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucywgbmV4dFByZWZpeENhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGluZGV4IG1hcmtlcnMgb2YgYSBzcGVjaWZpZWQgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gW29sVHlwZT0nMSddIE1hcmtlciB0eXBlLlxuICogQHJldHVybnMgeyAoaTogbnVtYmVyKSA9PiBzdHJpbmcgfVxuICovXG5mdW5jdGlvbiBnZXRPcmRlcmVkTGlzdEluZGV4RnVuY3Rpb24gKG9sVHlwZSA9ICcxJykge1xuICBzd2l0Y2ggKG9sVHlwZSkge1xuICAgIGNhc2UgJ2EnOiByZXR1cm4gKGkpID0+IG51bWJlclRvTGV0dGVyU2VxdWVuY2UoaSwgJ2EnKTtcbiAgICBjYXNlICdBJzogcmV0dXJuIChpKSA9PiBudW1iZXJUb0xldHRlclNlcXVlbmNlKGksICdBJyk7XG4gICAgY2FzZSAnaSc6IHJldHVybiAoaSkgPT4gbnVtYmVyVG9Sb21hbihpKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNhc2UgJ0knOiByZXR1cm4gKGkpID0+IG51bWJlclRvUm9tYW4oaSk7XG4gICAgY2FzZSAnMSc6XG4gICAgZGVmYXVsdDogcmV0dXJuIChpKSA9PiAoaSkudG9TdHJpbmcoKTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiBjbGFzcyBhbmQgSUQgc2VsZWN0b3JzIChwcmVmaXhlZCB3aXRoICcuJyBhbmQgJyMnKSxcbiAqIHJldHVybiB0aGVtIGFzIHNlcGFyYXRlIGxpc3RzIG9mIG5hbWVzIHdpdGhvdXQgcHJlZml4ZXMuXG4gKlxuICogQHBhcmFtIHsgc3RyaW5nW10gfSBzZWxlY3RvcnMgQ2xhc3MgYW5kIElEIHNlbGVjdG9ycyAoYFtcIi5jbGFzc1wiLCBcIiNpZFwiXWAgZXRjKS5cbiAqIEByZXR1cm5zIHsgeyBjbGFzc2VzOiBzdHJpbmdbXSwgaWRzOiBzdHJpbmdbXSB9IH1cbiAqL1xuZnVuY3Rpb24gc3BsaXRDbGFzc2VzQW5kSWRzIChzZWxlY3RvcnMpIHtcbiAgY29uc3QgY2xhc3NlcyA9IFtdO1xuICBjb25zdCBpZHMgPSBbXTtcbiAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBzZWxlY3RvcnMpIHtcbiAgICBpZiAoc2VsZWN0b3Iuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICBjbGFzc2VzLnB1c2goc2VsZWN0b3Iuc3Vic3RyaW5nKDEpKTtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgaWRzLnB1c2goc2VsZWN0b3Iuc3Vic3RyaW5nKDEpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgY2xhc3NlczogY2xhc3NlcywgaWRzOiBpZHMgfTtcbn1cblxuZnVuY3Rpb24gaXNEYXRhVGFibGUgKGF0dHIsIHRhYmxlcykge1xuICBpZiAodGFibGVzID09PSB0cnVlKSB7IHJldHVybiB0cnVlOyB9XG4gIGlmICghYXR0cikgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjb25zdCB7IGNsYXNzZXMsIGlkcyB9ID0gc3BsaXRDbGFzc2VzQW5kSWRzKHRhYmxlcyk7XG4gIGNvbnN0IGF0dHJDbGFzc2VzID0gKGF0dHJbJ2NsYXNzJ10gfHwgJycpLnNwbGl0KCcgJyk7XG4gIGNvbnN0IGF0dHJJZHMgPSAoYXR0clsnaWQnXSB8fCAnJykuc3BsaXQoJyAnKTtcblxuICByZXR1cm4gYXR0ckNsYXNzZXMuc29tZSh4ID0+IGNsYXNzZXMuaW5jbHVkZXMoeCkpIHx8IGF0dHJJZHMuc29tZSh4ID0+IGlkcy5pbmNsdWRlcyh4KSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIHRhYmxlIChlaXRoZXIgYXMgYSBjb250YWluZXIgb3IgYXMgYSBkYXRhIHRhYmxlLCBkZXBlbmRpbmcgb24gb3B0aW9ucykuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFRhYmxlIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIHJldHVybiBpc0RhdGFUYWJsZShlbGVtLmF0dHJpYnMsIGJ1aWxkZXIub3B0aW9ucy50YWJsZXMpXG4gICAgPyBmb3JtYXREYXRhVGFibGUoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucylcbiAgICA6IGZvcm1hdEJsb2NrKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRCbG9jayAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5CbG9jayh7IGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIH0pO1xuICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICBidWlsZGVyLmNsb3NlQmxvY2soeyB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBkYXRhIHRhYmxlLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXREYXRhVGFibGUgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuVGFibGUoKTtcbiAgZWxlbS5jaGlsZHJlbi5mb3JFYWNoKHdhbGtUYWJsZSk7XG4gIGJ1aWxkZXIuY2xvc2VUYWJsZSh7XG4gICAgdGFibGVUb1N0cmluZzogKHJvd3MpID0+IHRhYmxlVG9TdHJpbmcocm93cywgZm9ybWF0T3B0aW9ucy5yb3dTcGFjaW5nID8/IDAsIGZvcm1hdE9wdGlvbnMuY29sU3BhY2luZyA/PyAzKSxcbiAgICBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyxcbiAgICB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdENlbGwgKGNlbGxOb2RlKSB7XG4gICAgY29uc3QgY29sc3BhbiA9ICtnZXQoY2VsbE5vZGUsIFsnYXR0cmlicycsICdjb2xzcGFuJ10pIHx8IDE7XG4gICAgY29uc3Qgcm93c3BhbiA9ICtnZXQoY2VsbE5vZGUsIFsnYXR0cmlicycsICdyb3dzcGFuJ10pIHx8IDE7XG4gICAgYnVpbGRlci5vcGVuVGFibGVDZWxsKHsgbWF4Q29sdW1uV2lkdGg6IGZvcm1hdE9wdGlvbnMubWF4Q29sdW1uV2lkdGggfSk7XG4gICAgd2FsayhjZWxsTm9kZS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gICAgYnVpbGRlci5jbG9zZVRhYmxlQ2VsbCh7IGNvbHNwYW46IGNvbHNwYW4sIHJvd3NwYW46IHJvd3NwYW4gfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWxrVGFibGUgKGVsZW0pIHtcbiAgICBpZiAoZWxlbS50eXBlICE9PSAndGFnJykgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IGZvcm1hdEhlYWRlckNlbGwgPSAoZm9ybWF0T3B0aW9ucy51cHBlcmNhc2VIZWFkZXJDZWxscyAhPT0gZmFsc2UpXG4gICAgICA/IChjZWxsTm9kZSkgPT4ge1xuICAgICAgICBidWlsZGVyLnB1c2hXb3JkVHJhbnNmb3JtKHN0ciA9PiBzdHIudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIGZvcm1hdENlbGwoY2VsbE5vZGUpO1xuICAgICAgICBidWlsZGVyLnBvcFdvcmRUcmFuc2Zvcm0oKTtcbiAgICAgIH1cbiAgICAgIDogZm9ybWF0Q2VsbDtcblxuICAgIHN3aXRjaCAoZWxlbS5uYW1lKSB7XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBlbGVtLmNoaWxkcmVuLmZvckVhY2god2Fsa1RhYmxlKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICd0cic6IHtcbiAgICAgICAgYnVpbGRlci5vcGVuVGFibGVSb3coKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZE9mVHIgb2YgZWxlbS5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChjaGlsZE9mVHIudHlwZSAhPT0gJ3RhZycpIHsgY29udGludWU7IH1cbiAgICAgICAgICBzd2l0Y2ggKGNoaWxkT2ZUci5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlICd0aCc6IHtcbiAgICAgICAgICAgICAgZm9ybWF0SGVhZGVyQ2VsbChjaGlsZE9mVHIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3RkJzoge1xuICAgICAgICAgICAgICBmb3JtYXRDZWxsKGNoaWxkT2ZUcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1aWxkZXIuY2xvc2VUYWJsZVJvdygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgfVxufVxuXG52YXIgdGV4dEZvcm1hdHRlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYW5jaG9yOiBmb3JtYXRBbmNob3IsXG4gIGJsb2NrcXVvdGU6IGZvcm1hdEJsb2NrcXVvdGUsXG4gIGRhdGFUYWJsZTogZm9ybWF0RGF0YVRhYmxlLFxuICBoZWFkaW5nOiBmb3JtYXRIZWFkaW5nLFxuICBob3Jpem9udGFsTGluZTogZm9ybWF0SG9yaXpvbnRhbExpbmUsXG4gIGltYWdlOiBmb3JtYXRJbWFnZSxcbiAgbGluZUJyZWFrOiBmb3JtYXRMaW5lQnJlYWssXG4gIG9yZGVyZWRMaXN0OiBmb3JtYXRPcmRlcmVkTGlzdCxcbiAgcGFyYWdyYXBoOiBmb3JtYXRQYXJhZ3JhcGgsXG4gIHByZTogZm9ybWF0UHJlLFxuICB0YWJsZTogZm9ybWF0VGFibGUsXG4gIHVub3JkZXJlZExpc3Q6IGZvcm1hdFVub3JkZXJlZExpc3QsXG4gIHdicjogZm9ybWF0V2JyXG59KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7IE9wdGlvbnMgfVxuICogQGRlZmF1bHRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgYmFzZUVsZW1lbnRzOiB7XG4gICAgc2VsZWN0b3JzOiBbICdib2R5JyBdLFxuICAgIG9yZGVyQnk6ICdzZWxlY3RvcnMnLCAvLyAnc2VsZWN0b3JzJyB8ICdvY2N1cnJlbmNlJ1xuICAgIHJldHVybkRvbUJ5RGVmYXVsdDogdHJ1ZVxuICB9LFxuICBkZWNvZGVFbnRpdGllczogdHJ1ZSxcbiAgZW5jb2RlQ2hhcmFjdGVyczoge30sXG4gIGZvcm1hdHRlcnM6IHt9LFxuICBsaW1pdHM6IHtcbiAgICBlbGxpcHNpczogJy4uLicsXG4gICAgbWF4QmFzZUVsZW1lbnRzOiB1bmRlZmluZWQsXG4gICAgbWF4Q2hpbGROb2RlczogdW5kZWZpbmVkLFxuICAgIG1heERlcHRoOiB1bmRlZmluZWQsXG4gICAgbWF4SW5wdXRMZW5ndGg6ICgxIDw8IDI0KSAvLyAxNl83NzdfMjE2XG4gIH0sXG4gIGxvbmdXb3JkU3BsaXQ6IHtcbiAgICBmb3JjZVdyYXBPbkxpbWl0OiBmYWxzZSxcbiAgICB3cmFwQ2hhcmFjdGVyczogW11cbiAgfSxcbiAgcHJlc2VydmVOZXdsaW5lczogZmFsc2UsXG4gIHNlbGVjdG9yczogW1xuICAgIHsgc2VsZWN0b3I6ICcqJywgZm9ybWF0OiAnaW5saW5lJyB9LFxuICAgIHtcbiAgICAgIHNlbGVjdG9yOiAnYScsXG4gICAgICBmb3JtYXQ6ICdhbmNob3InLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBiYXNlVXJsOiBudWxsLFxuICAgICAgICBoaWRlTGlua0hyZWZJZlNhbWVBc1RleHQ6IGZhbHNlLFxuICAgICAgICBpZ25vcmVIcmVmOiBmYWxzZSxcbiAgICAgICAgbGlua0JyYWNrZXRzOiBbJ1snLCAnXSddLFxuICAgICAgICBub0FuY2hvclVybDogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgeyBzZWxlY3RvcjogJ2FydGljbGUnLCBmb3JtYXQ6ICdibG9jaycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDEsIHRyYWlsaW5nTGluZUJyZWFrczogMSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ2FzaWRlJywgZm9ybWF0OiAnYmxvY2snLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAxLCB0cmFpbGluZ0xpbmVCcmVha3M6IDEgfSB9LFxuICAgIHtcbiAgICAgIHNlbGVjdG9yOiAnYmxvY2txdW90ZScsXG4gICAgICBmb3JtYXQ6ICdibG9ja3F1b3RlJyxcbiAgICAgIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDIsIHRyYWlsaW5nTGluZUJyZWFrczogMiwgdHJpbUVtcHR5TGluZXM6IHRydWUgfVxuICAgIH0sXG4gICAgeyBzZWxlY3RvcjogJ2JyJywgZm9ybWF0OiAnbGluZUJyZWFrJyB9LFxuICAgIHsgc2VsZWN0b3I6ICdkaXYnLCBmb3JtYXQ6ICdibG9jaycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDEsIHRyYWlsaW5nTGluZUJyZWFrczogMSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ2Zvb3RlcicsIGZvcm1hdDogJ2Jsb2NrJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMSwgdHJhaWxpbmdMaW5lQnJlYWtzOiAxIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnZm9ybScsIGZvcm1hdDogJ2Jsb2NrJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMSwgdHJhaWxpbmdMaW5lQnJlYWtzOiAxIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnaDEnLCBmb3JtYXQ6ICdoZWFkaW5nJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMywgdHJhaWxpbmdMaW5lQnJlYWtzOiAyLCB1cHBlcmNhc2U6IHRydWUgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdoMicsIGZvcm1hdDogJ2hlYWRpbmcnLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAzLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIsIHVwcGVyY2FzZTogdHJ1ZSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ2gzJywgZm9ybWF0OiAnaGVhZGluZycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDMsIHRyYWlsaW5nTGluZUJyZWFrczogMiwgdXBwZXJjYXNlOiB0cnVlIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnaDQnLCBmb3JtYXQ6ICdoZWFkaW5nJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMiwgdHJhaWxpbmdMaW5lQnJlYWtzOiAyLCB1cHBlcmNhc2U6IHRydWUgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdoNScsIGZvcm1hdDogJ2hlYWRpbmcnLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAyLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIsIHVwcGVyY2FzZTogdHJ1ZSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ2g2JywgZm9ybWF0OiAnaGVhZGluZycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDIsIHRyYWlsaW5nTGluZUJyZWFrczogMiwgdXBwZXJjYXNlOiB0cnVlIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnaGVhZGVyJywgZm9ybWF0OiAnYmxvY2snLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAxLCB0cmFpbGluZ0xpbmVCcmVha3M6IDEgfSB9LFxuICAgIHtcbiAgICAgIHNlbGVjdG9yOiAnaHInLFxuICAgICAgZm9ybWF0OiAnaG9yaXpvbnRhbExpbmUnLFxuICAgICAgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMiwgbGVuZ3RoOiB1bmRlZmluZWQsIHRyYWlsaW5nTGluZUJyZWFrczogMiB9XG4gICAgfSxcbiAgICB7XG4gICAgICBzZWxlY3RvcjogJ2ltZycsXG4gICAgICBmb3JtYXQ6ICdpbWFnZScsXG4gICAgICBvcHRpb25zOiB7IGJhc2VVcmw6IG51bGwsIGxpbmtCcmFja2V0czogWydbJywgJ10nXSB9XG4gICAgfSxcbiAgICB7IHNlbGVjdG9yOiAnbWFpbicsIGZvcm1hdDogJ2Jsb2NrJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMSwgdHJhaWxpbmdMaW5lQnJlYWtzOiAxIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnbmF2JywgZm9ybWF0OiAnYmxvY2snLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAxLCB0cmFpbGluZ0xpbmVCcmVha3M6IDEgfSB9LFxuICAgIHtcbiAgICAgIHNlbGVjdG9yOiAnb2wnLFxuICAgICAgZm9ybWF0OiAnb3JkZXJlZExpc3QnLFxuICAgICAgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMiwgdHJhaWxpbmdMaW5lQnJlYWtzOiAyIH1cbiAgICB9LFxuICAgIHsgc2VsZWN0b3I6ICdwJywgZm9ybWF0OiAncGFyYWdyYXBoJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMiwgdHJhaWxpbmdMaW5lQnJlYWtzOiAyIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAncHJlJywgZm9ybWF0OiAncHJlJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMiwgdHJhaWxpbmdMaW5lQnJlYWtzOiAyIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnc2VjdGlvbicsIGZvcm1hdDogJ2Jsb2NrJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMSwgdHJhaWxpbmdMaW5lQnJlYWtzOiAxIH0gfSxcbiAgICB7XG4gICAgICBzZWxlY3RvcjogJ3RhYmxlJyxcbiAgICAgIGZvcm1hdDogJ3RhYmxlJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY29sU3BhY2luZzogMyxcbiAgICAgICAgbGVhZGluZ0xpbmVCcmVha3M6IDIsXG4gICAgICAgIG1heENvbHVtbldpZHRoOiA2MCxcbiAgICAgICAgcm93U3BhY2luZzogMCxcbiAgICAgICAgdHJhaWxpbmdMaW5lQnJlYWtzOiAyLFxuICAgICAgICB1cHBlcmNhc2VIZWFkZXJDZWxsczogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgc2VsZWN0b3I6ICd1bCcsXG4gICAgICBmb3JtYXQ6ICd1bm9yZGVyZWRMaXN0JyxcbiAgICAgIG9wdGlvbnM6IHsgaXRlbVByZWZpeDogJyAqICcsIGxlYWRpbmdMaW5lQnJlYWtzOiAyLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIgfVxuICAgIH0sXG4gICAgeyBzZWxlY3RvcjogJ3dicicsIGZvcm1hdDogJ3dicicgfSxcbiAgXSxcbiAgdGFibGVzOiBbXSwgLy8gZGVwcmVjYXRlZFxuICB3aGl0ZXNwYWNlQ2hhcmFjdGVyczogJyBcXHRcXHJcXG5cXGZcXHUyMDBiJyxcbiAgd29yZHdyYXA6IDgwXG59O1xuXG5jb25zdCBjb25jYXRNZXJnZSA9IChhY2MsIHNyYywgb3B0aW9ucykgPT4gWy4uLmFjYywgLi4uc3JjXTtcbmNvbnN0IG92ZXJ3cml0ZU1lcmdlID0gKGFjYywgc3JjLCBvcHRpb25zKSA9PiBbLi4uc3JjXTtcbmNvbnN0IHNlbGVjdG9yc01lcmdlID0gKGFjYywgc3JjLCBvcHRpb25zKSA9PiAoXG4gIChhY2Muc29tZShzID0+IHR5cGVvZiBzID09PSAnb2JqZWN0JykpXG4gICAgPyBjb25jYXRNZXJnZShhY2MsIHNyYykgLy8gc2VsZWN0b3JzXG4gICAgOiBvdmVyd3JpdGVNZXJnZShhY2MsIHNyYykgLy8gYmFzZUVsZW1lbnRzLnNlbGVjdG9yc1xuKTtcblxuLyoqXG4gKiBQcmVwcm9jZXNzIG9wdGlvbnMsIGNvbXBpbGUgc2VsZWN0b3JzIGludG8gYSBkZWNpc2lvbiB0cmVlLFxuICogcmV0dXJuIGEgZnVuY3Rpb24gaW50ZW5kZWQgZm9yIGJhdGNoIHByb2Nlc3NpbmcuXG4gKlxuICogQHBhcmFtICAgeyBPcHRpb25zIH0gW29wdGlvbnMgPSB7fV0gICBIdG1sVG9UZXh0IG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7IChodG1sOiBzdHJpbmcsIG1ldGFkYXRhPzogYW55KSA9PiBzdHJpbmcgfSBQcmUtY29uZmlndXJlZCBjb252ZXJ0ZXIgZnVuY3Rpb24uXG4gKiBAc3RhdGljXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zID0gbWVyZ2VfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFxuICAgIERFRkFVTFRfT1BUSU9OUyxcbiAgICBvcHRpb25zLFxuICAgIHtcbiAgICAgIGFycmF5TWVyZ2U6IG92ZXJ3cml0ZU1lcmdlLFxuICAgICAgY3VzdG9tTWVyZ2U6IChrZXkpID0+ICgoa2V5ID09PSAnc2VsZWN0b3JzJykgPyBzZWxlY3RvcnNNZXJnZSA6IHVuZGVmaW5lZClcbiAgICB9XG4gICk7XG4gIG9wdGlvbnMuZm9ybWF0dGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGdlbmVyaWNGb3JtYXR0ZXJzLCB0ZXh0Rm9ybWF0dGVycywgb3B0aW9ucy5mb3JtYXR0ZXJzKTtcbiAgb3B0aW9ucy5zZWxlY3RvcnMgPSBtZXJnZUR1cGxpY2F0ZXNQcmVmZXJMYXN0KG9wdGlvbnMuc2VsZWN0b3JzLCAocyA9PiBzLnNlbGVjdG9yKSk7XG5cbiAgaGFuZGxlRGVwcmVjYXRlZE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIGNvbXBpbGUkMShvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGdpdmVuIEhUTUwgY29udGVudCB0byBwbGFpbiB0ZXh0IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9ICBodG1sICAgICAgICAgICBIVE1MIGNvbnRlbnQgdG8gY29udmVydC5cbiAqIEBwYXJhbSAgIHsgT3B0aW9ucyB9IFtvcHRpb25zID0ge31dIEh0bWxUb1RleHQgb3B0aW9ucy5cbiAqIEBwYXJhbSAgIHsgYW55IH0gICAgIFttZXRhZGF0YV0gICAgIE9wdGlvbmFsIG1ldGFkYXRhIGZvciBIVE1MIGRvY3VtZW50LCBmb3IgdXNlIGluIGZvcm1hdHRlcnMuXG4gKiBAcmV0dXJucyB7IHN0cmluZyB9ICAgICAgICAgICAgICAgICBQbGFpbiB0ZXh0IHN0cmluZy5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgeyBjb252ZXJ0IH0gPSByZXF1aXJlKCdodG1sLXRvLXRleHQnKTtcbiAqIGNvbnN0IHRleHQgPSBjb252ZXJ0KCc8aDE+SGVsbG8gV29ybGQ8L2gxPicsIHtcbiAqICAgd29yZHdyYXA6IDEzMFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyh0ZXh0KTsgLy8gSEVMTE8gV09STERcbiAqL1xuZnVuY3Rpb24gY29udmVydCAoaHRtbCwgb3B0aW9ucyA9IHt9LCBtZXRhZGF0YSA9IHVuZGVmaW5lZCkge1xuICByZXR1cm4gY29tcGlsZShvcHRpb25zKShodG1sLCBtZXRhZGF0YSk7XG59XG5cbi8qKlxuICogTWFwIHByZXZpb3VzbHkgZXhpc3RpbmcgYW5kIG5vdyBkZXByZWNhdGVkIG9wdGlvbnMgdG8gdGhlIG5ldyBvcHRpb25zIGxheW91dC5cbiAqIFRoaXMgaXMgYSBzdWJqZWN0IGZvciBjbGVhbnVwIGluIG1ham9yIHJlbGVhc2VzLlxuICpcbiAqIEBwYXJhbSB7IE9wdGlvbnMgfSBvcHRpb25zIEh0bWxUb1RleHQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRGVwcmVjYXRlZE9wdGlvbnMgKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudGFncykge1xuICAgIGNvbnN0IHRhZ0RlZmluaXRpb25zID0gT2JqZWN0LmVudHJpZXMob3B0aW9ucy50YWdzKS5tYXAoXG4gICAgICAoW3NlbGVjdG9yLCBkZWZpbml0aW9uXSkgPT4gKHsgLi4uZGVmaW5pdGlvbiwgc2VsZWN0b3I6IHNlbGVjdG9yIHx8ICcqJyB9KVxuICAgICk7XG4gICAgb3B0aW9ucy5zZWxlY3RvcnMucHVzaCguLi50YWdEZWZpbml0aW9ucyk7XG4gICAgb3B0aW9ucy5zZWxlY3RvcnMgPSBtZXJnZUR1cGxpY2F0ZXNQcmVmZXJMYXN0KG9wdGlvbnMuc2VsZWN0b3JzLCAocyA9PiBzLnNlbGVjdG9yKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXQgKG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZUtleSA9IHBhdGgucG9wKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcGF0aCkge1xuICAgICAgbGV0IG5lc3RlZCA9IG9ialtrZXldO1xuICAgICAgaWYgKCFuZXN0ZWQpIHtcbiAgICAgICAgbmVzdGVkID0ge307XG4gICAgICAgIG9ialtrZXldID0gbmVzdGVkO1xuICAgICAgfVxuICAgICAgb2JqID0gbmVzdGVkO1xuICAgIH1cbiAgICBvYmpbdmFsdWVLZXldID0gdmFsdWU7XG4gIH1cblxuICBpZiAob3B0aW9uc1snYmFzZUVsZW1lbnQnXSkge1xuICAgIGNvbnN0IGJhc2VFbGVtZW50ID0gb3B0aW9uc1snYmFzZUVsZW1lbnQnXTtcbiAgICBzZXQoXG4gICAgICBvcHRpb25zLFxuICAgICAgWydiYXNlRWxlbWVudHMnLCAnc2VsZWN0b3JzJ10sXG4gICAgICAoQXJyYXkuaXNBcnJheShiYXNlRWxlbWVudCkgPyBiYXNlRWxlbWVudCA6IFtiYXNlRWxlbWVudF0pXG4gICAgKTtcbiAgfVxuICBpZiAob3B0aW9uc1sncmV0dXJuRG9tQnlEZWZhdWx0J10gIT09IHVuZGVmaW5lZCkge1xuICAgIHNldChvcHRpb25zLCBbJ2Jhc2VFbGVtZW50cycsICdyZXR1cm5Eb21CeURlZmF1bHQnXSwgb3B0aW9uc1sncmV0dXJuRG9tQnlEZWZhdWx0J10pO1xuICB9XG5cbiAgZm9yIChjb25zdCBkZWZpbml0aW9uIG9mIG9wdGlvbnMuc2VsZWN0b3JzKSB7XG4gICAgaWYgKGRlZmluaXRpb24uZm9ybWF0ID09PSAnYW5jaG9yJyAmJiBnZXQoZGVmaW5pdGlvbiwgWydvcHRpb25zJywgJ25vTGlua0JyYWNrZXRzJ10pKSB7XG4gICAgICBzZXQoZGVmaW5pdGlvbiwgWydvcHRpb25zJywgJ2xpbmtCcmFja2V0cyddLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG5leHBvcnRzLmNvbnZlcnQgPSBjb252ZXJ0O1xuZXhwb3J0cy5odG1sVG9UZXh0ID0gY29udmVydDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBsdWdpbkh0bWxwYXJzZXIyIiwicmVxdWlyZSIsImh0bWxwYXJzZXIyIiwic2VsZGVyZWUiLCJtZXJnZSIsImRvbVNlcmlhbGl6ZXIiLCJfaW50ZXJvcERlZmF1bHRMZWdhY3kiLCJlIiwibWVyZ2VfX2RlZmF1bHQiLCJsaW1pdGVkRGVwdGhSZWN1cnNpdmUiLCJuIiwiZiIsImciLCJ1bmRlZmluZWQiLCJmMSIsImFyZ3MiLCJ0cmltQ2hhcmFjdGVyIiwic3RyIiwiY2hhciIsInN0YXJ0IiwiZW5kIiwibGVuZ3RoIiwic3Vic3RyaW5nIiwidHJpbUNoYXJhY3RlckVuZCIsInVuaWNvZGVFc2NhcGUiLCJyZXBsYWNlIiwiYyIsImNoYXJDb2RlQXQiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwibWVyZ2VEdXBsaWNhdGVzUHJlZmVyTGFzdCIsIml0ZW1zIiwiZ2V0S2V5IiwibWFwIiwiTWFwIiwiaSIsIml0ZW0iLCJrZXkiLCJzZXQiLCJoYXMiLCJnZXQiLCJhcnJheU1lcmdlIiwib3ZlcndyaXRlTWVyZ2UkMSIsInZhbHVlcyIsInJldmVyc2UiLCJhY2MiLCJzcmMiLCJvcHRpb25zIiwib2JqIiwicGF0aCIsIm51bWJlclRvTGV0dGVyU2VxdWVuY2UiLCJudW0iLCJiYXNlQ2hhciIsImJhc2UiLCJkaWdpdHMiLCJwdXNoIiwiYmFzZUNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJqb2luIiwiSSIsIlYiLCJudW1iZXJUb1JvbWFuIiwidiIsInJlcGVhdCIsIklubGluZVRleHRCdWlsZGVyIiwiY29uc3RydWN0b3IiLCJtYXhMaW5lTGVuZ3RoIiwibGluZXMiLCJuZXh0TGluZVdvcmRzIiwid29yZHdyYXAiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJuZXh0TGluZUF2YWlsYWJsZUNoYXJzIiwid3JhcENoYXJhY3RlcnMiLCJmb3JjZVdyYXBPbkxpbWl0Iiwic3Rhc2hlZFNwYWNlIiwid29yZEJyZWFrT3Bwb3J0dW5pdHkiLCJwdXNoV29yZCIsIndvcmQiLCJub1dyYXAiLCJzdGFydE5ld0xpbmUiLCJpc0xpbmVTdGFydCIsImNvc3QiLCJmaXJzdCIsInJlc3QiLCJzcGxpdExvbmdXb3JkIiwicGFydCIsInBvcFdvcmQiLCJsYXN0V29yZCIsInBvcCIsImNvbmNhdFdvcmQiLCJjb25jYXQiLCJBcnJheSIsImZyb20iLCJpc0VtcHR5IiwiY2xlYXIiLCJ3b3JkcyIsInBhcnRzIiwiaWR4IiwiZmlyc3RMaW5lIiwicmVtYWluaW5nQ2hhcnMiLCJzcGxpdEluZGV4IiwibGFzdEluZGV4T2YiLCJTdGFja0l0ZW0iLCJuZXh0IiwiZ2V0Um9vdCIsIkJsb2NrU3RhY2tJdGVtIiwibGVhZGluZ0xpbmVCcmVha3MiLCJpbmxpbmVUZXh0QnVpbGRlciIsInJhd1RleHQiLCJzdGFzaGVkTGluZUJyZWFrcyIsImlzUHJlIiwiaXNOb1dyYXAiLCJMaXN0U3RhY2tJdGVtIiwiaW50ZXJSb3dMaW5lQnJlYWtzIiwibWF4UHJlZml4TGVuZ3RoIiwicHJlZml4QWxpZ24iLCJMaXN0SXRlbVN0YWNrSXRlbSIsInByZWZpeCIsIlRhYmxlU3RhY2tJdGVtIiwicm93cyIsIlRhYmxlUm93U3RhY2tJdGVtIiwiY2VsbHMiLCJUYWJsZUNlbGxTdGFja0l0ZW0iLCJtYXhDb2x1bW5XaWR0aCIsIlRyYW5zZm9ybWVyU3RhY2tJdGVtIiwidHJhbnNmb3JtIiwiY2hhcmFjdGVyc1RvQ29kZXMiLCJXaGl0ZXNwYWNlUHJvY2Vzc29yIiwid2hpdGVzcGFjZUNoYXJzIiwicHJlc2VydmVOZXdsaW5lcyIsIndoaXRlc3BhY2VDaGFyYWN0ZXJzIiwid2hpdGVzcGFjZUNvZGVzIiwibGVhZGluZ1doaXRlc3BhY2VSZSIsIlJlZ0V4cCIsInRyYWlsaW5nV2hpdGVzcGFjZVJlIiwiYWxsV2hpdGVzcGFjZU9yRW1wdHlSZSIsIm5ld2xpbmVPck5vbldoaXRlc3BhY2VSZSIsIm5ld2xpbmVPck5vbk5ld2xpbmVTdHJpbmdSZSIsIndvcmRPck5ld2xpbmVSZSIsInNocmlua1dyYXBBZGQiLCJ0ZXh0IiwicHJldmlvdXNseVN0YXNoZWRTcGFjZSIsImFueU1hdGNoIiwibSIsImV4ZWMiLCJ0ZXN0TGVhZGluZ1doaXRlc3BhY2UiLCJ0ZXN0VHJhaWxpbmdXaGl0ZXNwYWNlIiwid29yZFJlIiwiYWRkTGl0ZXJhbCIsInRlc3QiLCJ0ZXN0Q29udGFpbnNXb3JkcyIsImNvdW50TmV3bGluZXNOb1dvcmRzIiwibGFzdEluZGV4IiwiY291bnRlciIsIm1hdGNoIiwiQmxvY2tUZXh0QnVpbGRlciIsInBpY2tlciIsIm1ldGFkYXRhIiwid2hpdGVzcGFjZVByb2Nlc3NvciIsIl9zdGFja0l0ZW0iLCJfd29yZFRyYW5zZm9ybWVyIiwicHVzaFdvcmRUcmFuc2Zvcm0iLCJ3b3JkVHJhbnNmb3JtIiwicG9wV29yZFRyYW5zZm9ybSIsInN0YXJ0Tm9XcmFwIiwic3RvcE5vV3JhcCIsIl9nZXRDb21iaW5lZFdvcmRUcmFuc2Zvcm1lciIsInd0IiwiYXBwbHlUcmFuc2Zvcm1lciIsImNlIiwiZW5jb2RlQ2hhcmFjdGVycyIsIl9wb3BTdGFja0l0ZW0iLCJhZGRMaW5lQnJlYWsiLCJhZGRXb3JkQnJlYWtPcHBvcnR1bml0eSIsImFkZElubGluZSIsIm5vV29yZFRyYW5zZm9ybSIsIm5ld2xpbmVzTnVtYmVyIiwib3BlbkJsb2NrIiwicmVzZXJ2ZWRMaW5lTGVuZ3RoIiwiTWF0aCIsIm1heCIsImNsb3NlQmxvY2siLCJ0cmFpbGluZ0xpbmVCcmVha3MiLCJibG9ja1RyYW5zZm9ybSIsImJsb2NrIiwiYmxvY2tUZXh0IiwiZ2V0VGV4dCIsImFkZFRleHQiLCJvcGVuTGlzdCIsIm9wZW5MaXN0SXRlbSIsIkVycm9yIiwibGlzdCIsInByZWZpeExlbmd0aCIsImNsb3NlTGlzdEl0ZW0iLCJsaXN0SXRlbSIsInNwYWNpbmciLCJwYWRFbmQiLCJjbG9zZUxpc3QiLCJvcGVuVGFibGUiLCJvcGVuVGFibGVSb3ciLCJvcGVuVGFibGVDZWxsIiwiY2xvc2VUYWJsZUNlbGwiLCJjb2xzcGFuIiwicm93c3BhbiIsImNlbGwiLCJjbG9zZVRhYmxlUm93Iiwicm93IiwiY2xvc2VUYWJsZSIsInRhYmxlVG9TdHJpbmciLCJ0YWJsZSIsIm91dHB1dCIsInN0YWNrSXRlbSIsInBhcmVudFRleHQiLCJsaW5lQnJlYWtzIiwidHJhbnNmb3JtZXIiLCJjb21waWxlJDEiLCJzZWxlY3RvcnNXaXRob3V0Rm9ybWF0Iiwic2VsZWN0b3JzIiwiZmlsdGVyIiwicyIsImZvcm1hdCIsInNlbGVjdG9yIiwiRGVjaXNpb25UcmVlIiwiYnVpbGQiLCJocDJCdWlsZGVyIiwibWFrZVJlcGxhY2VyRnJvbURpY3QiLCJiYXNlU2VsZWN0b3JzUGlja2VyIiwiYmFzZUVsZW1lbnRzIiwiZmluZEJhc2VFbGVtZW50cyIsImRvbSIsImZpbmRCYXNlcyIsImxpbWl0ZWRXYWxrIiwibGltaXRzIiwibWF4RGVwdGgiLCJyZWN1cnNpdmVXYWxrIiwiYnVpbGRlciIsImVsbGlwc2lzIiwiaHRtbCIsInByb2Nlc3MiLCJ3YWxrIiwibWF4SW5wdXRMZW5ndGgiLCJjb25zb2xlIiwid2FybiIsImRvY3VtZW50IiwicGFyc2VEb2N1bWVudCIsImRlY29kZUVudGl0aWVzIiwiYmFzZXMiLCJjaGlsZHJlbiIsInJlc3VsdHMiLCJzbGljZSIsIm1heENoaWxkTm9kZXMiLCJlbGVtIiwidHlwZSIsInBpY2tlZFNlbGVjdG9ySW5kZXgiLCJwaWNrMSIsInNlbGVjdG9ySW5kZXgiLCJlbGVtZW50IiwibWF4QmFzZUVsZW1lbnRzIiwib3JkZXJCeSIsInNvcnQiLCJhIiwiYiIsInJldHVybkRvbUJ5RGVmYXVsdCIsIngiLCJ0b29NYW55Q2hpbGROb2RlcyIsImRhdGEiLCJ0YWdEZWZpbml0aW9uIiwiZm9ybWF0dGVycyIsImRpY3QiLCJrZXlzIiwiZW50cmllcyIsInJlZ2V4IiwicmVwbGFjZXIiLCJjZ3MiLCJmaW5kSW5kZXgiLCJjZyIsImZvcm1hdFNraXAiLCJmb3JtYXRPcHRpb25zIiwiZm9ybWF0SW5saW5lU3RyaW5nIiwic3RyaW5nIiwiZm9ybWF0QmxvY2tTdHJpbmciLCJmb3JtYXRJbmxpbmUiLCJmb3JtYXRCbG9jayQxIiwicmVuZGVyT3BlblRhZyIsImF0dHJzIiwiYXR0cmlicyIsImsiLCJuYW1lIiwicmVuZGVyQ2xvc2VUYWciLCJmb3JtYXRJbmxpbmVUYWciLCJmb3JtYXRCbG9ja1RhZyIsImZvcm1hdElubGluZUh0bWwiLCJyZW5kZXIiLCJmb3JtYXRCbG9ja0h0bWwiLCJmb3JtYXRJbmxpbmVTdXJyb3VuZCIsInN1ZmZpeCIsImdlbmVyaWNGb3JtYXR0ZXJzIiwiZnJlZXplIiwiX19wcm90b19fIiwiYmxvY2tIdG1sIiwiYmxvY2tTdHJpbmciLCJibG9ja1RhZyIsImlubGluZSIsImlubGluZUh0bWwiLCJpbmxpbmVTdHJpbmciLCJpbmxpbmVTdXJyb3VuZCIsImlubGluZVRhZyIsInNraXAiLCJnZXRSb3ciLCJtYXRyaXgiLCJqIiwiZmluZEZpcnN0VmFjYW50SW5kZXgiLCJ0cmFuc3Bvc2VJblBsYWNlIiwibWF4U2l6ZSIsInJvd0kiLCJyb3dKIiwidGVtcCIsInB1dENlbGxJbnRvTGF5b3V0IiwibGF5b3V0IiwiYmFzZVJvdyIsImJhc2VDb2wiLCJyIiwibGF5b3V0Um93IiwidXBkYXRlT2Zmc2V0Iiwib2Zmc2V0cyIsInNwYW4iLCJ0YWJsZVJvd3MiLCJyb3dTcGFjaW5nIiwiY29sU3BhY2luZyIsImNvbE51bWJlciIsInJvd051bWJlciIsInJvd09mZnNldHMiLCJzcGxpdCIsImNlbGxIZWlnaHQiLCJvdXRwdXRMaW5lcyIsImNvbE9mZnNldHMiLCJ5IiwicmVuZGVyZWQiLCJjZWxsV2lkdGgiLCJsaW5lIiwibGluZU9mZnNldCIsImZvcm1hdExpbmVCcmVhayIsImZvcm1hdFdiciIsImZvcm1hdEhvcml6b250YWxMaW5lIiwiZm9ybWF0UGFyYWdyYXBoIiwiZm9ybWF0UHJlIiwiZm9ybWF0SGVhZGluZyIsInVwcGVyY2FzZSIsInRvVXBwZXJDYXNlIiwiZm9ybWF0QmxvY2txdW90ZSIsInRyaW1FbXB0eUxpbmVzIiwid2l0aEJyYWNrZXRzIiwiYnJhY2tldHMiLCJsYnIiLCJyYnIiLCJwYXRoUmV3cml0ZSIsInJld3JpdGVyIiwiYmFzZVVybCIsIm1vZGlmaWVkUGF0aCIsImZvcm1hdEltYWdlIiwiYWx0IiwibGlua0JyYWNrZXRzIiwiZm9ybWF0QW5jaG9yIiwiZ2V0SHJlZiIsImlnbm9yZUhyZWYiLCJocmVmIiwibm9BbmNob3JVcmwiLCJoaWRlU2FtZUxpbmsiLCJoaWRlTGlua0hyZWZJZlNhbWVBc1RleHQiLCJmb3JtYXRMaXN0IiwibmV4dFByZWZpeENhbGxiYWNrIiwiaXNOZXN0ZWRMaXN0IiwibGlzdEl0ZW1zIiwiY2hpbGQiLCJub2RlIiwidHJpbVN0YXJ0IiwiZm9ybWF0VW5vcmRlcmVkTGlzdCIsIml0ZW1QcmVmaXgiLCJmb3JtYXRPcmRlcmVkTGlzdCIsIm5leHRJbmRleCIsImluZGV4RnVuY3Rpb24iLCJnZXRPcmRlcmVkTGlzdEluZGV4RnVuY3Rpb24iLCJvbFR5cGUiLCJ0b0xvd2VyQ2FzZSIsInNwbGl0Q2xhc3Nlc0FuZElkcyIsImNsYXNzZXMiLCJpZHMiLCJzdGFydHNXaXRoIiwiaXNEYXRhVGFibGUiLCJhdHRyIiwidGFibGVzIiwiYXR0ckNsYXNzZXMiLCJhdHRySWRzIiwic29tZSIsImluY2x1ZGVzIiwiZm9ybWF0VGFibGUiLCJmb3JtYXREYXRhVGFibGUiLCJmb3JtYXRCbG9jayIsImZvckVhY2giLCJ3YWxrVGFibGUiLCJmb3JtYXRDZWxsIiwiY2VsbE5vZGUiLCJmb3JtYXRIZWFkZXJDZWxsIiwidXBwZXJjYXNlSGVhZGVyQ2VsbHMiLCJjaGlsZE9mVHIiLCJ0ZXh0Rm9ybWF0dGVycyIsImFuY2hvciIsImJsb2NrcXVvdGUiLCJkYXRhVGFibGUiLCJoZWFkaW5nIiwiaG9yaXpvbnRhbExpbmUiLCJpbWFnZSIsImxpbmVCcmVhayIsIm9yZGVyZWRMaXN0IiwicGFyYWdyYXBoIiwicHJlIiwidW5vcmRlcmVkTGlzdCIsIndiciIsIkRFRkFVTFRfT1BUSU9OUyIsImxvbmdXb3JkU3BsaXQiLCJjb25jYXRNZXJnZSIsIm92ZXJ3cml0ZU1lcmdlIiwic2VsZWN0b3JzTWVyZ2UiLCJjb21waWxlIiwiY3VzdG9tTWVyZ2UiLCJhc3NpZ24iLCJoYW5kbGVEZXByZWNhdGVkT3B0aW9ucyIsImNvbnZlcnQiLCJ0YWdzIiwidGFnRGVmaW5pdGlvbnMiLCJkZWZpbml0aW9uIiwidmFsdWVLZXkiLCJuZXN0ZWQiLCJiYXNlRWxlbWVudCIsImlzQXJyYXkiLCJodG1sVG9UZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/html-to-text/lib/html-to-text.cjs\n");

/***/ })

};
;